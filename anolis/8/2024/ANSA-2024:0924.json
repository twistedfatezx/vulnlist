{
  "ID": "oval:cn.openanolis:def:20240924",
  "Version": "1",
  "Class": "patch",
  "Metadata": {
    "Title": "ANSA-2024:0924: kernel security update (Important)",
    "Affected": {
      "Family": "unix",
      "Platform": [
        "Anolis OS 8"
      ]
    },
    "References": [
      {
        "RefID": "ANSA-2024:0924",
        "RefURL": "https://anas.openanolis.cn/errata/detail/ANSA-2024:0924",
        "Source": "ANSA"
      }
    ],
    "Description": "Package updates are available for Anolis 8 that fix the following vulnerabilities:\n\nCVE-2021-46984:\nIn the Linux kernel, the following vulnerability has been resolved:\nkyber: fix out of bounds access when preempted\n__blk_mq_sched_bio_merge() gets the ctx and hctx for the current CPU and\npasses the hctx to -\u003ebio_merge(). kyber_bio_merge() then gets the ctx\nfor the current CPU again and uses that to get the corresponding Kyber\ncontext in the passed hctx. However, the thread may be preempted between\nthe two calls to blk_mq_get_ctx(), and the ctx returned the second time\nmay no longer correspond to the passed hctx. This \"works\" accidentally\nmost of the time, but it can cause us to read garbage if the second ctx\ncame from an hctx with more ctx's than the first one (i.e., if\nctx-\u003eindex_hw[hctx-\u003etype] \u003e hctx-\u003enr_ctx).\nThis manifested as this UBSAN array index out of bounds error reported\nby Jakub:\nUBSAN: array-index-out-of-bounds in ../kernel/locking/qspinlock.c:130:9\nindex 13106 is out of range for type 'long unsigned int [128]'\nCall Trace:\ndump_stack+0xa4/0xe5\nubsan_epilogue+0x5/0x40\n__ubsan_handle_out_of_bounds.cold.13+0x2a/0x34\nqueued_spin_lock_slowpath+0x476/0x480\ndo_raw_spin_lock+0x1c2/0x1d0\nkyber_bio_merge+0x112/0x180\nblk_mq_submit_bio+0x1f5/0x1100\nsubmit_bio_noacct+0x7b0/0x870\nsubmit_bio+0xc2/0x3a0\nbtrfs_map_bio+0x4f0/0x9d0\nbtrfs_submit_data_bio+0x24e/0x310\nsubmit_one_bio+0x7f/0xb0\nsubmit_extent_page+0xc4/0x440\n__extent_writepage_io+0x2b8/0x5e0\n__extent_writepage+0x28d/0x6e0\nextent_write_cache_pages+0x4d7/0x7a0\nextent_writepages+0xa2/0x110\ndo_writepages+0x8f/0x180\n__writeback_single_inode+0x99/0x7f0\nwriteback_sb_inodes+0x34e/0x790\n__writeback_inodes_wb+0x9e/0x120\nwb_writeback+0x4d2/0x660\nwb_workfn+0x64d/0xa10\nprocess_one_work+0x53a/0xa80\nworker_thread+0x69/0x5b0\nkthread+0x20b/0x240\nret_from_fork+0x1f/0x30\nOnly Kyber uses the hctx, so fix it by passing the request_queue to\n-\u003ebio_merge() instead. BFQ and mq-deadline just use that, and Kyber can\nmap the queues itself to avoid the mismatch.\n\nCVE-2021-47097:\nIn the Linux kernel, the following vulnerability has been resolved:\nInput: elantech - fix stack out of bound access in elantech_change_report_id()\nThe array param[] in elantech_change_report_id() must be at least 3\nbytes, because elantech_read_reg_params() is calling ps2_command() with\nPSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but\nit's defined in the stack as an array of 2 bytes, therefore we have a\npotential stack out-of-bounds access here, also confirmed by KASAN:\n[    6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0\n[    6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118\n[    6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110\n[    6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020\n[    6.512436] Workqueue: events_long serio_handle_event\n[    6.512453] Call Trace:\n[    6.512462]  show_stack+0x52/0x58\n[    6.512474]  dump_stack+0xa1/0xd3\n[    6.512487]  print_address_description.constprop.0+0x1d/0x140\n[    6.512502]  ? __ps2_command+0x372/0x7e0\n[    6.512516]  __kasan_report.cold+0x7d/0x112\n[    6.512527]  ? _raw_write_lock_irq+0x20/0xd0\n[    6.512539]  ? __ps2_command+0x372/0x7e0\n[    6.512552]  kasan_report+0x3c/0x50\n[    6.512564]  __asan_load1+0x6a/0x70\n[    6.512575]  __ps2_command+0x372/0x7e0\n[    6.512589]  ? ps2_drain+0x240/0x240\n[    6.512601]  ? dev_printk_emit+0xa2/0xd3\n[    6.512612]  ? dev_vprintk_emit+0xc5/0xc5\n[    6.512621]  ? __kasan_check_write+0x14/0x20\n[    6.512634]  ? mutex_lock+0x8f/0xe0\n[    6.512643]  ? __mutex_lock_slowpath+0x20/0x20\n[    6.512655]  ps2_command+0x52/0x90\n[    6.512670]  elantech_ps2_command+0x4f/0xc0 [psmouse]\n[    6.512734]  elantech_change_report_id+0x1e6/0x256 [psmouse]\n[    6.512799]  ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse]\n[    6.512863]  ? ps2_command+0x7f/0x90\n[    6.512877]  elantech_query_info.cold+0x6bd/0x9ed [psmouse]\n[    6.512943]  ? elantech_setup_ps2+0x460/0x460 [psmouse]\n[    6.513005]  ? psmouse_reset+0x69/0xb0 [psmouse]\n[    6.513064]  ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse]\n[    6.513122]  ? phys_pmd_init+0x30e/0x521\n[    6.513137]  elantech_init+0x8a/0x200 [psmouse]\n[    6.513200]  ? elantech_init_ps2+0xf0/0xf0 [psmouse]\n[    6.513249]  ? elantech_query_info+0x440/0x440 [psmouse]\n[    6.513296]  ? synaptics_send_cmd+0x60/0x60 [psmouse]\n[    6.513342]  ? elantech_query_info+0x440/0x440 [psmouse]\n[    6.513388]  ? psmouse_try_protocol+0x11e/0x170 [psmouse]\n[    6.513432]  psmouse_extensions+0x65d/0x6e0 [psmouse]\n[    6.513476]  ? psmouse_try_protocol+0x170/0x170 [psmouse]\n[    6.513519]  ? mutex_unlock+0x22/0x40\n[    6.513526]  ? ps2_command+0x7f/0x90\n[    6.513536]  ? psmouse_probe+0xa3/0xf0 [psmouse]\n[    6.513580]  psmouse_switch_protocol+0x27d/0x2e0 [psmouse]\n[    6.513624]  psmouse_connect+0x272/0x530 [psmouse]\n[    6.513669]  serio_driver_probe+0x55/0x70\n[    6.513679]  really_probe+0x190/0x720\n[    6.513689]  driver_probe_device+0x160/0x1f0\n[    6.513697]  device_driver_attach+0x119/0x130\n[    6.513705]  ? device_driver_attach+0x130/0x130\n[    6.513713]  __driver_attach+0xe7/0x1a0\n[    6.513720]  ? device_driver_attach+0x130/0x130\n[    6.513728]  bus_for_each_dev+0xfb/0x150\n[    6.513738]  ? subsys_dev_iter_exit+0x10/0x10\n[    6.513748]  ? _raw_write_unlock_bh+0x30/0x30\n[    6.513757]  driver_attach+0x2d/0x40\n[    6.513764]  serio_handle_event+0x199/0x3d0\n[    6.513775]  process_one_work+0x471/0x740\n[    6.513785]  worker_thread+0x2d2/0x790\n[    6.513794]  ? process_one_work+0x740/0x740\n[    6.513802]  kthread+0x1b4/0x1e0\n[    6.513809]  ? set_kthread_struct+0x80/0x80\n[    6.513816]  ret_from_fork+0x22/0x30\n[    6.513832] The buggy address belongs to the page:\n[    6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7\n[    6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff)\n[    6.513860] raw: 0\n---truncated---\n\nCVE-2021-47101:\nIn the Linux kernel, the following vulnerability has been resolved:\nasix: fix uninit-value in asix_mdio_read()\nasix_read_cmd() may read less than sizeof(smsr) bytes and in this case\nsmsr will be uninitialized.\nFail log:\nBUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]\nBUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497\nBUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497\nasix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]\nasix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497\nasix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497\n\nCVE-2021-47287:\nIn the Linux kernel, the following vulnerability has been resolved:\ndriver core: auxiliary bus: Fix memory leak when driver_register() fail\nIf driver_register() returns with error we need to free the memory\nallocated for auxdrv-\u003edriver.name before returning from\n__auxiliary_driver_register()\n\nCVE-2021-47289:\nIn the Linux kernel, the following vulnerability has been resolved:\nACPI: fix NULL pointer dereference\nCommit 71f642833284 (\"ACPI: utils: Fix reference counting in\nfor_each_acpi_dev_match()\") started doing \"acpi_dev_put()\" on a pointer\nthat was possibly NULL.  That fails miserably, because that helper\ninline function is not set up to handle that case.\nJust make acpi_dev_put() silently accept a NULL pointer, rather than\ncalling down to put_device() with an invalid offset off that NULL\npointer.\n\nCVE-2021-47321:\nIn the Linux kernel, the following vulnerability has been resolved:\nwatchdog: Fix possible use-after-free by calling del_timer_sync()\nThis driver's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself.\n\nCVE-2021-47338:\nIn the Linux kernel, the following vulnerability has been resolved:\nfbmem: Do not delete the mode that is still in use\nThe execution of fb_delete_videomode() is not based on the result of the\nprevious fbcon_mode_deleted(). As a result, the mode is directly deleted,\nregardless of whether it is still in use, which may cause UAF.\n==================================================================\nBUG: KASAN: use-after-free in fb_mode_is_equal+0x36e/0x5e0 \\\ndrivers/video/fbdev/core/modedb.c:924\nRead of size 4 at addr ffff88807e0ddb1c by task syz-executor.0/18962\nCPU: 2 PID: 18962 Comm: syz-executor.0 Not tainted 5.10.45-rc1+ #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ...\nCall Trace:\n__dump_stack lib/dump_stack.c:77 [inline]\ndump_stack+0x137/0x1be lib/dump_stack.c:118\nprint_address_description+0x6c/0x640 mm/kasan/report.c:385\n__kasan_report mm/kasan/report.c:545 [inline]\nkasan_report+0x13d/0x1e0 mm/kasan/report.c:562\nfb_mode_is_equal+0x36e/0x5e0 drivers/video/fbdev/core/modedb.c:924\nfbcon_mode_deleted+0x16a/0x220 drivers/video/fbdev/core/fbcon.c:2746\nfb_set_var+0x1e1/0xdb0 drivers/video/fbdev/core/fbmem.c:975\ndo_fb_ioctl+0x4d9/0x6e0 drivers/video/fbdev/core/fbmem.c:1108\nvfs_ioctl fs/ioctl.c:48 [inline]\n__do_sys_ioctl fs/ioctl.c:753 [inline]\n__se_sys_ioctl+0xfb/0x170 fs/ioctl.c:739\ndo_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\nentry_SYSCALL_64_after_hwframe+0x44/0xa9\nFreed by task 18960:\nkasan_save_stack mm/kasan/common.c:48 [inline]\nkasan_set_track+0x3d/0x70 mm/kasan/common.c:56\nkasan_set_free_info+0x17/0x30 mm/kasan/generic.c:355\n__kasan_slab_free+0x108/0x140 mm/kasan/common.c:422\nslab_free_hook mm/slub.c:1541 [inline]\nslab_free_freelist_hook+0xd6/0x1a0 mm/slub.c:1574\nslab_free mm/slub.c:3139 [inline]\nkfree+0xca/0x3d0 mm/slub.c:4121\nfb_delete_videomode+0x56a/0x820 drivers/video/fbdev/core/modedb.c:1104\nfb_set_var+0x1f3/0xdb0 drivers/video/fbdev/core/fbmem.c:978\ndo_fb_ioctl+0x4d9/0x6e0 drivers/video/fbdev/core/fbmem.c:1108\nvfs_ioctl fs/ioctl.c:48 [inline]\n__do_sys_ioctl fs/ioctl.c:753 [inline]\n__se_sys_ioctl+0xfb/0x170 fs/ioctl.c:739\ndo_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\nentry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nCVE-2021-47352:\nIn the Linux kernel, the following vulnerability has been resolved:\nvirtio-net: Add validation for used length\nThis adds validation for used length (might come\nfrom an untrusted device) to avoid data corruption\nor loss.\n\nCVE-2021-47383:\nIn the Linux kernel, the following vulnerability has been resolved:\ntty: Fix out-of-bound vmalloc access in imageblit\nThis issue happens when a userspace program does an ioctl\nFBIOPUT_VSCREENINFO passing the fb_var_screeninfo struct\ncontaining only the fields xres, yres, and bits_per_pixel\nwith values.\nIf this struct is the same as the previous ioctl, the\nvc_resize() detects it and doesn't call the resize_screen(),\nleaving the fb_var_screeninfo incomplete. And this leads to\nthe updatescrollmode() calculates a wrong value to\nfbcon_display-\u003evrows, which makes the real_y() return a\nwrong value of y, and that value, eventually, causes\nthe imageblit to access an out-of-bound address value.\nTo solve this issue I made the resize_screen() be called\neven if the screen does not need any resizing, so it will\n\"fix and fill\" the fb_var_screeninfo independently.\n\nCVE-2021-47384:\nIn the Linux kernel, the following vulnerability has been resolved:\nhwmon: (w83793) Fix NULL pointer dereference by removing unnecessary structure field\nIf driver read tmp value sufficient for\n(tmp \u0026 0x08) \u0026\u0026 (!(tmp \u0026 0x80)) \u0026\u0026 ((tmp \u0026 0x7) == ((tmp \u003e\u003e 4) \u0026 0x7))\nfrom device then Null pointer dereference occurs.\n(It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers)\nAlso lm75[] does not serve a purpose anymore after switching to\ndevm_i2c_new_dummy_device() in w83791d_detect_subclients().\nThe patch fixes possible NULL pointer dereference by removing lm75[].\nFound by Linux Driver Verification project (linuxtesting.org).\n[groeck: Dropped unnecessary continuation lines, fixed multi-line alignments]\n\nCVE-2021-47385:\nIn the Linux kernel, the following vulnerability has been resolved:\nhwmon: (w83792d) Fix NULL pointer dereference by removing unnecessary structure field\nIf driver read val value sufficient for\n(val \u0026 0x08) \u0026\u0026 (!(val \u0026 0x80)) \u0026\u0026 ((val \u0026 0x7) == ((val \u003e\u003e 4) \u0026 0x7))\nfrom device then Null pointer dereference occurs.\n(It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers)\nAlso lm75[] does not serve a purpose anymore after switching to\ndevm_i2c_new_dummy_device() in w83791d_detect_subclients().\nThe patch fixes possible NULL pointer dereference by removing lm75[].\nFound by Linux Driver Verification project (linuxtesting.org).\n[groeck: Dropped unnecessary continuation lines, fixed multipline alignment]\n\nCVE-2021-47386:\nIn the Linux kernel, the following vulnerability has been resolved:\nhwmon: (w83791d) Fix NULL pointer dereference by removing unnecessary structure field\nIf driver read val value sufficient for\n(val \u0026 0x08) \u0026\u0026 (!(val \u0026 0x80)) \u0026\u0026 ((val \u0026 0x7) == ((val \u003e\u003e 4) \u0026 0x7))\nfrom device then Null pointer dereference occurs.\n(It is possible if tmp = 0b0xyz1xyz, where same literals mean same numbers)\nAlso lm75[] does not serve a purpose anymore after switching to\ndevm_i2c_new_dummy_device() in w83791d_detect_subclients().\nThe patch fixes possible NULL pointer dereference by removing lm75[].\nFound by Linux Driver Verification project (linuxtesting.org).\n[groeck: Dropped unnecessary continuation lines, fixed multi-line alignment]\n\nCVE-2021-47393:\nIn the Linux kernel, the following vulnerability has been resolved:\nhwmon: (mlxreg-fan) Return non-zero value when fan current state is enforced from sysfs\nFan speed minimum can be enforced from sysfs. For example, setting\ncurrent fan speed to 20 is used to enforce fan speed to be at 100%\nspeed, 19 - to be not below 90% speed, etcetera. This feature provides\nability to limit fan speed according to some system wise\nconsiderations, like absence of some replaceable units or high system\nambient temperature.\nRequest for changing fan minimum speed is configuration request and can\nbe set only through 'sysfs' write procedure. In this situation value of\nargument 'state' is above nominal fan speed maximum.\nReturn non-zero code in this case to avoid\nthermal_cooling_device_stats_update() call, because in this case\nstatistics update violates thermal statistics table range.\nThe issues is observed in case kernel is configured with option\nCONFIG_THERMAL_STATISTICS.\nHere is the trace from KASAN:\n[  159.506659] BUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x7d/0xb0\n[  159.516016] Read of size 4 at addr ffff888116163840 by task hw-management.s/7444\n[  159.545625] Call Trace:\n[  159.548366]  dump_stack+0x92/0xc1\n[  159.552084]  ? thermal_cooling_device_stats_update+0x7d/0xb0\n[  159.635869]  thermal_zone_device_update+0x345/0x780\n[  159.688711]  thermal_zone_device_set_mode+0x7d/0xc0\n[  159.694174]  mlxsw_thermal_modules_init+0x48f/0x590 [mlxsw_core]\n[  159.700972]  ? mlxsw_thermal_set_cur_state+0x5a0/0x5a0 [mlxsw_core]\n[  159.731827]  mlxsw_thermal_init+0x763/0x880 [mlxsw_core]\n[  160.070233] RIP: 0033:0x7fd995909970\n[  160.074239] Code: 73 01 c3 48 8b 0d 28 d5 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 99 2d 2c 00 00 75 10 b8 01 00 00 00 0f 05 \u003c48\u003e 3d 01 f0 ff ..\n[  160.095242] RSP: 002b:00007fff54f5d938 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[  160.103722] RAX: ffffffffffffffda RBX: 0000000000000013 RCX: 00007fd995909970\n[  160.111710] RDX: 0000000000000013 RSI: 0000000001906008 RDI: 0000000000000001\n[  160.119699] RBP: 0000000001906008 R08: 00007fd995bc9760 R09: 00007fd996210700\n[  160.127687] R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000013\n[  160.135673] R13: 0000000000000001 R14: 00007fd995bc8600 R15: 0000000000000013\n[  160.143671]\n[  160.145338] Allocated by task 2924:\n[  160.149242]  kasan_save_stack+0x19/0x40\n[  160.153541]  __kasan_kmalloc+0x7f/0xa0\n[  160.157743]  __kmalloc+0x1a2/0x2b0\n[  160.161552]  thermal_cooling_device_setup_sysfs+0xf9/0x1a0\n[  160.167687]  __thermal_cooling_device_register+0x1b5/0x500\n[  160.173833]  devm_thermal_of_cooling_device_register+0x60/0xa0\n[  160.180356]  mlxreg_fan_probe+0x474/0x5e0 [mlxreg_fan]\n[  160.248140]\n[  160.249807] The buggy address belongs to the object at ffff888116163400\n[  160.249807]  which belongs to the cache kmalloc-1k of size 1024\n[  160.263814] The buggy address is located 64 bytes to the right of\n[  160.263814]  1024-byte region [ffff888116163400, ffff888116163800)\n[  160.277536] The buggy address belongs to the page:\n[  160.282898] page:0000000012275840 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888116167000 pfn:0x116160\n[  160.294872] head:0000000012275840 order:3 compound_mapcount:0 compound_pincount:0\n[  160.303251] flags: 0x200000000010200(slab|head|node=0|zone=2)\n[  160.309694] raw: 0200000000010200 ffffea00046f7208 ffffea0004928208 ffff88810004dbc0\n[  160.318367] raw: ffff888116167000 00000000000a0006 00000001ffffffff 0000000000000000\n[  160.327033] page dumped because: kasan: bad access detected\n[  160.333270]\n[  160.334937] Memory state around the buggy address:\n[  160.356469] \u003effff888116163800: fc ..\n\nCVE-2021-47412:\nIn the Linux kernel, the following vulnerability has been resolved:\nblock: don't call rq_qos_ops-\u003edone_bio if the bio isn't tracked\nrq_qos framework is only applied on request based driver, so:\n1) rq_qos_done_bio() needn't to be called for bio based driver\n2) rq_qos_done_bio() needn't to be called for bio which isn't tracked,\nsuch as bios ended from error handling code.\nEspecially in bio_endio():\n1) request queue is referred via bio-\u003ebi_bdev-\u003ebd_disk-\u003equeue, which\nmay be gone since request queue refcount may not be held in above two\ncases\n2) q-\u003erq_qos may be freed in blk_cleanup_queue() when calling into\n__rq_qos_done_bio()\nFix the potential kernel panic by not calling rq_qos_ops-\u003edone_bio if\nthe bio isn't tracked. This way is safe because both ioc_rqos_done_bio()\nand blkcg_iolatency_done_bio() are nop if the bio isn't tracked.\n\nCVE-2021-47432:\nIn the Linux kernel, the following vulnerability has been resolved:\nlib/generic-radix-tree.c: Don't overflow in peek()\nWhen we started spreading new inode numbers throughout most of the 64\nbit inode space, that triggered some corner case bugs, in particular\nsome integer overflows related to the radix tree code. Oops.\n\nCVE-2021-47441:\nIn the Linux kernel, the following vulnerability has been resolved:\nmlxsw: thermal: Fix out-of-bounds memory accesses\nCurrently, mlxsw allows cooling states to be set above the maximum\ncooling state supported by the driver:\n# cat /sys/class/thermal/thermal_zone2/cdev0/type\nmlxsw_fan\n# cat /sys/class/thermal/thermal_zone2/cdev0/max_state\n10\n# echo 18 \u003e /sys/class/thermal/thermal_zone2/cdev0/cur_state\n# echo $?\n0\nThis results in out-of-bounds memory accesses when thermal state\ntransition statistics are enabled (CONFIG_THERMAL_STATISTICS=y), as the\ntransition table is accessed with a too large index (state) [1].\nAccording to the thermal maintainer, it is the responsibility of the\ndriver to reject such operations [2].\nTherefore, return an error when the state to be set exceeds the maximum\ncooling state supported by the driver.\nTo avoid dead code, as suggested by the thermal maintainer [3],\npartially revert commit a421ce088ac8 (\"mlxsw: core: Extend cooling\ndevice with cooling levels\") that tried to interpret these invalid\ncooling states (above the maximum) in a special way. The cooling levels\narray is not removed in order to prevent the fans going below 20% PWM,\nwhich would cause them to get stuck at 0% PWM.\n[1]\nBUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x271/0x290\nRead of size 4 at addr ffff8881052f7bf8 by task kworker/0:0/5\nCPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.15.0-rc3-custom-45935-gce1adf704b14 #122\nHardware name: Mellanox Technologies Ltd. \"MSN2410-CB2FO\"/\"SA000874\", BIOS 4.6.5 03/08/2016\nWorkqueue: events_freezable_power_ thermal_zone_device_check\nCall Trace:\ndump_stack_lvl+0x8b/0xb3\nprint_address_description.constprop.0+0x1f/0x140\nkasan_report.cold+0x7f/0x11b\nthermal_cooling_device_stats_update+0x271/0x290\n__thermal_cdev_update+0x15e/0x4e0\nthermal_cdev_update+0x9f/0xe0\nstep_wise_throttle+0x770/0xee0\nthermal_zone_device_update+0x3f6/0xdf0\nprocess_one_work+0xa42/0x1770\nworker_thread+0x62f/0x13e0\nkthread+0x3ee/0x4e0\nret_from_fork+0x1f/0x30\nAllocated by task 1:\nkasan_save_stack+0x1b/0x40\n__kasan_kmalloc+0x7c/0x90\nthermal_cooling_device_setup_sysfs+0x153/0x2c0\n__thermal_cooling_device_register.part.0+0x25b/0x9c0\nthermal_cooling_device_register+0xb3/0x100\nmlxsw_thermal_init+0x5c5/0x7e0\n__mlxsw_core_bus_device_register+0xcb3/0x19c0\nmlxsw_core_bus_device_register+0x56/0xb0\nmlxsw_pci_probe+0x54f/0x710\nlocal_pci_probe+0xc6/0x170\npci_device_probe+0x2b2/0x4d0\nreally_probe+0x293/0xd10\n__driver_probe_device+0x2af/0x440\ndriver_probe_device+0x51/0x1e0\n__driver_attach+0x21b/0x530\nbus_for_each_dev+0x14c/0x1d0\nbus_add_driver+0x3ac/0x650\ndriver_register+0x241/0x3d0\nmlxsw_sp_module_init+0xa2/0x174\ndo_one_initcall+0xee/0x5f0\nkernel_init_freeable+0x45a/0x4de\nkernel_init+0x1f/0x210\nret_from_fork+0x1f/0x30\nThe buggy address belongs to the object at ffff8881052f7800\nwhich belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 1016 bytes inside of\n1024-byte region [ffff8881052f7800, ffff8881052f7c00)\nThe buggy address belongs to the page:\npage:0000000052355272 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1052f0\nhead:0000000052355272 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffffea0005034800 0000000300000003 ffff888100041dc0\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\nMemory state around the buggy address:\nffff8881052f7a80: 00 00 00 00 00 00 04 fc fc fc fc fc fc fc fc fc\nffff8881052f7b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\u003effff8881052f7b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n^\nffff8881052f7c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\nffff8881052f7c80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[2] https://lore.kernel.org/linux-pm/9aca37cb-1629-5c67-\n---truncated---\n\nCVE-2021-47455:\nIn the Linux kernel, the following vulnerability has been resolved:\nptp: Fix possible memory leak in ptp_clock_register()\nI got memory leak as follows when doing fault injection test:\nunreferenced object 0xffff88800906c618 (size 8):\ncomm \"i2c-idt82p33931\", pid 4421, jiffies 4294948083 (age 13.188s)\nhex dump (first 8 bytes):\n70 74 70 30 00 00 00 00                          ptp0....\nbacktrace:\n[\u003c00000000312ed458\u003e] __kmalloc_track_caller+0x19f/0x3a0\n[\u003c0000000079f6e2ff\u003e] kvasprintf+0xb5/0x150\n[\u003c0000000026aae54f\u003e] kvasprintf_const+0x60/0x190\n[\u003c00000000f323a5f7\u003e] kobject_set_name_vargs+0x56/0x150\n[\u003c000000004e35abdd\u003e] dev_set_name+0xc0/0x100\n[\u003c00000000f20cfe25\u003e] ptp_clock_register+0x9f4/0xd30 [ptp]\n[\u003c000000008bb9f0de\u003e] idt82p33_probe.cold+0x8b6/0x1561 [ptp_idt82p33]\nWhen posix_clock_register() returns an error, the name allocated\nin dev_set_name() will be leaked, the put_device() should be used\nto give up the device reference, then the name will be freed in\nkobject_cleanup() and other memory will be freed in ptp_clock_release().\n\nCVE-2021-47466:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm, slub: fix potential memoryleak in kmem_cache_open()\nIn error path, the random_seq of slub cache might be leaked.  Fix this\nby using __kmem_cache_release() to release all the relevant resources.\n\nCVE-2021-47497:\nIn the Linux kernel, the following vulnerability has been resolved:\nnvmem: Fix shift-out-of-bound (UBSAN) with byte size cells\nIf a cell has 'nbits' equal to a multiple of BITS_PER_BYTE the logic\n*p \u0026= GENMASK((cell-\u003enbits%BITS_PER_BYTE) - 1, 0);\nwill become undefined behavior because nbits modulo BITS_PER_BYTE is 0, and we\nsubtract one from that making a large number that is then shifted more than the\nnumber of bits that fit into an unsigned long.\nUBSAN reports this problem:\nUBSAN: shift-out-of-bounds in drivers/nvmem/core.c:1386:8\nshift exponent 64 is too large for 64-bit type 'unsigned long'\nCPU: 6 PID: 7 Comm: kworker/u16:0 Not tainted 5.15.0-rc3+ #9\nHardware name: Google Lazor (rev3+) with KB Backlight (DT)\nWorkqueue: events_unbound deferred_probe_work_func\nCall trace:\ndump_backtrace+0x0/0x170\nshow_stack+0x24/0x30\ndump_stack_lvl+0x64/0x7c\ndump_stack+0x18/0x38\nubsan_epilogue+0x10/0x54\n__ubsan_handle_shift_out_of_bounds+0x180/0x194\n__nvmem_cell_read+0x1ec/0x21c\nnvmem_cell_read+0x58/0x94\nnvmem_cell_read_variable_common+0x4c/0xb0\nnvmem_cell_read_variable_le_u32+0x40/0x100\na6xx_gpu_init+0x170/0x2f4\nadreno_bind+0x174/0x284\ncomponent_bind_all+0xf0/0x264\nmsm_drm_bind+0x1d8/0x7a0\ntry_to_bring_up_master+0x164/0x1ac\n__component_add+0xbc/0x13c\ncomponent_add+0x20/0x2c\ndp_display_probe+0x340/0x384\nplatform_probe+0xc0/0x100\nreally_probe+0x110/0x304\n__driver_probe_device+0xb8/0x120\ndriver_probe_device+0x4c/0xfc\n__device_attach_driver+0xb0/0x128\nbus_for_each_drv+0x90/0xdc\n__device_attach+0xc8/0x174\ndevice_initial_probe+0x20/0x2c\nbus_probe_device+0x40/0xa4\ndeferred_probe_work_func+0x7c/0xb8\nprocess_one_work+0x128/0x21c\nprocess_scheduled_works+0x40/0x54\nworker_thread+0x1ec/0x2a8\nkthread+0x138/0x158\nret_from_fork+0x10/0x20\nFix it by making sure there are any bits to mask out.\n\nCVE-2021-47527:\nIn the Linux kernel, the following vulnerability has been resolved:\nserial: core: fix transmit-buffer reset and memleak\nCommit 761ed4a94582 (\"tty: serial_core: convert uart_close to use\ntty_port_close\") converted serial core to use tty_port_close() but\nfailed to notice that the transmit buffer still needs to be freed on\nfinal close.\nNot freeing the transmit buffer means that the buffer is no longer\ncleared on next open so that any ioctl() waiting for the buffer to drain\nmight wait indefinitely (e.g. on termios changes) or that stale data can\nend up being transmitted in case tx is restarted.\nFurthermore, the buffer of any port that has been opened would leak on\ndriver unbind.\nNote that the port lock is held when clearing the buffer pointer due to\nthe ldisc race worked around by commit a5ba1d95e46e (\"uart: fix race\nbetween uart_put_char() and uart_shutdown()\").\nAlso note that the tty-port shutdown() callback is not called for\nconsole ports so it is not strictly necessary to free the buffer page\nafter releasing the lock (cf. d72402145ace (\"tty/serial: do not free\ntrasnmit buffer page under port lock\")).\n\nCVE-2021-47560:\nIn the Linux kernel, the following vulnerability has been resolved:\nmlxsw: spectrum: Protect driver from buggy firmware\nWhen processing port up/down events generated by the device's firmware,\nthe driver protects itself from events reported for non-existent local\nports, but not the CPU port (local port 0), which exists, but lacks a\nnetdev.\nThis can result in a NULL pointer dereference when calling\nnetif_carrier_{on,off}().\nFix this by bailing early when processing an event reported for the CPU\nport. Problem was only observed when running on top of a buggy emulator.\n\nCVE-2021-47582:\nIn the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Make do_proc_control() and do_proc_bulk() killable\nThe USBDEVFS_CONTROL and USBDEVFS_BULK ioctls invoke\nusb_start_wait_urb(), which contains an uninterruptible wait with a\nuser-specified timeout value.  If timeout value is very large and the\ndevice being accessed does not respond in a reasonable amount of time,\nthe kernel will complain about \"Task X blocked for more than N\nseconds\", as found in testing by syzbot:\nINFO: task syz-executor.0:8700 blocked for more than 143 seconds.\nNot tainted 5.14.0-rc7-syzkaller #0\n\"echo 0 \u003e /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\ntask:syz-executor.0  state:D stack:23192 pid: 8700 ppid:  8455 flags:0x00004004\nCall Trace:\ncontext_switch kernel/sched/core.c:4681 [inline]\n__schedule+0xc07/0x11f0 kernel/sched/core.c:5938\nschedule+0x14b/0x210 kernel/sched/core.c:6017\nschedule_timeout+0x98/0x2f0 kernel/time/timer.c:1857\ndo_wait_for_common+0x2da/0x480 kernel/sched/completion.c:85\n__wait_for_common kernel/sched/completion.c:106 [inline]\nwait_for_common kernel/sched/completion.c:117 [inline]\nwait_for_completion_timeout+0x46/0x60 kernel/sched/completion.c:157\nusb_start_wait_urb+0x167/0x550 drivers/usb/core/message.c:63\ndo_proc_bulk+0x978/0x1080 drivers/usb/core/devio.c:1236\nproc_bulk drivers/usb/core/devio.c:1273 [inline]\nusbdev_do_ioctl drivers/usb/core/devio.c:2547 [inline]\nusbdev_ioctl+0x3441/0x6b10 drivers/usb/core/devio.c:2713\n...\nTo fix this problem, this patch replaces usbfs's calls to\nusb_control_msg() and usb_bulk_msg() with special-purpose code that\ndoes essentially the same thing (as recommended in the comment for\nusb_start_wait_urb()), except that it always uses a killable wait and\nit uses GFP_KERNEL rather than GFP_NOIO.\n\nCVE-2021-47609:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirmware: arm_scpi: Fix string overflow in SCPI genpd driver\nWithout the bound checks for scpi_pd-\u003ename, it could result in the buffer\noverflow when copying the SCPI device name from the corresponding device\ntree node as the name string is set at maximum size of 30.\nLet us fix it by using devm_kasprintf so that the string buffer is\nallocated dynamically.\n\nCVE-2022-48619:\nAn issue was discovered in drivers/input/input.c in the Linux kernel before 5.17.10. An attacker can cause a denial of service (panic) because input_set_capability mishandles the situation in which an event code falls outside of a bitmap.\n\nCVE-2022-48754:\nIn the Linux kernel, the following vulnerability has been resolved:\nphylib: fix potential use-after-free\nCommit bafbdd527d56 (\"phylib: Add device reset GPIO support\") added call\nto phy_device_reset(phydev) after the put_device() call in phy_detach().\nThe comment before the put_device() call says that the phydev might go\naway with put_device().\nFix potential use-after-free by calling phy_device_reset() before\nput_device().\n\nCVE-2022-48760:\nIn the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Fix hang in usb_kill_urb by adding memory barriers\nThe syzbot fuzzer has identified a bug in which processes hang waiting\nfor usb_kill_urb() to return.  It turns out the issue is not unlinking\nthe URB; that works just fine.  Rather, the problem arises when the\nwakeup notification that the URB has completed is not received.\nThe reason is memory-access ordering on SMP systems.  In outline form,\nusb_kill_urb() and __usb_hcd_giveback_urb() operating concurrently on\ndifferent CPUs perform the following actions:\nCPU 0CPU 1\n-------------------------------------------------------------\nusb_kill_urb():__usb_hcd_giveback_urb():\n...  ...\natomic_inc(\u0026urb-\u003ereject);  atomic_dec(\u0026urb-\u003euse_count);\n...  ...\nwait_event(usb_kill_urb_queue,\natomic_read(\u0026urb-\u003euse_count) == 0);\nif (atomic_read(\u0026urb-\u003ereject))\nwake_up(\u0026usb_kill_urb_queue);\nConfining your attention to urb-\u003ereject and urb-\u003euse_count, you can\nsee that the overall pattern of accesses on CPU 0 is:\nwrite urb-\u003ereject, then read urb-\u003euse_count;\nwhereas the overall pattern of accesses on CPU 1 is:\nwrite urb-\u003euse_count, then read urb-\u003ereject.\nThis pattern is referred to in memory-model circles as SB (for \"Store\nBuffering\"), and it is well known that without suitable enforcement of\nthe desired order of accesses -- in the form of memory barriers -- it\nis entirely possible for one or both CPUs to execute their reads ahead\nof their writes.  The end result will be that sometimes CPU 0 sees the\nold un-decremented value of urb-\u003euse_count while CPU 1 sees the old\nun-incremented value of urb-\u003ereject.  Consequently CPU 0 ends up on\nthe wait queue and never gets woken up, leading to the observed hang\nin usb_kill_urb().\nThe same pattern of accesses occurs in usb_poison_urb() and the\nfailure pathway of usb_hcd_submit_urb().\nThe problem is fixed by adding suitable memory barriers.  To provide\nproper memory-access ordering in the SB pattern, a full barrier is\nrequired on both CPUs.  The atomic_inc() and atomic_dec() accesses\nthemselves don't provide any memory ordering, but since they are\npresent, we can use the optimized smp_mb__after_atomic() memory\nbarrier in the various routines to obtain the desired effect.\nThis patch adds the necessary memory barriers.\n\nCVE-2022-48804:\nIn the Linux kernel, the following vulnerability has been resolved:\nvt_ioctl: fix array_index_nospec in vt_setactivate\narray_index_nospec ensures that an out-of-bounds value is set to zero\non the transient path. Decreasing the value by one afterwards causes\na transient integer underflow. vsa.console should be decreased first\nand then sanitized with array_index_nospec.\nKasper Acknowledgements: Jakob Koschel, Brian Johannesmeyer, Kaveh\nRazavi, Herbert Bos, Cristiano Giuffrida from the VUSec group at VU\nAmsterdam.\n\nCVE-2022-48836:\nIn the Linux kernel, the following vulnerability has been resolved:\nInput: aiptek - properly check endpoint type\nSyzbot reported warning in usb_submit_urb() which is caused by wrong\nendpoint type. There was a check for the number of endpoints, but not\nfor the type of endpoint.\nFix it by replacing old desc.bNumEndpoints check with\nusb_find_common_endpoints() helper for finding endpoints\nFail log:\nusb 5-1: BOGUS urb xfer, pipe 1 != type 3\nWARNING: CPU: 2 PID: 48 at drivers/usb/core/urb.c:502 usb_submit_urb+0xed2/0x18a0 drivers/usb/core/urb.c:502\nModules linked in:\nCPU: 2 PID: 48 Comm: kworker/2:2 Not tainted 5.17.0-rc6-syzkaller-00226-g07ebd38a0da2 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014\nWorkqueue: usb_hub_wq hub_event\n...\nCall Trace:\n\u003cTASK\u003e\naiptek_open+0xd5/0x130 drivers/input/tablet/aiptek.c:830\ninput_open_device+0x1bb/0x320 drivers/input/input.c:629\nkbd_connect+0xfe/0x160 drivers/tty/vt/keyboard.c:1593\n\nCVE-2022-48866:\nIn the Linux kernel, the following vulnerability has been resolved:\nHID: hid-thrustmaster: fix OOB read in thrustmaster_interrupts\nSyzbot reported an slab-out-of-bounds Read in thrustmaster_probe() bug.\nThe root case is in missing validation check of actual number of endpoints.\nCode should not blindly access usb_host_interface::endpoint array, since\nit may contain less endpoints than code expects.\nFix it by adding missing validaion check and print an error if\nnumber of endpoints do not match expected number\n\nCVE-2023-52470:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/radeon: check the alloc_workqueue return value in radeon_crtc_init()\ncheck the alloc_workqueue return value in radeon_crtc_init()\nto avoid null-ptr-deref.\n\nCVE-2023-52476:\nIn the Linux kernel, the following vulnerability has been resolved:\nperf/x86/lbr: Filter vsyscall addresses\nWe found that a panic can occur when a vsyscall is made while LBR sampling\nis active. If the vsyscall is interrupted (NMI) for perf sampling, this\ncall sequence can occur (most recent at top):\n__insn_get_emulate_prefix()\ninsn_get_emulate_prefix()\ninsn_get_prefixes()\ninsn_get_opcode()\ndecode_branch_type()\nget_branch_type()\nintel_pmu_lbr_filter()\nintel_pmu_handle_irq()\nperf_event_nmi_handler()\nWithin __insn_get_emulate_prefix() at frame 0, a macro is called:\npeek_nbyte_next(insn_byte_t, insn, i)\nWithin this macro, this dereference occurs:\n(insn)-\u003enext_byte\nInspecting registers at this point, the value of the next_byte field is the\naddress of the vsyscall made, for example the location of the vsyscall\nversion of gettimeofday() at 0xffffffffff600000. The access to an address\nin the vsyscall region will trigger an oops due to an unhandled page fault.\nTo fix the bug, filtering for vsyscalls can be done when\ndetermining the branch type. This patch will return\na \"none\" branch if a kernel address if found to lie in the\nvsyscall region.\n\nCVE-2023-52478:\nIn the Linux kernel, the following vulnerability has been resolved:\nHID: logitech-hidpp: Fix kernel crash on receiver USB disconnect\nhidpp_connect_event() has *four* time-of-check vs time-of-use (TOCTOU)\nraces when it races with itself.\nhidpp_connect_event() primarily runs from a workqueue but it also runs\non probe() and if a \"device-connected\" packet is received by the hw\nwhen the thread running hidpp_connect_event() from probe() is waiting on\nthe hw, then a second thread running hidpp_connect_event() will be\nstarted from the workqueue.\nThis opens the following races (note the below code is simplified):\n1. Retrieving + printing the protocol (harmless race):\nif (!hidpp-\u003eprotocol_major) {\nhidpp_root_get_protocol_version()\nhidpp-\u003eprotocol_major = response.rap.params[0];\n}\nWe can actually see this race hit in the dmesg in the abrt output\nattached to rhbz#2227968:\n[ 3064.624215] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected.\n[ 3064.658184] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected.\nTesting with extra logging added has shown that after this the 2 threads\ntake turn grabbing the hw access mutex (send_mutex) so they ping-pong\nthrough all the other TOCTOU cases managing to hit all of them:\n2. Updating the name to the HIDPP name (harmless race):\nif (hidpp-\u003ename == hdev-\u003ename) {\n...\nhidpp-\u003ename = new_name;\n}\n3. Initializing the power_supply class for the battery (problematic!):\nhidpp_initialize_battery()\n{\nif (hidpp-\u003ebattery.ps)\nreturn 0;\nprobe_battery(); /* Blocks, threads take turns executing this */\nhidpp-\u003ebattery.desc.properties =\ndevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);\nhidpp-\u003ebattery.ps =\ndevm_power_supply_register(\u0026hidpp-\u003ehid_dev-\u003edev,\n\u0026hidpp-\u003ebattery.desc, cfg);\n}\n4. Creating delayed input_device (potentially problematic):\nif (hidpp-\u003edelayed_input)\nreturn;\nhidpp-\u003edelayed_input = hidpp_allocate_input(hdev);\nThe really big problem here is 3. Hitting the race leads to the following\nsequence:\nhidpp-\u003ebattery.desc.properties =\ndevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);\nhidpp-\u003ebattery.ps =\ndevm_power_supply_register(\u0026hidpp-\u003ehid_dev-\u003edev,\n\u0026hidpp-\u003ebattery.desc, cfg);\n...\nhidpp-\u003ebattery.desc.properties =\ndevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);\nhidpp-\u003ebattery.ps =\ndevm_power_supply_register(\u0026hidpp-\u003ehid_dev-\u003edev,\n\u0026hidpp-\u003ebattery.desc, cfg);\nSo now we have registered 2 power supplies for the same battery,\nwhich looks a bit weird from userspace's pov but this is not even\nthe really big problem.\nNotice how:\n1. This is all devm-maganaged\n2. The hidpp-\u003ebattery.desc struct is shared between the 2 power supplies\n3. hidpp-\u003ebattery.desc.properties points to the result from the second\ndevm_kmemdup()\nThis causes a use after free scenario on USB disconnect of the receiver:\n1. The last registered power supply class device gets unregistered\n2. The memory from the last devm_kmemdup() call gets freed,\nhidpp-\u003ebattery.desc.properties now points to freed memory\n3. The first registered power supply class device gets unregistered,\nthis involves sending a remove uevent to userspace which invokes\npower_supply_uevent() to fill the uevent data\n4. power_supply_uevent() uses hidpp-\u003ebattery.desc.properties which\nnow points to freed memory leading to backtraces like this one:\nSep 22 20:01:35 eric kernel: BUG: unable to handle page fault for address: ffffb2140e017f08\n...\nSep 22 20:01:35 eric kernel: Workqueue: usb_hub_wq hub_event\nSep 22 20:01:35 eric kernel: RIP: 0010:power_supply_uevent+0xee/0x1d0\n...\nSep 22 20:01:35 eric kernel:  ? asm_exc_page_fault+0x26/0x30\nSep 22 20:01:35 eric kernel:  ? power_supply_uevent+0xee/0x1d0\nSep 22 20:01:35 eric kernel:  ? power_supply_uevent+0x10d/0x1d0\nSep 22 20:01:35 eric kernel:  dev_uevent+0x10f/0x2d0\nSep 22 20:01:35 eric kernel:  kobject_uevent_env+0x291/0x680\nSep 22 20:01:35 eric kernel:  \n---truncated---\n\nCVE-2023-52522:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: fix possible store tearing in neigh_periodic_work()\nWhile looking at a related syzbot report involving neigh_periodic_work(),\nI found that I forgot to add an annotation when deleting an\nRCU protected item from a list.\nReaders use rcu_deference(*np), we need to use either\nrcu_assign_pointer() or WRITE_ONCE() on writer side\nto prevent store tearing.\nI use rcu_assign_pointer() to have lockdep support,\nthis was the choice made in neigh_flush_dev().\n\nCVE-2023-52605:\nThis CVE ID has been rejected or withdrawn by its CVE Numbering Authority for the following reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.\n\nCVE-2023-52683:\nIn the Linux kernel, the following vulnerability has been resolved:\nACPI: LPIT: Avoid u32 multiplication overflow\nIn lpit_update_residency() there is a possibility of overflow\nin multiplication, if tsc_khz is large enough (\u003e UINT_MAX/1000).\nChange multiplication to mul_u32_u32().\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\n\nCVE-2023-52798:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: ath11k: fix dfs radar event locking\nThe ath11k active pdevs are protected by RCU but the DFS radar event\nhandling code calling ath11k_mac_get_ar_by_pdev_id() was not marked as a\nread-side critical section.\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\nCompile tested only.\n\nCVE-2023-52800:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: ath11k: fix htt pktlog locking\nThe ath11k active pdevs are protected by RCU but the htt pktlog handling\ncode calling ath11k_mac_get_ar_by_pdev_id() was not marked as a\nread-side critical section.\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\nCompile tested only.\n\nCVE-2023-52809:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: libfc: Fix potential NULL pointer dereference in fc_lport_ptp_setup()\nfc_lport_ptp_setup() did not check the return value of fc_rport_create()\nwhich can return NULL and would cause a NULL pointer dereference. Address\nthis issue by checking return value of fc_rport_create() and log error\nmessage on fc_rport_create() failed.\n\nCVE-2023-52817:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Fix a null pointer access when the smc_rreg pointer is NULL\nIn certain types of chips, such as VEGA20, reading the amdgpu_regs_smc file could result in an abnormal null pointer access when the smc_rreg pointer is NULL. Below are the steps to reproduce this issue and the corresponding exception log:\n1. Navigate to the directory: /sys/kernel/debug/dri/0\n2. Execute command: cat amdgpu_regs_smc\n3. Exception Log::\n[4005007.702554] BUG: kernel NULL pointer dereference, address: 0000000000000000\n[4005007.702562] #PF: supervisor instruction fetch in kernel mode\n[4005007.702567] #PF: error_code(0x0010) - not-present page\n[4005007.702570] PGD 0 P4D 0\n[4005007.702576] Oops: 0010 [#1] SMP NOPTI\n[4005007.702581] CPU: 4 PID: 62563 Comm: cat Tainted: G           OE     5.15.0-43-generic #46-Ubunt       u\n[4005007.702590] RIP: 0010:0x0\n[4005007.702598] Code: Unable to access opcode bytes at RIP 0xffffffffffffffd6.\n[4005007.702600] RSP: 0018:ffffa82b46d27da0 EFLAGS: 00010206\n[4005007.702605] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffa82b46d27e68\n[4005007.702609] RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9940656e0000\n[4005007.702612] RBP: ffffa82b46d27dd8 R08: 0000000000000000 R09: ffff994060c07980\n[4005007.702615] R10: 0000000000020000 R11: 0000000000000000 R12: 00007f5e06753000\n[4005007.702618] R13: ffff9940656e0000 R14: ffffa82b46d27e68 R15: 00007f5e06753000\n[4005007.702622] FS:  00007f5e0755b740(0000) GS:ffff99479d300000(0000) knlGS:0000000000000000\n[4005007.702626] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[4005007.702629] CR2: ffffffffffffffd6 CR3: 00000003253fc000 CR4: 00000000003506e0\n[4005007.702633] Call Trace:\n[4005007.702636]  \u003cTASK\u003e\n[4005007.702640]  amdgpu_debugfs_regs_smc_read+0xb0/0x120 [amdgpu]\n[4005007.703002]  full_proxy_read+0x5c/0x80\n[4005007.703011]  vfs_read+0x9f/0x1a0\n[4005007.703019]  ksys_read+0x67/0xe0\n[4005007.703023]  __x64_sys_read+0x19/0x20\n[4005007.703028]  do_syscall_64+0x5c/0xc0\n[4005007.703034]  ? do_user_addr_fault+0x1e3/0x670\n[4005007.703040]  ? exit_to_user_mode_prepare+0x37/0xb0\n[4005007.703047]  ? irqentry_exit_to_user_mode+0x9/0x20\n[4005007.703052]  ? irqentry_exit+0x19/0x30\n[4005007.703057]  ? exc_page_fault+0x89/0x160\n[4005007.703062]  ? asm_exc_page_fault+0x8/0x30\n[4005007.703068]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[4005007.703075] RIP: 0033:0x7f5e07672992\n[4005007.703079] Code: c0 e9 b2 fe ff ff 50 48 8d 3d fa b2 0c 00 e8 c5 1d 02 00 0f 1f 44 00 00 f3 0f        1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 e       c 28 48 89 54 24\n[4005007.703083] RSP: 002b:00007ffe03097898 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\n[4005007.703088] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5e07672992\n[4005007.703091] RDX: 0000000000020000 RSI: 00007f5e06753000 RDI: 0000000000000003\n[4005007.703094] RBP: 00007f5e06753000 R08: 00007f5e06752010 R09: 00007f5e06752010\n[4005007.703096] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000022000\n[4005007.703099] R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000\n[4005007.703105]  \u003c/TASK\u003e\n[4005007.703107] Modules linked in: nf_tables libcrc32c nfnetlink algif_hash af_alg binfmt_misc nls_       iso8859_1 ipmi_ssif ast intel_rapl_msr intel_rapl_common drm_vram_helper drm_ttm_helper amd64_edac t       tm edac_mce_amd kvm_amd ccp mac_hid k10temp kvm acpi_ipmi ipmi_si rapl sch_fq_codel ipmi_devintf ipm       i_msghandler msr parport_pc ppdev lp parport mtd pstore_blk efi_pstore ramoops pstore_zone reed_solo       mon ip_tables x_tables autofs4 ib_uverbs ib_core amdgpu(OE) amddrm_ttm_helper(OE) amdttm(OE) iommu_v       2 amd_sched(OE) amdkcl(OE) drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops cec rc_core        drm igb ahci xhci_pci libahci i2c_piix4 i2c_algo_bit xhci_pci_renesas dca\n[4005007.703184] CR2: 0000000000000000\n[4005007.703188] ---[ en\n---truncated---\n\nCVE-2023-52840:\nIn the Linux kernel, the following vulnerability has been resolved:\nInput: synaptics-rmi4 - fix use after free in rmi_unregister_function()\nThe put_device() calls rmi_release_function() which frees \"fn\" so the\ndereference on the next line \"fn-\u003enum_of_irqs\" is a use after free.\nMove the put_device() to the end to fix this.\n\nCVE-2023-6040:\nAn out-of-bounds access vulnerability involving netfilter was reported and fixed as: f1082dd31fe4 (netfilter: nf_tables: Reject tables of unsupported family); While creating a new netfilter table, lack of a safeguard against invalid nf_tables family (pf) values within `nf_tables_newtable` function enables an attacker to achieve out-of-bounds access.\n\nCVE-2024-23848:\nIn the Linux kernel through 6.7.1, there is a use-after-free in cec_queue_msg_fh, related to drivers/media/cec/core/cec-adap.c and drivers/media/cec/core/cec-api.c.\n\nCVE-2024-26595:\nIn the Linux kernel, the following vulnerability has been resolved:\nmlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error path\nWhen calling mlxsw_sp_acl_tcam_region_destroy() from an error path after\nfailing to attach the region to an ACL group, we hit a NULL pointer\ndereference upon 'region-\u003egroup-\u003etcam' [1].\nFix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam().\n[1]\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n[...]\nRIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0\n[...]\nCall Trace:\nmlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20\nmlxsw_sp_acl_tcam_ventry_add+0x25/0xe0\nmlxsw_sp_acl_rule_add+0x47/0x240\nmlxsw_sp_flower_replace+0x1a9/0x1d0\ntc_setup_cb_add+0xdc/0x1c0\nfl_hw_replace_filter+0x146/0x1f0\nfl_change+0xc17/0x1360\ntc_new_tfilter+0x472/0xb90\nrtnetlink_rcv_msg+0x313/0x3b0\nnetlink_rcv_skb+0x58/0x100\nnetlink_unicast+0x244/0x390\nnetlink_sendmsg+0x1e4/0x440\n____sys_sendmsg+0x164/0x260\n___sys_sendmsg+0x9a/0xe0\n__sys_sendmsg+0x7a/0xc0\ndo_syscall_64+0x40/0xe0\nentry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nCVE-2024-26600:\nIn the Linux kernel, the following vulnerability has been resolved:\nphy: ti: phy-omap-usb2: Fix NULL pointer dereference for SRP\nIf the external phy working together with phy-omap-usb2 does not implement\nsend_srp(), we may still attempt to call it. This can happen on an idle\nEthernet gadget triggering a wakeup for example:\nconfigfs-gadget.g1 gadget.0: ECM Suspend\nconfigfs-gadget.g1 gadget.0: Port suspended. Triggering wakeup\n...\nUnable to handle kernel NULL pointer dereference at virtual address\n00000000 when execute\n...\nPC is at 0x0\nLR is at musb_gadget_wakeup+0x1d4/0x254 [musb_hdrc]\n...\nmusb_gadget_wakeup [musb_hdrc] from usb_gadget_wakeup+0x1c/0x3c [udc_core]\nusb_gadget_wakeup [udc_core] from eth_start_xmit+0x3b0/0x3d4 [u_ether]\neth_start_xmit [u_ether] from dev_hard_start_xmit+0x94/0x24c\ndev_hard_start_xmit from sch_direct_xmit+0x104/0x2e4\nsch_direct_xmit from __dev_queue_xmit+0x334/0xd88\n__dev_queue_xmit from arp_solicit+0xf0/0x268\narp_solicit from neigh_probe+0x54/0x7c\nneigh_probe from __neigh_event_send+0x22c/0x47c\n__neigh_event_send from neigh_resolve_output+0x14c/0x1c0\nneigh_resolve_output from ip_finish_output2+0x1c8/0x628\nip_finish_output2 from ip_send_skb+0x40/0xd8\nip_send_skb from udp_send_skb+0x124/0x340\nudp_send_skb from udp_sendmsg+0x780/0x984\nudp_sendmsg from __sys_sendto+0xd8/0x158\n__sys_sendto from ret_fast_syscall+0x0/0x58\nLet's fix the issue by checking for send_srp() and set_vbus() before\ncalling them. For USB peripheral only cases these both could be NULL.\n\nCVE-2024-26638:\nIn the Linux kernel, the following vulnerability has been resolved:\nnbd: always initialize struct msghdr completely\nsyzbot complains that msg-\u003emsg_get_inq value can be uninitialized [1]\nstruct msghdr got many new fields recently, we should always make\nsure their values is zero by default.\n[1]\nBUG: KMSAN: uninit-value in tcp_recvmsg+0x686/0xac0 net/ipv4/tcp.c:2571\ntcp_recvmsg+0x686/0xac0 net/ipv4/tcp.c:2571\ninet_recvmsg+0x131/0x580 net/ipv4/af_inet.c:879\nsock_recvmsg_nosec net/socket.c:1044 [inline]\nsock_recvmsg+0x12b/0x1e0 net/socket.c:1066\n__sock_xmit+0x236/0x5c0 drivers/block/nbd.c:538\nnbd_read_reply drivers/block/nbd.c:732 [inline]\nrecv_work+0x262/0x3100 drivers/block/nbd.c:863\nprocess_one_work kernel/workqueue.c:2627 [inline]\nprocess_scheduled_works+0x104e/0x1e70 kernel/workqueue.c:2700\nworker_thread+0xf45/0x1490 kernel/workqueue.c:2781\nkthread+0x3ed/0x540 kernel/kthread.c:388\nret_from_fork+0x66/0x80 arch/x86/kernel/process.c:147\nret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\nLocal variable msg created at:\n__sock_xmit+0x4c/0x5c0 drivers/block/nbd.c:513\nnbd_read_reply drivers/block/nbd.c:732 [inline]\nrecv_work+0x262/0x3100 drivers/block/nbd.c:863\nCPU: 1 PID: 7465 Comm: kworker/u5:1 Not tainted 6.7.0-rc7-syzkaller-00041-gf016f7547aee #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\nWorkqueue: nbd5-recv recv_work\n\nCVE-2024-26645:\nIn the Linux kernel, the following vulnerability has been resolved:\ntracing: Ensure visibility when inserting an element into tracing_map\nRunning the following two commands in parallel on a multi-processor\nAArch64 machine can sporadically produce an unexpected warning about\nduplicate histogram entries:\n$ while true; do\necho hist:key=id.syscall:val=hitcount \u003e \\\n/sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/trigger\ncat /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/hist\nsleep 0.001\ndone\n$ stress-ng --sysbadaddr $(nproc)\nThe warning looks as follows:\n[ 2911.172474] ------------[ cut here ]------------\n[ 2911.173111] Duplicates detected: 1\n[ 2911.173574] WARNING: CPU: 2 PID: 12247 at kernel/trace/tracing_map.c:983 tracing_map_sort_entries+0x3e0/0x408\n[ 2911.174702] Modules linked in: iscsi_ibft(E) iscsi_boot_sysfs(E) rfkill(E) af_packet(E) nls_iso8859_1(E) nls_cp437(E) vfat(E) fat(E) ena(E) tiny_power_button(E) qemu_fw_cfg(E) button(E) fuse(E) efi_pstore(E) ip_tables(E) x_tables(E) xfs(E) libcrc32c(E) aes_ce_blk(E) aes_ce_cipher(E) crct10dif_ce(E) polyval_ce(E) polyval_generic(E) ghash_ce(E) gf128mul(E) sm4_ce_gcm(E) sm4_ce_ccm(E) sm4_ce(E) sm4_ce_cipher(E) sm4(E) sm3_ce(E) sm3(E) sha3_ce(E) sha512_ce(E) sha512_arm64(E) sha2_ce(E) sha256_arm64(E) nvme(E) sha1_ce(E) nvme_core(E) nvme_auth(E) t10_pi(E) sg(E) scsi_mod(E) scsi_common(E) efivarfs(E)\n[ 2911.174738] Unloaded tainted modules: cppc_cpufreq(E):1\n[ 2911.180985] CPU: 2 PID: 12247 Comm: cat Kdump: loaded Tainted: G            E      6.7.0-default #2 1b58bbb22c97e4399dc09f92d309344f69c44a01\n[ 2911.182398] Hardware name: Amazon EC2 c7g.8xlarge/, BIOS 1.0 11/1/2018\n[ 2911.183208] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n[ 2911.184038] pc : tracing_map_sort_entries+0x3e0/0x408\n[ 2911.184667] lr : tracing_map_sort_entries+0x3e0/0x408\n[ 2911.185310] sp : ffff8000a1513900\n[ 2911.185750] x29: ffff8000a1513900 x28: ffff0003f272fe80 x27: 0000000000000001\n[ 2911.186600] x26: ffff0003f272fe80 x25: 0000000000000030 x24: 0000000000000008\n[ 2911.187458] x23: ffff0003c5788000 x22: ffff0003c16710c8 x21: ffff80008017f180\n[ 2911.188310] x20: ffff80008017f000 x19: ffff80008017f180 x18: ffffffffffffffff\n[ 2911.189160] x17: 0000000000000000 x16: 0000000000000000 x15: ffff8000a15134b8\n[ 2911.190015] x14: 0000000000000000 x13: 205d373432323154 x12: 5b5d313131333731\n[ 2911.190844] x11: 00000000fffeffff x10: 00000000fffeffff x9 : ffffd1b78274a13c\n[ 2911.191716] x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 000000000057ffa8\n[ 2911.192554] x5 : ffff0012f6c24ec0 x4 : 0000000000000000 x3 : ffff2e5b72b5d000\n[ 2911.193404] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0003ff254480\n[ 2911.194259] Call trace:\n[ 2911.194626]  tracing_map_sort_entries+0x3e0/0x408\n[ 2911.195220]  hist_show+0x124/0x800\n[ 2911.195692]  seq_read_iter+0x1d4/0x4e8\n[ 2911.196193]  seq_read+0xe8/0x138\n[ 2911.196638]  vfs_read+0xc8/0x300\n[ 2911.197078]  ksys_read+0x70/0x108\n[ 2911.197534]  __arm64_sys_read+0x24/0x38\n[ 2911.198046]  invoke_syscall+0x78/0x108\n[ 2911.198553]  el0_svc_common.constprop.0+0xd0/0xf8\n[ 2911.199157]  do_el0_svc+0x28/0x40\n[ 2911.199613]  el0_svc+0x40/0x178\n[ 2911.200048]  el0t_64_sync_handler+0x13c/0x158\n[ 2911.200621]  el0t_64_sync+0x1a8/0x1b0\n[ 2911.201115] ---[ end trace 0000000000000000 ]---\nThe problem appears to be caused by CPU reordering of writes issued from\n__tracing_map_insert().\nThe check for the presence of an element with a given key in this\nfunction is:\nval = READ_ONCE(entry-\u003eval);\nif (val \u0026\u0026 keys_match(key, val-\u003ekey, map-\u003ekey_size)) ...\nThe write of a new entry is:\nelt = get_free_elt(map);\nmemcpy(elt-\u003ekey, key, map-\u003ekey_size);\nentry-\u003eval = elt;\nThe \"memcpy(elt-\u003ekey, key, map-\u003ekey_size);\" and \"entry-\u003eval = elt;\"\nstores may become visible in the reversed order on another CPU. This\nsecond CPU might then incorrectly determine that a new key doesn't match\nan already present val-\u003ekey and subse\n---truncated---\n\nCVE-2024-26649:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Fix the null pointer when load rlc firmware\nIf the RLC firmware is invalid because of wrong header size,\nthe pointer to the rlc firmware is released in function\namdgpu_ucode_request. There will be a null pointer error\nin subsequent use. So skip validation to fix it.\n\nCVE-2024-26665:\nIn the Linux kernel, the following vulnerability has been resolved:\ntunnels: fix out of bounds access when building IPv6 PMTU error\nIf the ICMPv6 error is built from a non-linear skb we get the following\nsplat,\nBUG: KASAN: slab-out-of-bounds in do_csum+0x220/0x240\nRead of size 4 at addr ffff88811d402c80 by task netperf/820\nCPU: 0 PID: 820 Comm: netperf Not tainted 6.8.0-rc1+ #543\n...\nkasan_report+0xd8/0x110\ndo_csum+0x220/0x240\ncsum_partial+0xc/0x20\nskb_tunnel_check_pmtu+0xeb9/0x3280\nvxlan_xmit_one+0x14c2/0x4080\nvxlan_xmit+0xf61/0x5c00\ndev_hard_start_xmit+0xfb/0x510\n__dev_queue_xmit+0x7cd/0x32a0\nbr_dev_queue_push_xmit+0x39d/0x6a0\nUse skb_checksum instead of csum_partial who cannot deal with non-linear\nSKBs.\n\nCVE-2024-26717:\nIn the Linux kernel, the following vulnerability has been resolved:\nHID: i2c-hid-of: fix NULL-deref on failed power up\nA while back the I2C HID implementation was split in an ACPI and OF\npart, but the new OF driver never initialises the client pointer which\nis dereferenced on power-up failures.\n\nCVE-2024-26720:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm/writeback: fix possible divide-by-zero in wb_dirty_limits(), again\n(struct dirty_throttle_control *)-\u003ethresh is an unsigned long, but is\npassed as the u32 divisor argument to div_u64().  On architectures where\nunsigned long is 64 bytes, the argument will be implicitly truncated.\nUse div64_u64() instead of div_u64() so that the value used in the \"is\nthis a safe division\" check is the same as the divisor.\nAlso, remove redundant cast of the numerator to u64, as that should happen\nimplicitly.\nThis would be difficult to exploit in memcg domain, given the ratio-based\narithmetic domain_drity_limits() uses, but is much easier in global\nwriteback domain with a BDI_CAP_STRICTLIMIT-backing device, using e.g. \nvm.dirty_bytes=(1\u003c\u003c32)*PAGE_SIZE so that dtc-\u003ethresh == (1\u003c\u003c32)\n\nCVE-2024-26769:\nIn the Linux kernel, the following vulnerability has been resolved:\nnvmet-fc: avoid deadlock on delete association path\nWhen deleting an association the shutdown path is deadlocking because we\ntry to flush the nvmet_wq nested. Avoid this by deadlock by deferring\nthe put work into its own work item.\n\nCVE-2024-26846:\nIn the Linux kernel, the following vulnerability has been resolved:\nnvme-fc: do not wait in vain when unloading module\nThe module exit path has race between deleting all controllers and\nfreeing 'left over IDs'. To prevent double free a synchronization\nbetween nvme_delete_ctrl and ida_destroy has been added by the initial\ncommit.\nThere is some logic around trying to prevent from hanging forever in\nwait_for_completion, though it does not handling all cases. E.g.\nblktests is able to reproduce the situation where the module unload\nhangs forever.\nIf we completely rely on the cleanup code executed from the\nnvme_delete_ctrl path, all IDs will be freed eventually. This makes\ncalling ida_destroy unnecessary. We only have to ensure that all\nnvme_delete_ctrl code has been executed before we leave\nnvme_fc_exit_module. This is done by flushing the nvme_delete_wq\nworkqueue.\nWhile at it, remove the unused nvme_fc_wq workqueue too.\n\nCVE-2024-26855:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: ice: Fix potential NULL pointer dereference in ice_bridge_setlink()\nThe function ice_bridge_setlink() may encounter a NULL pointer dereference\nif nlmsg_find_attr() returns NULL and br_spec is dereferenced subsequently\nin nla_for_each_nested(). To address this issue, add a check to ensure that\nbr_spec is not NULL before proceeding with the nested attribute iteration.\n\nCVE-2024-26880:\nIn the Linux kernel, the following vulnerability has been resolved:\ndm: call the resume method on internal suspend\nThere is this reported crash when experimenting with the lvm2 testsuite.\nThe list corruption is caused by the fact that the postsuspend and resume\nmethods were not paired correctly; there were two consecutive calls to the\norigin_postsuspend function. The second call attempts to remove the\n\"hash_list\" entry from a list, while it was already removed by the first\ncall.\nFix __dm_internal_resume so that it calls the preresume and resume\nmethods of the table's targets.\nIf a preresume method of some target fails, we are in a tricky situation.\nWe can't return an error because dm_internal_resume isn't supposed to\nreturn errors. We can't return success, because then the \"resume\" and\n\"postsuspend\" methods would not be paired correctly. So, we set the\nDMF_SUSPENDED flag and we fake normal suspend - it may confuse userspace\ntools, but it won't cause a kernel crash.\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:56!\ninvalid opcode: 0000 [#1] PREEMPT SMP\nCPU: 1 PID: 8343 Comm: dmsetup Not tainted 6.8.0-rc6 #4\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014\nRIP: 0010:__list_del_entry_valid_or_report+0x77/0xc0\n\u003csnip\u003e\nRSP: 0018:ffff8881b831bcc0 EFLAGS: 00010282\nRAX: 000000000000004e RBX: ffff888143b6eb80 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: ffffffff819053d0 RDI: 00000000ffffffff\nRBP: ffff8881b83a3400 R08: 00000000fffeffff R09: 0000000000000058\nR10: 0000000000000000 R11: ffffffff81a24080 R12: 0000000000000001\nR13: ffff88814538e000 R14: ffff888143bc6dc0 R15: ffffffffa02e4bb0\nFS:  00000000f7c0f780(0000) GS:ffff8893f0a40000(0000) knlGS:0000000000000000\nCS:  0010 DS: 002b ES: 002b CR0: 0000000080050033\nCR2: 0000000057fb5000 CR3: 0000000143474000 CR4: 00000000000006b0\nCall Trace:\n\u003cTASK\u003e\n? die+0x2d/0x80\n? do_trap+0xeb/0xf0\n? __list_del_entry_valid_or_report+0x77/0xc0\n? do_error_trap+0x60/0x80\n? __list_del_entry_valid_or_report+0x77/0xc0\n? exc_invalid_op+0x49/0x60\n? __list_del_entry_valid_or_report+0x77/0xc0\n? asm_exc_invalid_op+0x16/0x20\n? table_deps+0x1b0/0x1b0 [dm_mod]\n? __list_del_entry_valid_or_report+0x77/0xc0\norigin_postsuspend+0x1a/0x50 [dm_snapshot]\ndm_table_postsuspend_targets+0x34/0x50 [dm_mod]\ndm_suspend+0xd8/0xf0 [dm_mod]\ndev_suspend+0x1f2/0x2f0 [dm_mod]\n? table_deps+0x1b0/0x1b0 [dm_mod]\nctl_ioctl+0x300/0x5f0 [dm_mod]\ndm_compat_ctl_ioctl+0x7/0x10 [dm_mod]\n__x64_compat_sys_ioctl+0x104/0x170\ndo_syscall_64+0x184/0x1b0\nentry_SYSCALL_64_after_hwframe+0x46/0x4e\nRIP: 0033:0xf7e6aead\n\u003csnip\u003e\n---[ end trace 0000000000000000 ]---\n\nCVE-2024-26894:\nIn the Linux kernel, the following vulnerability has been resolved:\nACPI: processor_idle: Fix memory leak in acpi_processor_power_exit()\nAfter unregistering the CPU idle device, the memory associated with\nit is not freed, leading to a memory leak:\nunreferenced object 0xffff896282f6c000 (size 1024):\ncomm \"swapper/0\", pid 1, jiffies 4294893170\nhex dump (first 32 bytes):\n00 00 00 00 0b 00 00 00 00 00 00 00 00 00 00 00  ................\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nbacktrace (crc 8836a742):\n[\u003cffffffff993495ed\u003e] kmalloc_trace+0x29d/0x340\n[\u003cffffffff9972f3b3\u003e] acpi_processor_power_init+0xf3/0x1c0\n[\u003cffffffff9972d263\u003e] __acpi_processor_start+0xd3/0xf0\n[\u003cffffffff9972d2bc\u003e] acpi_processor_start+0x2c/0x50\n[\u003cffffffff99805872\u003e] really_probe+0xe2/0x480\n[\u003cffffffff99805c98\u003e] __driver_probe_device+0x78/0x160\n[\u003cffffffff99805daf\u003e] driver_probe_device+0x1f/0x90\n[\u003cffffffff9980601e\u003e] __driver_attach+0xce/0x1c0\n[\u003cffffffff99803170\u003e] bus_for_each_dev+0x70/0xc0\n[\u003cffffffff99804822\u003e] bus_add_driver+0x112/0x210\n[\u003cffffffff99807245\u003e] driver_register+0x55/0x100\n[\u003cffffffff9aee4acb\u003e] acpi_processor_driver_init+0x3b/0xc0\n[\u003cffffffff990012d1\u003e] do_one_initcall+0x41/0x300\n[\u003cffffffff9ae7c4b0\u003e] kernel_init_freeable+0x320/0x470\n[\u003cffffffff99b231f6\u003e] kernel_init+0x16/0x1b0\n[\u003cffffffff99042e6d\u003e] ret_from_fork+0x2d/0x50\nFix this by freeing the CPU idle device after unregistering it.\n\nCVE-2024-26923:\nIn the Linux kernel, the following vulnerability has been resolved:\naf_unix: Fix garbage collector racing against connect()\nGarbage collector does not take into account the risk of embryo getting\nenqueued during the garbage collection. If such embryo has a peer that\ncarries SCM_RIGHTS, two consecutive passes of scan_children() may see a\ndifferent set of children. Leading to an incorrectly elevated inflight\ncount, and then a dangling pointer within the gc_inflight_list.\nsockets are AF_UNIX/SOCK_STREAM\nS is an unconnected socket\nL is a listening in-flight socket bound to addr, not in fdtable\nV's fd will be passed via sendmsg(), gets inflight count bumped\nconnect(S, addr)sendmsg(S, [V]); close(V)__unix_gc()\n----------------------------------------------------\nNS = unix_create1()\nskb1 = sock_wmalloc(NS)\nL = unix_find_other(addr)\nunix_state_lock(L)\nunix_peer(S) = NS\n// V count=1 inflight=0\nNS = unix_peer(S)\nskb2 = sock_alloc()\nskb_queue_tail(NS, skb2[V])\n// V became in-flight\n// V count=2 inflight=1\nclose(V)\n// V count=1 inflight=1\n// GC candidate condition met\nfor u in gc_inflight_list:\nif (total_refs == inflight_refs)\nadd u to gc_candidates\n// gc_candidates={L, V}\nfor u in gc_candidates:\nscan_children(u, dec_inflight)\n// embryo (skb1) was not\n// reachable from L yet, so V's\n// inflight remains unchanged\n__skb_queue_tail(L, skb1)\nunix_state_unlock(L)\nfor u in gc_candidates:\nif (u.inflight)\nscan_children(u, inc_inflight_move_tail)\n// V count=1 inflight=2 (!)\nIf there is a GC-candidate listening socket, lock/unlock its state. This\nmakes GC wait until the end of any ongoing connect() to that socket. After\nflipping the lock, a possibly SCM-laden embryo is already enqueued. And if\nthere is another embryo coming, it can not possibly carry SCM_RIGHTS. At\nthis point, unix_inflight() can not happen because unix_gc_lock is already\ntaken. Inflight graph remains unaffected.\n\nCVE-2024-26939:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/i915/vma: Fix UAF on destroy against retire race\nObject debugging tools were sporadically reporting illegal attempts to\nfree a still active i915 VMA object when parking a GT believed to be idle.\n[161.359441] ODEBUG: free active (active state 0) object: ffff88811643b958 object type: i915_active hint: __i915_vma_active+0x0/0x50 [i915]\n[161.360082] WARNING: CPU: 5 PID: 276 at lib/debugobjects.c:514 debug_print_object+0x80/0xb0\n...\n[161.360304] CPU: 5 PID: 276 Comm: kworker/5:2 Not tainted 6.5.0-rc1-CI_DRM_13375-g003f860e5577+ #1\n[161.360314] Hardware name: Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022\n[161.360322] Workqueue: i915-unordered __intel_wakeref_put_work [i915]\n[161.360592] RIP: 0010:debug_print_object+0x80/0xb0\n...\n[161.361347] debug_object_free+0xeb/0x110\n[161.361362] i915_active_fini+0x14/0x130 [i915]\n[161.361866] release_references+0xfe/0x1f0 [i915]\n[161.362543] i915_vma_parked+0x1db/0x380 [i915]\n[161.363129] __gt_park+0x121/0x230 [i915]\n[161.363515] ____intel_wakeref_put_last+0x1f/0x70 [i915]\nThat has been tracked down to be happening when another thread is\ndeactivating the VMA inside __active_retire() helper, after the VMA's\nactive counter has been already decremented to 0, but before deactivation\nof the VMA's object is reported to the object debugging tool.\nWe could prevent from that race by serializing i915_active_fini() with\n__active_retire() via ref-\u003etree_lock, but that wouldn't stop the VMA from\nbeing used, e.g. from __i915_vma_retire() called at the end of\n__active_retire(), after that VMA has been already freed by a concurrent\ni915_vma_destroy() on return from the i915_active_fini().  Then, we should\nrather fix the issue at the VMA level, not in i915_active.\nSince __i915_vma_parked() is called from __gt_park() on last put of the\nGT's wakeref, the issue could be addressed by holding the GT wakeref long\nenough for __active_retire() to complete before that wakeref is released\nand the GT parked.\nI believe the issue was introduced by commit d93939730347 (\"drm/i915:\nRemove the vma refcount\") which moved a call to i915_active_fini() from\na dropped i915_vma_release(), called on last put of the removed VMA kref,\nto i915_vma_parked() processing path called on last put of a GT wakeref.\nHowever, its visibility to the object debugging tool was suppressed by a\nbug in i915_active that was fixed two weeks later with commit e92eb246feb9\n(\"drm/i915/active: Fix missing debug object activation\").\nA VMA associated with a request doesn't acquire a GT wakeref by itself.\nInstead, it depends on a wakeref held directly by the request's active\nintel_context for a GT associated with its VM, and indirectly on that\nintel_context's engine wakeref if the engine belongs to the same GT as the\nVMA's VM.  Those wakerefs are released asynchronously to VMA deactivation.\nFix the issue by getting a wakeref for the VMA's GT when activating it,\nand putting that wakeref only after the VMA is deactivated.  However,\nexclude global GTT from that processing path, otherwise the GPU never goes\nidle.  Since __i915_vma_retire() may be called from atomic contexts, use\nasync variant of wakeref put.  Also, to avoid circular locking dependency,\ntake care of acquiring the wakeref before VM mutex when both are needed.\nv7: Add inline comments with justifications for:\n- using untracked variants of intel_gt_pm_get/put() (Nirmoy),\n- using async variant of _put(),\n- not getting the wakeref in case of a global GTT,\n- always getting the first wakeref outside vm-\u003emutex.\nv6: Since __i915_vma_active/retire() callbacks are not serialized, storing\na wakeref tracking handle inside struct i915_vma is not safe, and\nthere is no other good place for that.  Use untracked variants of\nintel_gt_pm_get/put_async().\nv5: Replace \"tile\" with \"GT\" across commit description (Rodrigo),\n- \n---truncated---\n\nCVE-2024-27013:\nIn the Linux kernel, the following vulnerability has been resolved:\ntun: limit printing rate when illegal packet received by tun dev\nvhost_worker will call tun call backs to receive packets. If too many\nillegal packets arrives, tun_do_read will keep dumping packet contents.\nWhen console is enabled, it will costs much more cpu time to dump\npacket and soft lockup will be detected.\nnet_ratelimit mechanism can be used to limit the dumping rate.\nPID: 33036    TASK: ffff949da6f20000  CPU: 23   COMMAND: \"vhost-32980\"\n#0 [fffffe00003fce50] crash_nmi_callback at ffffffff89249253\n#1 [fffffe00003fce58] nmi_handle at ffffffff89225fa3\n#2 [fffffe00003fceb0] default_do_nmi at ffffffff8922642e\n#3 [fffffe00003fced0] do_nmi at ffffffff8922660d\n#4 [fffffe00003fcef0] end_repeat_nmi at ffffffff89c01663\n[exception RIP: io_serial_in+20]\nRIP: ffffffff89792594  RSP: ffffa655314979e8  RFLAGS: 00000002\nRAX: ffffffff89792500  RBX: ffffffff8af428a0  RCX: 0000000000000000\nRDX: 00000000000003fd  RSI: 0000000000000005  RDI: ffffffff8af428a0\nRBP: 0000000000002710   R8: 0000000000000004   R9: 000000000000000f\nR10: 0000000000000000  R11: ffffffff8acbf64f  R12: 0000000000000020\nR13: ffffffff8acbf698  R14: 0000000000000058  R15: 0000000000000000\nORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n#5 [ffffa655314979e8] io_serial_in at ffffffff89792594\n#6 [ffffa655314979e8] wait_for_xmitr at ffffffff89793470\n#7 [ffffa65531497a08] serial8250_console_putchar at ffffffff897934f6\n#8 [ffffa65531497a20] uart_console_write at ffffffff8978b605\n#9 [ffffa65531497a48] serial8250_console_write at ffffffff89796558\n#10 [ffffa65531497ac8] console_unlock at ffffffff89316124\n#11 [ffffa65531497b10] vprintk_emit at ffffffff89317c07\n#12 [ffffa65531497b68] printk at ffffffff89318306\n#13 [ffffa65531497bc8] print_hex_dump at ffffffff89650765\n#14 [ffffa65531497ca8] tun_do_read at ffffffffc0b06c27 [tun]\n#15 [ffffa65531497d38] tun_recvmsg at ffffffffc0b06e34 [tun]\n#16 [ffffa65531497d68] handle_rx at ffffffffc0c5d682 [vhost_net]\n#17 [ffffa65531497ed0] vhost_worker at ffffffffc0c644dc [vhost]\n#18 [ffffa65531497f10] kthread at ffffffff892d2e72\n#19 [ffffa65531497f50] ret_from_fork at ffffffff89c0022f\n\nCVE-2024-27042:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Fix potential out-of-bounds access in 'amdgpu_discovery_reg_base_init()'\nThe issue arises when the array 'adev-\u003evcn.vcn_config' is accessed\nbefore checking if the index 'adev-\u003evcn.num_vcn_inst' is within the\nbounds of the array.\nThe fix involves moving the bounds check before the array access. This\nensures that 'adev-\u003evcn.num_vcn_inst' is within the bounds of the array\nbefore it is used as an index.\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c:1289 amdgpu_discovery_reg_base_init() error: testing array offset 'adev-\u003evcn.num_vcn_inst' after use.\n\nCVE-2024-35809:\nIn the Linux kernel, the following vulnerability has been resolved:\nPCI/PM: Drain runtime-idle callbacks before driver removal\nA race condition between the .runtime_idle() callback and the .remove()\ncallback in the rtsx_pcr PCI driver leads to a kernel crash due to an\nunhandled page fault [1].\nThe problem is that rtsx_pci_runtime_idle() is not expected to be running\nafter pm_runtime_get_sync() has been called, but the latter doesn't really\nguarantee that.  It only guarantees that the suspend and resume callbacks\nwill not be running when it returns.\nHowever, if a .runtime_idle() callback is already running when\npm_runtime_get_sync() is called, the latter will notice that the runtime PM\nstatus of the device is RPM_ACTIVE and it will return right away without\nwaiting for the former to complete.  In fact, it cannot wait for\n.runtime_idle() to complete because it may be called from that callback (it\narguably does not make much sense to do that, but it is not strictly\nprohibited).\nThus in general, whoever is providing a .runtime_idle() callback needs\nto protect it from running in parallel with whatever code runs after\npm_runtime_get_sync().  [Note that .runtime_idle() will not start after\npm_runtime_get_sync() has returned, but it may continue running then if it\nhas started earlier.]\nOne way to address that race condition is to call pm_runtime_barrier()\nafter pm_runtime_get_sync() (not before it, because a nonzero value of the\nruntime PM usage counter is necessary to prevent runtime PM callbacks from\nbeing invoked) to wait for the .runtime_idle() callback to complete should\nit be running at that point.  A suitable place for doing that is in\npci_device_remove() which calls pm_runtime_get_sync() before removing the\ndriver, so it may as well call pm_runtime_barrier() subsequently, which\nwill prevent the race in question from occurring, not just in the rtsx_pcr\ndriver, but in any PCI drivers providing .runtime_idle() callbacks.\n\nCVE-2024-35877:\nIn the Linux kernel, the following vulnerability has been resolved:\nx86/mm/pat: fix VM_PAT handling in COW mappings\nPAT handling won't do the right thing in COW mappings: the first PTE (or,\nin fact, all PTEs) can be replaced during write faults to point at anon\nfolios.  Reliably recovering the correct PFN and cachemode using\nfollow_phys() from PTEs will not work in COW mappings.\nUsing follow_phys(), we might just get the address+protection of the anon\nfolio (which is very wrong), or fail on swap/nonswap entries, failing\nfollow_phys() and triggering a WARN_ON_ONCE() in untrack_pfn() and\ntrack_pfn_copy(), not properly calling free_pfn_range().\nIn free_pfn_range(), we either wouldn't call memtype_free() or would call\nit with the wrong range, possibly leaking memory.\nTo fix that, let's update follow_phys() to refuse returning anon folios,\nand fallback to using the stored PFN inside vma-\u003evm_pgoff for COW mappings\nif we run into that.\nWe will now properly handle untrack_pfn() with COW mappings, where we\ndon't need the cachemode.  We'll have to fail fork()-\u003etrack_pfn_copy() if\nthe first page was replaced by an anon folio, though: we'd have to store\nthe cachemode in the VMA to make this work, likely growing the VMA size.\nFor now, lets keep it simple and let track_pfn_copy() just fail in that\ncase: it would have failed in the past with swap/nonswap entries already,\nand it would have done the wrong thing with anon folios.\nSimple reproducer to trigger the WARN_ON_ONCE() in untrack_pfn():\n\u003c--- C reproducer ---\u003e\n#include \u003cstdio.h\u003e\n#include \u003csys/mman.h\u003e\n#include \u003cunistd.h\u003e\n#include \u003cliburing.h\u003e\nint main(void)\n{\nstruct io_uring_params p = {};\nint ring_fd;\nsize_t size;\nchar *map;\nring_fd = io_uring_setup(1, \u0026p);\nif (ring_fd \u003c 0) {\nperror(\"io_uring_setup\");\nreturn 1;\n}\nsize = p.sq_off.array + p.sq_entries * sizeof(unsigned);\n/* Map the submission queue ring MAP_PRIVATE */\nmap = mmap(0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE,\nring_fd, IORING_OFF_SQ_RING);\nif (map == MAP_FAILED) {\nperror(\"mmap\");\nreturn 1;\n}\n/* We have at least one page. Let's COW it. */\n*map = 0;\npause();\nreturn 0;\n}\n\u003c--- C reproducer ---\u003e\nOn a system with 16 GiB RAM and swap configured:\n# ./iouring \u0026\n# memhog 16G\n# killall iouring\n[  301.552930] ------------[ cut here ]------------\n[  301.553285] WARNING: CPU: 7 PID: 1402 at arch/x86/mm/pat/memtype.c:1060 untrack_pfn+0xf4/0x100\n[  301.553989] Modules linked in: binfmt_misc nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_g\n[  301.558232] CPU: 7 PID: 1402 Comm: iouring Not tainted 6.7.5-100.fc38.x86_64 #1\n[  301.558772] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebu4\n[  301.559569] RIP: 0010:untrack_pfn+0xf4/0x100\n[  301.559893] Code: 75 c4 eb cf 48 8b 43 10 8b a8 e8 00 00 00 3b 6b 28 74 b8 48 8b 7b 30 e8 ea 1a f7 000\n[  301.561189] RSP: 0018:ffffba2c0377fab8 EFLAGS: 00010282\n[  301.561590] RAX: 00000000ffffffea RBX: ffff9208c8ce9cc0 RCX: 000000010455e047\n[  301.562105] RDX: 07fffffff0eb1e0a RSI: 0000000000000000 RDI: ffff9208c391d200\n[  301.562628] RBP: 0000000000000000 R08: ffffba2c0377fab8 R09: 0000000000000000\n[  301.563145] R10: ffff9208d2292d50 R11: 0000000000000002 R12: 00007fea890e0000\n[  301.563669] R13: 0000000000000000 R14: ffffba2c0377fc08 R15: 0000000000000000\n[  301.564186] FS:  0000000000000000(0000) GS:ffff920c2fbc0000(0000) knlGS:0000000000000000\n[  301.564773] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  301.565197] CR2: 00007fea88ee8a20 CR3: 00000001033a8000 CR4: 0000000000750ef0\n[  301.565725] PKRU: 55555554\n[  301.565944] Call Trace:\n[  301.566148]  \u003cTASK\u003e\n[  301.566325]  ? untrack_pfn+0xf4/0x100\n[  301.566618]  ? __warn+0x81/0x130\n[  301.566876]  ? untrack_pfn+0xf4/0x100\n[  3\n---truncated---\n\nCVE-2024-35884:\nIn the Linux kernel, the following vulnerability has been resolved:\nudp: do not accept non-tunnel GSO skbs landing in a tunnel\nWhen rx-udp-gro-forwarding is enabled UDP packets might be GROed when\nbeing forwarded. If such packets might land in a tunnel this can cause\nvarious issues and udp_gro_receive makes sure this isn't the case by\nlooking for a matching socket. This is performed in\nudp4/6_gro_lookup_skb but only in the current netns. This is an issue\nwith tunneled packets when the endpoint is in another netns. In such\ncases the packets will be GROed at the UDP level, which leads to various\nissues later on. The same thing can happen with rx-gro-list.\nWe saw this with geneve packets being GROed at the UDP level. In such\ncase gso_size is set; later the packet goes through the geneve rx path,\nthe geneve header is pulled, the offset are adjusted and frag_list skbs\nare not adjusted with regard to geneve. When those skbs hit\nskb_fragment, it will misbehave. Different outcomes are possible\ndepending on what the GROed skbs look like; from corrupted packets to\nkernel crashes.\nOne example is a BUG_ON[1] triggered in skb_segment while processing the\nfrag_list. Because gso_size is wrong (geneve header was pulled)\nskb_segment thinks there is \"geneve header size\" of data in frag_list,\nalthough it's in fact the next packet. The BUG_ON itself has nothing to\ndo with the issue. This is only one of the potential issues.\nLooking up for a matching socket in udp_gro_receive is fragile: the\nlookup could be extended to all netns (not speaking about performances)\nbut nothing prevents those packets from being modified in between and we\ncould still not find a matching socket. It's OK to keep the current\nlogic there as it should cover most cases but we also need to make sure\nwe handle tunnel packets being GROed too early.\nThis is done by extending the checks in udp_unexpected_gso: GSO packets\nlacking the SKB_GSO_UDP_TUNNEL/_CSUM bits and landing in a tunnel must\nbe segmented.\n[1] kernel BUG at net/core/skbuff.c:4408!\nRIP: 0010:skb_segment+0xd2a/0xf70\n__udp_gso_segment+0xaa/0x560\n\nCVE-2024-35944:\nIn the Linux kernel, the following vulnerability has been resolved:\nVMCI: Fix memcpy() run-time warning in dg_dispatch_as_host()\nSyzkaller hit 'WARNING in dg_dispatch_as_host' bug.\nmemcpy: detected field-spanning write (size 56) of single field \"\u0026dg_info-\u003emsg\"\nat drivers/misc/vmw_vmci/vmci_datagram.c:237 (size 24)\nWARNING: CPU: 0 PID: 1555 at drivers/misc/vmw_vmci/vmci_datagram.c:237\ndg_dispatch_as_host+0x88e/0xa60 drivers/misc/vmw_vmci/vmci_datagram.c:237\nSome code commentry, based on my understanding:\n544 #define VMCI_DG_SIZE(_dg) (VMCI_DG_HEADERSIZE + (size_t)(_dg)-\u003epayload_size)\n/// This is 24 + payload_size\nmemcpy(\u0026dg_info-\u003emsg, dg, dg_size);\nDestination = dg_info-\u003emsg ---\u003e this is a 24 byte\nstructure(struct vmci_datagram)\nSource = dg --\u003e this is a 24 byte structure (struct vmci_datagram)\nSize = dg_size = 24 + payload_size\n{payload_size = 56-24 =32} -- Syzkaller managed to set payload_size to 32.\n35 struct delayed_datagram_info {\n36         struct datagram_entry *entry;\n37         struct work_struct work;\n38         bool in_dg_host_queue;\n39         /* msg and msg_payload must be together. */\n40         struct vmci_datagram msg;\n41         u8 msg_payload[];\n42 };\nSo those extra bytes of payload are copied into msg_payload[], a run time\nwarning is seen while fuzzing with Syzkaller.\nOne possible way to fix the warning is to split the memcpy() into\ntwo parts -- one -- direct assignment of msg and second taking care of payload.\nGustavo quoted:\n\"Under FORTIFY_SOURCE we should not copy data across multiple members\nin a structure.\"\n\nCVE-2024-35989:\nIn the Linux kernel, the following vulnerability has been resolved:\ndmaengine: idxd: Fix oops during rmmod on single-CPU platforms\nDuring the removal of the idxd driver, registered offline callback is\ninvoked as part of the clean up process. However, on systems with only\none CPU online, no valid target is available to migrate the\nperf context, resulting in a kernel oops:\nBUG: unable to handle page fault for address: 000000000002a2b8\n#PF: supervisor write access in kernel mode\n#PF: error_code(0x0002) - not-present page\nPGD 1470e1067 P4D 0\nOops: 0002 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 20 Comm: cpuhp/0 Not tainted 6.8.0-rc6-dsa+ #57\nHardware name: Intel Corporation AvenueCity/AvenueCity, BIOS BHSDCRB1.86B.2492.D03.2307181620 07/18/2023\nRIP: 0010:mutex_lock+0x2e/0x50\n...\nCall Trace:\n\u003cTASK\u003e\n__die+0x24/0x70\npage_fault_oops+0x82/0x160\ndo_user_addr_fault+0x65/0x6b0\n__pfx___rdmsr_safe_on_cpu+0x10/0x10\nexc_page_fault+0x7d/0x170\nasm_exc_page_fault+0x26/0x30\nmutex_lock+0x2e/0x50\nmutex_lock+0x1e/0x50\nperf_pmu_migrate_context+0x87/0x1f0\nperf_event_cpu_offline+0x76/0x90 [idxd]\ncpuhp_invoke_callback+0xa2/0x4f0\n__pfx_perf_event_cpu_offline+0x10/0x10 [idxd]\ncpuhp_thread_fun+0x98/0x150\nsmpboot_thread_fn+0x27/0x260\nsmpboot_thread_fn+0x1af/0x260\n__pfx_smpboot_thread_fn+0x10/0x10\nkthread+0x103/0x140\n__pfx_kthread+0x10/0x10\nret_from_fork+0x31/0x50\n__pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1b/0x30\n\u003cTASK\u003e\nFix the issue by preventing the migration of the perf context to an\ninvalid target.\n\nCVE-2024-36883:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: fix out-of-bounds access in ops_init\nnet_alloc_generic is called by net_alloc, which is called without any\nlocking. It reads max_gen_ptrs, which is changed under pernet_ops_rwsem. It\nis read twice, first to allocate an array, then to set s.len, which is\nlater used to limit the bounds of the array access.\nIt is possible that the array is allocated and another thread is\nregistering a new pernet ops, increments max_gen_ptrs, which is then used\nto set s.len with a larger than allocated length for the variable array.\nFix it by reading max_gen_ptrs only once in net_alloc_generic. If\nmax_gen_ptrs is later incremented, it will be caught in net_assign_generic.\n\nCVE-2024-36901:\nIn the Linux kernel, the following vulnerability has been resolved:\nipv6: prevent NULL dereference in ip6_output()\nAccording to syzbot, there is a chance that ip6_dst_idev()\nreturns NULL in ip6_output(). Most places in IPv6 stack\ndeal with a NULL idev just fine, but not here.\nsyzbot reported:\ngeneral protection fault, probably for non-canonical address 0xdffffc00000000bc: 0000 [#1] PREEMPT SMP KASAN PTI\nKASAN: null-ptr-deref in range [0x00000000000005e0-0x00000000000005e7]\nCPU: 0 PID: 9775 Comm: syz-executor.4 Not tainted 6.9.0-rc5-syzkaller-00157-g6a30653b604a #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nRIP: 0010:ip6_output+0x231/0x3f0 net/ipv6/ip6_output.c:237\nCode: 3c 1e 00 49 89 df 74 08 4c 89 ef e8 19 58 db f7 48 8b 44 24 20 49 89 45 00 49 89 c5 48 8d 9d e0 05 00 00 48 89 d8 48 c1 e8 03 \u003c42\u003e 0f b6 04 38 84 c0 4c 8b 74 24 28 0f 85 61 01 00 00 8b 1b 31 ff\nRSP: 0018:ffffc9000927f0d8 EFLAGS: 00010202\nRAX: 00000000000000bc RBX: 00000000000005e0 RCX: 0000000000040000\nRDX: ffffc900131f9000 RSI: 0000000000004f47 RDI: 0000000000004f48\nRBP: 0000000000000000 R08: ffffffff8a1f0b9a R09: 1ffffffff1f51fad\nR10: dffffc0000000000 R11: fffffbfff1f51fae R12: ffff8880293ec8c0\nR13: ffff88805d7fc000 R14: 1ffff1100527d91a R15: dffffc0000000000\nFS:  00007f135c6856c0(0000) GS:ffff8880b9400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000080 CR3: 0000000064096000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cTASK\u003e\nNF_HOOK include/linux/netfilter.h:314 [inline]\nip6_xmit+0xefe/0x17f0 net/ipv6/ip6_output.c:358\nsctp_v6_xmit+0x9f2/0x13f0 net/sctp/ipv6.c:248\nsctp_packet_transmit+0x26ad/0x2ca0 net/sctp/output.c:653\nsctp_packet_singleton+0x22c/0x320 net/sctp/outqueue.c:783\nsctp_outq_flush_ctrl net/sctp/outqueue.c:914 [inline]\nsctp_outq_flush+0x6d5/0x3e20 net/sctp/outqueue.c:1212\nsctp_side_effects net/sctp/sm_sideeffect.c:1198 [inline]\nsctp_do_sm+0x59cc/0x60c0 net/sctp/sm_sideeffect.c:1169\nsctp_primitive_ASSOCIATE+0x95/0xc0 net/sctp/primitive.c:73\n__sctp_connect+0x9cd/0xe30 net/sctp/socket.c:1234\nsctp_connect net/sctp/socket.c:4819 [inline]\nsctp_inet_connect+0x149/0x1f0 net/sctp/socket.c:4834\n__sys_connect_file net/socket.c:2048 [inline]\n__sys_connect+0x2df/0x310 net/socket.c:2065\n__do_sys_connect net/socket.c:2075 [inline]\n__se_sys_connect net/socket.c:2072 [inline]\n__x64_sys_connect+0x7a/0x90 net/socket.c:2072\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCVE-2024-36902:\nIn the Linux kernel, the following vulnerability has been resolved:\nipv6: fib6_rules: avoid possible NULL dereference in fib6_rule_action()\nsyzbot is able to trigger the following crash [1],\ncaused by unsafe ip6_dst_idev() use.\nIndeed ip6_dst_idev() can return NULL, and must always be checked.\n[1]\nOops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 0 PID: 31648 Comm: syz-executor.0 Not tainted 6.9.0-rc4-next-20240417-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nRIP: 0010:__fib6_rule_action net/ipv6/fib6_rules.c:237 [inline]\nRIP: 0010:fib6_rule_action+0x241/0x7b0 net/ipv6/fib6_rules.c:267\nCode: 02 00 00 49 8d 9f d8 00 00 00 48 89 d8 48 c1 e8 03 42 80 3c 20 00 74 08 48 89 df e8 f9 32 bf f7 48 8b 1b 48 89 d8 48 c1 e8 03 \u003c42\u003e 80 3c 20 00 74 08 48 89 df e8 e0 32 bf f7 4c 8b 03 48 89 ef 4c\nRSP: 0018:ffffc9000fc1f2f0 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 1a772f98c8186700\nRDX: 0000000000000003 RSI: ffffffff8bcac4e0 RDI: ffffffff8c1f9760\nRBP: ffff8880673fb980 R08: ffffffff8fac15ef R09: 1ffffffff1f582bd\nR10: dffffc0000000000 R11: fffffbfff1f582be R12: dffffc0000000000\nR13: 0000000000000080 R14: ffff888076509000 R15: ffff88807a029a00\nFS:  00007f55e82ca6c0(0000) GS:ffff8880b9400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000001b31d23000 CR3: 0000000022b66000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cTASK\u003e\nfib_rules_lookup+0x62c/0xdb0 net/core/fib_rules.c:317\nfib6_rule_lookup+0x1fd/0x790 net/ipv6/fib6_rules.c:108\nip6_route_output_flags_noref net/ipv6/route.c:2637 [inline]\nip6_route_output_flags+0x38e/0x610 net/ipv6/route.c:2649\nip6_route_output include/net/ip6_route.h:93 [inline]\nip6_dst_lookup_tail+0x189/0x11a0 net/ipv6/ip6_output.c:1120\nip6_dst_lookup_flow+0xb9/0x180 net/ipv6/ip6_output.c:1250\nsctp_v6_get_dst+0x792/0x1e20 net/sctp/ipv6.c:326\nsctp_transport_route+0x12c/0x2e0 net/sctp/transport.c:455\nsctp_assoc_add_peer+0x614/0x15c0 net/sctp/associola.c:662\nsctp_connect_new_asoc+0x31d/0x6c0 net/sctp/socket.c:1099\n__sctp_connect+0x66d/0xe30 net/sctp/socket.c:1197\nsctp_connect net/sctp/socket.c:4819 [inline]\nsctp_inet_connect+0x149/0x1f0 net/sctp/socket.c:4834\n__sys_connect_file net/socket.c:2048 [inline]\n__sys_connect+0x2df/0x310 net/socket.c:2065\n__do_sys_connect net/socket.c:2075 [inline]\n__se_sys_connect net/socket.c:2072 [inline]\n__x64_sys_connect+0x7a/0x90 net/socket.c:2072\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCVE-2024-36919:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: bnx2fc: Remove spin_lock_bh while releasing resources after upload\nThe session resources are used by FW and driver when session is offloaded,\nonce session is uploaded these resources are not used. The lock is not\nrequired as these fields won't be used any longer. The offload and upload\ncalls are sequential, hence lock is not required.\nThis will suppress following BUG_ON():\n[  449.843143] ------------[ cut here ]------------\n[  449.848302] kernel BUG at mm/vmalloc.c:2727!\n[  449.853072] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n[  449.858712] CPU: 5 PID: 1996 Comm: kworker/u24:2 Not tainted 5.14.0-118.el9.x86_64 #1\nRebooting.\n[  449.867454] Hardware name: Dell Inc. PowerEdge R730/0WCJNT, BIOS 2.3.4 11/08/2016\n[  449.876966] Workqueue: fc_rport_eq fc_rport_work [libfc]\n[  449.882910] RIP: 0010:vunmap+0x2e/0x30\n[  449.887098] Code: 00 65 8b 05 14 a2 f0 4a a9 00 ff ff 00 75 1b 55 48 89 fd e8 34 36 79 00 48 85 ed 74 0b 48 89 ef 31 f6 5d e9 14 fc ff ff 5d c3 \u003c0f\u003e 0b 0f 1f 44 00 00 41 57 41 56 49 89 ce 41 55 49 89 fd 41 54 41\n[  449.908054] RSP: 0018:ffffb83d878b3d68 EFLAGS: 00010206\n[  449.913887] RAX: 0000000080000201 RBX: ffff8f4355133550 RCX: 000000000d400005\n[  449.921843] RDX: 0000000000000001 RSI: 0000000000001000 RDI: ffffb83da53f5000\n[  449.929808] RBP: ffff8f4ac6675800 R08: ffffb83d878b3d30 R09: 00000000000efbdf\n[  449.937774] R10: 0000000000000003 R11: ffff8f434573e000 R12: 0000000000001000\n[  449.945736] R13: 0000000000001000 R14: ffffb83da53f5000 R15: ffff8f43d4ea3ae0\n[  449.953701] FS:  0000000000000000(0000) GS:ffff8f529fc80000(0000) knlGS:0000000000000000\n[  449.962732] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  449.969138] CR2: 00007f8cf993e150 CR3: 0000000efbe10003 CR4: 00000000003706e0\n[  449.977102] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  449.985065] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  449.993028] Call Trace:\n[  449.995756]  __iommu_dma_free+0x96/0x100\n[  450.000139]  bnx2fc_free_session_resc+0x67/0x240 [bnx2fc]\n[  450.006171]  bnx2fc_upload_session+0xce/0x100 [bnx2fc]\n[  450.011910]  bnx2fc_rport_event_handler+0x9f/0x240 [bnx2fc]\n[  450.018136]  fc_rport_work+0x103/0x5b0 [libfc]\n[  450.023103]  process_one_work+0x1e8/0x3c0\n[  450.027581]  worker_thread+0x50/0x3b0\n[  450.031669]  ? rescuer_thread+0x370/0x370\n[  450.036143]  kthread+0x149/0x170\n[  450.039744]  ? set_kthread_struct+0x40/0x40\n[  450.044411]  ret_from_fork+0x22/0x30\n[  450.048404] Modules linked in: vfat msdos fat xfs nfs_layout_nfsv41_files rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver dm_service_time qedf qed crc8 bnx2fc libfcoe libfc scsi_transport_fc intel_rapl_msr intel_rapl_common x86_pkg_temp_thermal intel_powerclamp dcdbas rapl intel_cstate intel_uncore mei_me pcspkr mei ipmi_ssif lpc_ich ipmi_si fuse zram ext4 mbcache jbd2 loop nfsv3 nfs_acl nfs lockd grace fscache netfs irdma ice sd_mod t10_pi sg ib_uverbs ib_core 8021q garp mrp stp llc mgag200 i2c_algo_bit drm_kms_helper syscopyarea sysfillrect sysimgblt mxm_wmi fb_sys_fops cec crct10dif_pclmul ahci crc32_pclmul bnx2x drm ghash_clmulni_intel libahci rfkill i40e libata megaraid_sas mdio wmi sunrpc lrw dm_crypt dm_round_robin dm_multipath dm_snapshot dm_bufio dm_mirror dm_region_hash dm_log dm_zero dm_mod linear raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid6_pq libcrc32c crc32c_intel raid1 raid0 iscsi_ibft squashfs be2iscsi bnx2i cnic uio cxgb4i cxgb4 tls\n[  450.048497]  libcxgbi libcxgb qla4xxx iscsi_boot_sysfs iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi edd ipmi_devintf ipmi_msghandler\n[  450.159753] ---[ end trace 712de2c57c64abc8 ]---\n\nCVE-2024-36920:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: mpi3mr: Avoid memcpy field-spanning write WARNING\nWhen the \"storcli2 show\" command is executed for eHBA-9600, mpi3mr driver\nprints this WARNING message:\nmemcpy: detected field-spanning write (size 128) of single field \"bsg_reply_buf-\u003ereply_buf\" at drivers/scsi/mpi3mr/mpi3mr_app.c:1658 (size 1)\nWARNING: CPU: 0 PID: 12760 at drivers/scsi/mpi3mr/mpi3mr_app.c:1658 mpi3mr_bsg_request+0x6b12/0x7f10 [mpi3mr]\nThe cause of the WARN is 128 bytes memcpy to the 1 byte size array \"__u8\nreplay_buf[1]\" in the struct mpi3mr_bsg_in_reply_buf. The array is intended\nto be a flexible length array, so the WARN is a false positive.\nTo suppress the WARN, remove the constant number '1' from the array\ndeclaration and clarify that it has flexible length. Also, adjust the\nmemory allocation size to match the change.\n\nCVE-2024-36922:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: iwlwifi: read txq-\u003eread_ptr under lock\nIf we read txq-\u003eread_ptr without lock, we can read the same\nvalue twice, then obtain the lock, and reclaim from there\nto two different places, but crucially reclaim the same\nentry twice, resulting in the WARN_ONCE() a little later.\nFix that by reading txq-\u003eread_ptr under lock.\n\nCVE-2024-36939:\nIn the Linux kernel, the following vulnerability has been resolved:\nnfs: Handle error of rpc_proc_register() in nfs_net_init().\nsyzkaller reported a warning [0] triggered while destroying immature\nnetns.\nrpc_proc_register() was called in init_nfs_fs(), but its error\nhas been ignored since at least the initial commit 1da177e4c3f4\n(\"Linux-2.6.12-rc2\").\nRecently, commit d47151b79e32 (\"nfs: expose /proc/net/sunrpc/nfs\nin net namespaces\") converted the procfs to per-netns and made\nthe problem more visible.\nEven when rpc_proc_register() fails, nfs_net_init() could succeed,\nand thus nfs_net_exit() will be called while destroying the netns.\nThen, remove_proc_entry() will be called for non-existing proc\ndirectory and trigger the warning below.\nLet's handle the error of rpc_proc_register() properly in nfs_net_init().\n[0]:\nname 'nfs'\nWARNING: CPU: 1 PID: 1710 at fs/proc/generic.c:711 remove_proc_entry+0x1bb/0x2d0 fs/proc/generic.c:711\nModules linked in:\nCPU: 1 PID: 1710 Comm: syz-executor.2 Not tainted 6.8.0-12822-gcd51db110a7e #12\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nRIP: 0010:remove_proc_entry+0x1bb/0x2d0 fs/proc/generic.c:711\nCode: 41 5d 41 5e c3 e8 85 09 b5 ff 48 c7 c7 88 58 64 86 e8 09 0e 71 02 e8 74 09 b5 ff 4c 89 e6 48 c7 c7 de 1b 80 84 e8 c5 ad 97 ff \u003c0f\u003e 0b eb b1 e8 5c 09 b5 ff 48 c7 c7 88 58 64 86 e8 e0 0d 71 02 eb\nRSP: 0018:ffffc9000c6d7ce0 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: ffff8880422b8b00 RCX: ffffffff8110503c\nRDX: ffff888030652f00 RSI: ffffffff81105045 RDI: 0000000000000001\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000001 R11: ffffffff81bb62cb R12: ffffffff84807ffc\nR13: ffff88804ad6fcc0 R14: ffffffff84807ffc R15: ffffffff85741ff8\nFS:  00007f30cfba8640(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ff51afe8000 CR3: 000000005a60a005 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\nrpc_proc_unregister+0x64/0x70 net/sunrpc/stats.c:310\nnfs_net_exit+0x1c/0x30 fs/nfs/inode.c:2438\nops_exit_list+0x62/0xb0 net/core/net_namespace.c:170\nsetup_net+0x46c/0x660 net/core/net_namespace.c:372\ncopy_net_ns+0x244/0x590 net/core/net_namespace.c:505\ncreate_new_namespaces+0x2ed/0x770 kernel/nsproxy.c:110\nunshare_nsproxy_namespaces+0xae/0x160 kernel/nsproxy.c:228\nksys_unshare+0x342/0x760 kernel/fork.c:3322\n__do_sys_unshare kernel/fork.c:3393 [inline]\n__se_sys_unshare kernel/fork.c:3391 [inline]\n__x64_sys_unshare+0x1f/0x30 kernel/fork.c:3391\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0x4f/0x110 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x46/0x4e\nRIP: 0033:0x7f30d0febe5d\nCode: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 9f 1b 00 f7 d8 64 89 01 48\nRSP: 002b:00007f30cfba7cc8 EFLAGS: 00000246 ORIG_RAX: 0000000000000110\nRAX: ffffffffffffffda RBX: 00000000004bbf80 RCX: 00007f30d0febe5d\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 000000006c020600\nRBP: 00000000004bbf80 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000002\nR13: 000000000000000b R14: 00007f30d104c530 R15: 0000000000000000\n\u003c/TASK\u003e\n\nCVE-2024-36953:\nIn the Linux kernel, the following vulnerability has been resolved:\nKVM: arm64: vgic-v2: Check for non-NULL vCPU in vgic_v2_parse_attr()\nvgic_v2_parse_attr() is responsible for finding the vCPU that matches\nthe user-provided CPUID, which (of course) may not be valid. If the ID\nis invalid, kvm_get_vcpu_by_id() returns NULL, which isn't handled\ngracefully.\nSimilar to the GICv3 uaccess flow, check that kvm_get_vcpu_by_id()\nactually returns something and fail the ioctl if not.\n\nCVE-2024-37356:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: Fix shift-out-of-bounds in dctcp_update_alpha().\nIn dctcp_update_alpha(), we use a module parameter dctcp_shift_g\nas follows:\nalpha -= min_not_zero(alpha, alpha \u003e\u003e dctcp_shift_g);\n...\ndelivered_ce \u003c\u003c= (10 - dctcp_shift_g);\nIt seems syzkaller started fuzzing module parameters and triggered\nshift-out-of-bounds [0] by setting 100 to dctcp_shift_g:\nmemcpy((void*)0x20000080,\n\"/sys/module/tcp_dctcp/parameters/dctcp_shift_g\\000\", 47);\nres = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul, /*file=*/0x20000080ul,\n/*flags=*/2ul, /*mode=*/0ul);\nmemcpy((void*)0x20000000, \"100\\000\", 4);\nsyscall(__NR_write, /*fd=*/r[0], /*val=*/0x20000000ul, /*len=*/4ul);\nLet's limit the max value of dctcp_shift_g by param_set_uint_minmax().\nWith this patch:\n# echo 10 \u003e /sys/module/tcp_dctcp/parameters/dctcp_shift_g\n# cat /sys/module/tcp_dctcp/parameters/dctcp_shift_g\n10\n# echo 11 \u003e /sys/module/tcp_dctcp/parameters/dctcp_shift_g\n-bash: echo: write error: Invalid argument\n[0]:\nUBSAN: shift-out-of-bounds in net/ipv4/tcp_dctcp.c:143:12\nshift exponent 100 is too large for 32-bit type 'u32' (aka 'unsigned int')\nCPU: 0 PID: 8083 Comm: syz-executor345 Not tainted 6.9.0-05151-g1b294a1f3561 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.13.0-1ubuntu1.1 04/01/2014\nCall Trace:\n\u003cTASK\u003e\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0x201/0x300 lib/dump_stack.c:114\nubsan_epilogue lib/ubsan.c:231 [inline]\n__ubsan_handle_shift_out_of_bounds+0x346/0x3a0 lib/ubsan.c:468\ndctcp_update_alpha+0x540/0x570 net/ipv4/tcp_dctcp.c:143\ntcp_in_ack_event net/ipv4/tcp_input.c:3802 [inline]\ntcp_ack+0x17b1/0x3bc0 net/ipv4/tcp_input.c:3948\ntcp_rcv_state_process+0x57a/0x2290 net/ipv4/tcp_input.c:6711\ntcp_v4_do_rcv+0x764/0xc40 net/ipv4/tcp_ipv4.c:1937\nsk_backlog_rcv include/net/sock.h:1106 [inline]\n__release_sock+0x20f/0x350 net/core/sock.c:2983\nrelease_sock+0x61/0x1f0 net/core/sock.c:3549\nmptcp_subflow_shutdown+0x3d0/0x620 net/mptcp/protocol.c:2907\nmptcp_check_send_data_fin+0x225/0x410 net/mptcp/protocol.c:2976\n__mptcp_close+0x238/0xad0 net/mptcp/protocol.c:3072\nmptcp_close+0x2a/0x1a0 net/mptcp/protocol.c:3127\ninet_release+0x190/0x1f0 net/ipv4/af_inet.c:437\n__sock_release net/socket.c:659 [inline]\nsock_close+0xc0/0x240 net/socket.c:1421\n__fput+0x41b/0x890 fs/file_table.c:422\ntask_work_run+0x23b/0x300 kernel/task_work.c:180\nexit_task_work include/linux/task_work.h:38 [inline]\ndo_exit+0x9c8/0x2540 kernel/exit.c:878\ndo_group_exit+0x201/0x2b0 kernel/exit.c:1027\n__do_sys_exit_group kernel/exit.c:1038 [inline]\n__se_sys_exit_group kernel/exit.c:1036 [inline]\n__x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1036\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xe4/0x240 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x67/0x6f\nRIP: 0033:0x7f6c2b5005b6\nCode: Unable to access opcode bytes at 0x7f6c2b50058c.\nRSP: 002b:00007ffe883eb948 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7\nRAX: ffffffffffffffda RBX: 00007f6c2b5862f0 RCX: 00007f6c2b5005b6\nRDX: 0000000000000001 RSI: 000000000000003c RDI: 0000000000000001\nRBP: 0000000000000001 R08: 00000000000000e7 R09: ffffffffffffffc0\nR10: 0000000000000006 R11: 0000000000000246 R12: 00007f6c2b5862f0\nR13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000001\n\u003c/TASK\u003e\n\nCVE-2024-38558:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: openvswitch: fix overwriting ct original tuple for ICMPv6\nOVS_PACKET_CMD_EXECUTE has 3 main attributes:\n- OVS_PACKET_ATTR_KEY - Packet metadata in a netlink format.\n- OVS_PACKET_ATTR_PACKET - Binary packet content.\n- OVS_PACKET_ATTR_ACTIONS - Actions to execute on the packet.\nOVS_PACKET_ATTR_KEY is parsed first to populate sw_flow_key structure\nwith the metadata like conntrack state, input port, recirculation id,\netc.  Then the packet itself gets parsed to populate the rest of the\nkeys from the packet headers.\nWhenever the packet parsing code starts parsing the ICMPv6 header, it\nfirst zeroes out fields in the key corresponding to Neighbor Discovery\ninformation even if it is not an ND packet.\nIt is an 'ipv6.nd' field.  However, the 'ipv6' is a union that shares\nthe space between 'nd' and 'ct_orig' that holds the original tuple\nconntrack metadata parsed from the OVS_PACKET_ATTR_KEY.\nND packets should not normally have conntrack state, so it's fine to\nshare the space, but normal ICMPv6 Echo packets or maybe other types of\nICMPv6 can have the state attached and it should not be overwritten.\nThe issue results in all but the last 4 bytes of the destination\naddress being wiped from the original conntrack tuple leading to\nincorrect packet matching and potentially executing wrong actions\nin case this packet recirculates within the datapath or goes back\nto userspace.\nND fields should not be accessed in non-ND packets, so not clearing\nthem should be fine.  Executing memset() only for actual ND packets to\navoid the issue.\nInitializing the whole thing before parsing is needed because ND packet\nmay not contain all the options.\nThe issue only affects the OVS_PACKET_CMD_EXECUTE path and doesn't\naffect packets entering OVS datapath from network interfaces, because\nin this case CT metadata is populated from skb after the packet is\nalready parsed.\n\nCVE-2024-38559:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: qedf: Ensure the copied buf is NUL terminated\nCurrently, we allocate a count-sized kernel buffer and copy count from\nuserspace to that buffer. Later, we use kstrtouint on this buffer but we\ndon't ensure that the string is terminated inside the buffer, this can\nlead to OOB read when using kstrtouint. Fix this issue by using\nmemdup_user_nul instead of memdup_user.\n\nCVE-2024-38570:\nIn the Linux kernel, the following vulnerability has been resolved:\ngfs2: Fix potential glock use-after-free on unmount\nWhen a DLM lockspace is released and there ares still locks in that\nlockspace, DLM will unlock those locks automatically.  Commit\nfb6791d100d1b started exploiting this behavior to speed up filesystem\nunmount: gfs2 would simply free glocks it didn't want to unlock and then\nrelease the lockspace.  This didn't take the bast callbacks for\nasynchronous lock contention notifications into account, which remain\nactive until until a lock is unlocked or its lockspace is released.\nTo prevent those callbacks from accessing deallocated objects, put the\nglocks that should not be unlocked on the sd_dead_glocks list, release\nthe lockspace, and only then free those glocks.\nAs an additional measure, ignore unexpected ast and bast callbacks if\nthe receiving glock is dead.\n\nCVE-2024-38579:\nIn the Linux kernel, the following vulnerability has been resolved:\ncrypto: bcm - Fix pointer arithmetic\nIn spu2_dump_omd() value of ptr is increased by ciph_key_len\ninstead of hash_iv_len which could lead to going beyond the\nbuffer boundaries.\nFix this bug by changing ciph_key_len to hash_iv_len.\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\n\nCVE-2024-38581:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu/mes: fix use-after-free issue\nDelete fence fallback timer to fix the ramdom\nuse-after-free issue.\nv2: move to amdgpu_mes.c\n\nCVE-2024-38619:\nIn the Linux kernel, the following vulnerability has been resolved:\nusb-storage: alauda: Check whether the media is initialized\nThe member \"uzonesize\" of struct alauda_info will remain 0\nif alauda_init_media() fails, potentially causing divide errors\nin alauda_read_data() and alauda_write_lba().\n- Add a member \"media_initialized\" to struct alauda_info.\n- Change a condition in alauda_check_media() to ensure the\nfirst initialization.\n- Add an error check for the return value of alauda_init_media().\n\nCVE-2024-39471:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: add error handle to avoid out-of-bounds\nif the sdma_v4_0_irq_id_to_seq return -EINVAL, the process should\nbe stop to avoid out-of-bounds read, so directly return -EINVAL.\n\nCVE-2024-39499:\nIn the Linux kernel, the following vulnerability has been resolved:\nvmci: prevent speculation leaks by sanitizing event in event_deliver()\nCoverity spotted that event_msg is controlled by user-space,\nevent_msg-\u003eevent_data.event is passed to event_deliver() and used\nas an index without sanitization.\nThis change ensures that the event index is sanitized to mitigate any\npossibility of speculative information leaks.\nThis bug was discovered and resolved using Coverity Static Analysis\nSecurity Testing (SAST) by Synopsys, Inc.\nOnly compile tested, no access to HW.\n\nCVE-2024-39501:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrivers: core: synchronize really_probe() and dev_uevent()\nSynchronize the dev-\u003edriver usage in really_probe() and dev_uevent().\nThese can run in different threads, what can result in the following\nrace condition for dev-\u003edriver uninitialization:\nThread #1:\n==========\nreally_probe() {\n...\nprobe_failed:\n...\ndevice_unbind_cleanup(dev) {\n...\ndev-\u003edriver = NULL;   // \u003c= Failed probe sets dev-\u003edriver to NULL\n...\n}\n...\n}\nThread #2:\n==========\ndev_uevent() {\n...\nif (dev-\u003edriver)\n// If dev-\u003edriver is NULLed from really_probe() from here on,\n// after above check, the system crashes\nadd_uevent_var(env, \"DRIVER=%s\", dev-\u003edriver-\u003ename);\n...\n}\nreally_probe() holds the lock, already. So nothing needs to be done\nthere. dev_uevent() is called with lock held, often, too. But not\nalways. What implies that we can't add any locking in dev_uevent()\nitself. So fix this race by adding the lock to the non-protected\npath. This is the path where above race is observed:\ndev_uevent+0x235/0x380\nuevent_show+0x10c/0x1f0  \u003c= Add lock here\ndev_attr_show+0x3a/0xa0\nsysfs_kf_seq_show+0x17c/0x250\nkernfs_seq_show+0x7c/0x90\nseq_read_iter+0x2d7/0x940\nkernfs_fop_read_iter+0xc6/0x310\nvfs_read+0x5bc/0x6b0\nksys_read+0xeb/0x1b0\n__x64_sys_read+0x42/0x50\nx64_sys_call+0x27ad/0x2d30\ndo_syscall_64+0xcd/0x1d0\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\nSimilar cases are reported by syzkaller in\nhttps://syzkaller.appspot.com/bug?extid=ffa8143439596313a85a\nBut these are regarding the *initialization* of dev-\u003edriver\ndev-\u003edriver = drv;\nAs this switches dev-\u003edriver to non-NULL these reports can be considered\nto be false-positives (which should be \"fixed\" by this commit, as well,\nthough).\nThe same issue was reported and tried to be fixed back in 2015 in\nhttps://lore.kernel.org/lkml/1421259054-2574-1-git-send-email-a.sangwan@samsung.com/\nalready.\n\nCVE-2024-39506:\nIn the Linux kernel, the following vulnerability has been resolved:\nliquidio: Adjust a NULL pointer handling path in lio_vf_rep_copy_packet\nIn lio_vf_rep_copy_packet() pg_info-\u003epage is compared to a NULL value,\nbut then it is unconditionally passed to skb_add_rx_frag() which looks\nstrange and could lead to null pointer dereference.\nlio_vf_rep_copy_packet() call trace looks like:\nocteon_droq_process_packets\nocteon_droq_fast_process_packets\nocteon_droq_dispatch_pkt\nocteon_create_recv_info\n...search in the dispatch_list...\n-\u003edisp_fn(rdisp-\u003erinfo, ...)\nlio_vf_rep_pkt_recv(struct octeon_recv_info *recv_info, ...)\nIn this path there is no code which sets pg_info-\u003epage to NULL.\nSo this check looks unneeded and doesn't solve potential problem.\nBut I guess the author had reason to add a check and I have no such card\nand can't do real test.\nIn addition, the code in the function liquidio_push_packet() in\nliquidio/lio_core.c does exactly the same.\nBased on this, I consider the most acceptable compromise solution to\nadjust this issue by moving skb_add_rx_frag() into conditional scope.\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\n\nCVE-2024-40901:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: mpt3sas: Avoid test/set_bit() operating in non-allocated memory\nThere is a potential out-of-bounds access when using test_bit() on a single\nword. The test_bit() and set_bit() functions operate on long values, and\nwhen testing or setting a single word, they can exceed the word\nboundary. KASAN detects this issue and produces a dump:\nBUG: KASAN: slab-out-of-bounds in _scsih_add_device.constprop.0 (./arch/x86/include/asm/bitops.h:60 ./include/asm-generic/bitops/instrumented-atomic.h:29 drivers/scsi/mpt3sas/mpt3sas_scsih.c:7331) mpt3sas\nWrite of size 8 at addr ffff8881d26e3c60 by task kworker/u1536:2/2965\nFor full log, please look at [1].\nMake the allocation at least the size of sizeof(unsigned long) so that\nset_bit() and test_bit() have sufficient room for read/write operations\nwithout overwriting unallocated memory.\n[1] Link: https://lore.kernel.org/all/ZkNcALr3W3KGYYJG@gmail.com/\n\nCVE-2024-40904:\nIn the Linux kernel, the following vulnerability has been resolved:\nUSB: class: cdc-wdm: Fix CPU lockup caused by excessive log messages\nThe syzbot fuzzer found that the interrupt-URB completion callback in\nthe cdc-wdm driver was taking too long, and the driver's immediate\nresubmission of interrupt URBs with -EPROTO status combined with the\ndummy-hcd emulation to cause a CPU lockup:\ncdc_wdm 1-1:1.0: nonzero urb status received: -71\ncdc_wdm 1-1:1.0: wdm_int_callback - 0 bytes\nwatchdog: BUG: soft lockup - CPU#0 stuck for 26s! [syz-executor782:6625]\nCPU#0 Utilization every 4s during lockup:\n#1:  98% system,  0% softirq,  3% hardirq,  0% idle\n#2:  98% system,  0% softirq,  3% hardirq,  0% idle\n#3:  98% system,  0% softirq,  3% hardirq,  0% idle\n#4:  98% system,  0% softirq,  3% hardirq,  0% idle\n#5:  98% system,  1% softirq,  3% hardirq,  0% idle\nModules linked in:\nirq event stamp: 73096\nhardirqs last  enabled at (73095): [\u003cffff80008037bc00\u003e] console_emit_next_record kernel/printk/printk.c:2935 [inline]\nhardirqs last  enabled at (73095): [\u003cffff80008037bc00\u003e] console_flush_all+0x650/0xb74 kernel/printk/printk.c:2994\nhardirqs last disabled at (73096): [\u003cffff80008af10b00\u003e] __el1_irq arch/arm64/kernel/entry-common.c:533 [inline]\nhardirqs last disabled at (73096): [\u003cffff80008af10b00\u003e] el1_interrupt+0x24/0x68 arch/arm64/kernel/entry-common.c:551\nsoftirqs last  enabled at (73048): [\u003cffff8000801ea530\u003e] softirq_handle_end kernel/softirq.c:400 [inline]\nsoftirqs last  enabled at (73048): [\u003cffff8000801ea530\u003e] handle_softirqs+0xa60/0xc34 kernel/softirq.c:582\nsoftirqs last disabled at (73043): [\u003cffff800080020de8\u003e] __do_softirq+0x14/0x20 kernel/softirq.c:588\nCPU: 0 PID: 6625 Comm: syz-executor782 Tainted: G        W          6.10.0-rc2-syzkaller-g8867bbd4a056 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024\nTesting showed that the problem did not occur if the two error\nmessages -- the first two lines above -- were removed; apparently adding\nmaterial to the kernel log takes a surprisingly large amount of time.\nIn any case, the best approach for preventing these lockups and to\navoid spamming the log with thousands of error messages per second is\nto ratelimit the two dev_err() calls.  Therefore we replace them with\ndev_err_ratelimited().\n\nCVE-2024-40911:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: cfg80211: Lock wiphy in cfg80211_get_station\nWiphy should be locked before calling rdev_get_station() (see lockdep\nassert in ieee80211_get_station()).\nThis fixes the following kernel NULL dereference:\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000050\nMem abort info:\nESR = 0x0000000096000006\nEC = 0x25: DABT (current EL), IL = 32 bits\nSET = 0, FnV = 0\nEA = 0, S1PTW = 0\nFSC = 0x06: level 2 translation fault\nData abort info:\nISV = 0, ISS = 0x00000006\nCM = 0, WnR = 0\nuser pgtable: 4k pages, 48-bit VAs, pgdp=0000000003001000\n[0000000000000050] pgd=0800000002dca003, p4d=0800000002dca003, pud=08000000028e9003, pmd=0000000000000000\nInternal error: Oops: 0000000096000006 [#1] SMP\nModules linked in: netconsole dwc3_meson_g12a dwc3_of_simple dwc3 ip_gre gre ath10k_pci ath10k_core ath9k ath9k_common ath9k_hw ath\nCPU: 0 PID: 1091 Comm: kworker/u8:0 Not tainted 6.4.0-02144-g565f9a3a7911-dirty #705\nHardware name: RPT (r1) (DT)\nWorkqueue: bat_events batadv_v_elp_throughput_metric_update\npstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : ath10k_sta_statistics+0x10/0x2dc [ath10k_core]\nlr : sta_set_sinfo+0xcc/0xbd4\nsp : ffff000007b43ad0\nx29: ffff000007b43ad0 x28: ffff0000071fa900 x27: ffff00000294ca98\nx26: ffff000006830880 x25: ffff000006830880 x24: ffff00000294c000\nx23: 0000000000000001 x22: ffff000007b43c90 x21: ffff800008898acc\nx20: ffff00000294c6e8 x19: ffff000007b43c90 x18: 0000000000000000\nx17: 445946354d552d78 x16: 62661f7200000000 x15: 57464f445946354d\nx14: 0000000000000000 x13: 00000000000000e3 x12: d5f0acbcebea978e\nx11: 00000000000000e3 x10: 000000010048fe41 x9 : 0000000000000000\nx8 : ffff000007b43d90 x7 : 000000007a1e2125 x6 : 0000000000000000\nx5 : ffff0000024e0900 x4 : ffff800000a0250c x3 : ffff000007b43c90\nx2 : ffff00000294ca98 x1 : ffff000006831920 x0 : 0000000000000000\nCall trace:\nath10k_sta_statistics+0x10/0x2dc [ath10k_core]\nsta_set_sinfo+0xcc/0xbd4\nieee80211_get_station+0x2c/0x44\ncfg80211_get_station+0x80/0x154\nbatadv_v_elp_get_throughput+0x138/0x1fc\nbatadv_v_elp_throughput_metric_update+0x1c/0xa4\nprocess_one_work+0x1ec/0x414\nworker_thread+0x70/0x46c\nkthread+0xdc/0xe0\nret_from_fork+0x10/0x20\nCode: a9bb7bfd 910003fd a90153f3 f9411c40 (f9402814)\nThis happens because STA has time to disconnect and reconnect before\nbatadv_v_elp_throughput_metric_update() delayed work gets scheduled. In\nthis situation, ath10k_sta_state() can be in the middle of resetting\narsta data when the work queue get chance to be scheduled and ends up\naccessing it. Locking wiphy prevents that.\n\nCVE-2024-40912:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: mac80211: Fix deadlock in ieee80211_sta_ps_deliver_wakeup()\nThe ieee80211_sta_ps_deliver_wakeup() function takes sta-\u003eps_lock to\nsynchronizes with ieee80211_tx_h_unicast_ps_buf() which is called from\nsoftirq context. However using only spin_lock() to get sta-\u003eps_lock in\nieee80211_sta_ps_deliver_wakeup() does not prevent softirq to execute\non this same CPU, to run ieee80211_tx_h_unicast_ps_buf() and try to\ntake this same lock ending in deadlock. Below is an example of rcu stall\nthat arises in such situation.\nrcu: INFO: rcu_sched self-detected stall on CPU\nrcu:    2-....: (42413413 ticks this GP) idle=b154/1/0x4000000000000000 softirq=1763/1765 fqs=21206996\nrcu:    (t=42586894 jiffies g=2057 q=362405 ncpus=4)\nCPU: 2 PID: 719 Comm: wpa_supplicant Tainted: G        W          6.4.0-02158-g1b062f552873 #742\nHardware name: RPT (r1) (DT)\npstate: 00000005 (nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : queued_spin_lock_slowpath+0x58/0x2d0\nlr : invoke_tx_handlers_early+0x5b4/0x5c0\nsp : ffff00001ef64660\nx29: ffff00001ef64660 x28: ffff000009bc1070 x27: ffff000009bc0ad8\nx26: ffff000009bc0900 x25: ffff00001ef647a8 x24: 0000000000000000\nx23: ffff000009bc0900 x22: ffff000009bc0900 x21: ffff00000ac0e000\nx20: ffff00000a279e00 x19: ffff00001ef646e8 x18: 0000000000000000\nx17: ffff800016468000 x16: ffff00001ef608c0 x15: 0010533c93f64f80\nx14: 0010395c9faa3946 x13: 0000000000000000 x12: 00000000fa83b2da\nx11: 000000012edeceea x10: ffff0000010fbe00 x9 : 0000000000895440\nx8 : 000000000010533c x7 : ffff00000ad8b740 x6 : ffff00000c350880\nx5 : 0000000000000007 x4 : 0000000000000001 x3 : 0000000000000000\nx2 : 0000000000000000 x1 : 0000000000000001 x0 : ffff00000ac0e0e8\nCall trace:\nqueued_spin_lock_slowpath+0x58/0x2d0\nieee80211_tx+0x80/0x12c\nieee80211_tx_pending+0x110/0x278\ntasklet_action_common.constprop.0+0x10c/0x144\ntasklet_action+0x20/0x28\n_stext+0x11c/0x284\n____do_softirq+0xc/0x14\ncall_on_irq_stack+0x24/0x34\ndo_softirq_own_stack+0x18/0x20\ndo_softirq+0x74/0x7c\n__local_bh_enable_ip+0xa0/0xa4\n_ieee80211_wake_txqs+0x3b0/0x4b8\n__ieee80211_wake_queue+0x12c/0x168\nieee80211_add_pending_skbs+0xec/0x138\nieee80211_sta_ps_deliver_wakeup+0x2a4/0x480\nieee80211_mps_sta_status_update.part.0+0xd8/0x11c\nieee80211_mps_sta_status_update+0x18/0x24\nsta_apply_parameters+0x3bc/0x4c0\nieee80211_change_station+0x1b8/0x2dc\nnl80211_set_station+0x444/0x49c\ngenl_family_rcv_msg_doit.isra.0+0xa4/0xfc\ngenl_rcv_msg+0x1b0/0x244\nnetlink_rcv_skb+0x38/0x10c\ngenl_rcv+0x34/0x48\nnetlink_unicast+0x254/0x2bc\nnetlink_sendmsg+0x190/0x3b4\n____sys_sendmsg+0x1e8/0x218\n___sys_sendmsg+0x68/0x8c\n__sys_sendmsg+0x44/0x84\n__arm64_sys_sendmsg+0x20/0x28\ndo_el0_svc+0x6c/0xe8\nel0_svc+0x14/0x48\nel0t_64_sync_handler+0xb0/0xb4\nel0t_64_sync+0x14c/0x150\nUsing spin_lock_bh()/spin_unlock_bh() instead prevents softirq to raise\non the same CPU that is holding the lock.\n\nCVE-2024-40929:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: iwlwifi: mvm: check n_ssids before accessing the ssids\nIn some versions of cfg80211, the ssids poinet might be a valid one even\nthough n_ssids is 0. Accessing the pointer in this case will cuase an\nout-of-bound access. Fix this by checking n_ssids first.\n\nCVE-2024-40931:\nIn the Linux kernel, the following vulnerability has been resolved:\nmptcp: ensure snd_una is properly initialized on connect\nThis is strictly related to commit fb7a0d334894 (\"mptcp: ensure snd_nxt\nis properly initialized on connect\"). It turns out that syzkaller can\ntrigger the retransmit after fallback and before processing any other\nincoming packet - so that snd_una is still left uninitialized.\nAddress the issue explicitly initializing snd_una together with snd_nxt\nand write_seq.\n\nCVE-2024-40941:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: iwlwifi: mvm: don't read past the mfuart notifcation\nIn case the firmware sends a notification that claims it has more data\nthan it has, we will read past that was allocated for the notification.\nRemove the print of the buffer, we won't see it by default. If needed,\nwe can see the content with tracing.\nThis was reported by KFENCE.\n\nCVE-2024-40954:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: do not leave a dangling sk pointer, when socket creation fails\nIt is possible to trigger a use-after-free by:\n* attaching an fentry probe to __sock_release() and the probe calling the\nbpf_get_socket_cookie() helper\n* running traceroute -I 1.1.1.1 on a freshly booted VM\nA KASAN enabled kernel will log something like below (decoded and stripped):\n==================================================================\nBUG: KASAN: slab-use-after-free in __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29)\nRead of size 8 at addr ffff888007110dd8 by task traceroute/299\nCPU: 2 PID: 299 Comm: traceroute Tainted: G            E      6.10.0-rc2+ #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nCall Trace:\n\u003cTASK\u003e\ndump_stack_lvl (lib/dump_stack.c:117 (discriminator 1))\nprint_report (mm/kasan/report.c:378 mm/kasan/report.c:488)\n? __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29)\nkasan_report (mm/kasan/report.c:603)\n? __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29)\nkasan_check_range (mm/kasan/generic.c:183 mm/kasan/generic.c:189)\n__sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29)\nbpf_get_socket_ptr_cookie (./arch/x86/include/asm/preempt.h:94 ./include/linux/sock_diag.h:42 net/core/filter.c:5094 net/core/filter.c:5092)\nbpf_prog_875642cf11f1d139___sock_release+0x6e/0x8e\nbpf_trampoline_6442506592+0x47/0xaf\n__sock_release (net/socket.c:652)\n__sock_create (net/socket.c:1601)\n...\nAllocated by task 299 on cpu 2 at 78.328492s:\nkasan_save_stack (mm/kasan/common.c:48)\nkasan_save_track (mm/kasan/common.c:68)\n__kasan_slab_alloc (mm/kasan/common.c:312 mm/kasan/common.c:338)\nkmem_cache_alloc_noprof (mm/slub.c:3941 mm/slub.c:4000 mm/slub.c:4007)\nsk_prot_alloc (net/core/sock.c:2075)\nsk_alloc (net/core/sock.c:2134)\ninet_create (net/ipv4/af_inet.c:327 net/ipv4/af_inet.c:252)\n__sock_create (net/socket.c:1572)\n__sys_socket (net/socket.c:1660 net/socket.c:1644 net/socket.c:1706)\n__x64_sys_socket (net/socket.c:1718)\ndo_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\nFreed by task 299 on cpu 2 at 78.328502s:\nkasan_save_stack (mm/kasan/common.c:48)\nkasan_save_track (mm/kasan/common.c:68)\nkasan_save_free_info (mm/kasan/generic.c:582)\npoison_slab_object (mm/kasan/common.c:242)\n__kasan_slab_free (mm/kasan/common.c:256)\nkmem_cache_free (mm/slub.c:4437 mm/slub.c:4511)\n__sk_destruct (net/core/sock.c:2117 net/core/sock.c:2208)\ninet_create (net/ipv4/af_inet.c:397 net/ipv4/af_inet.c:252)\n__sock_create (net/socket.c:1572)\n__sys_socket (net/socket.c:1660 net/socket.c:1644 net/socket.c:1706)\n__x64_sys_socket (net/socket.c:1718)\ndo_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\nFix this by clearing the struct socket reference in sk_common_release() to cover\nall protocol families create functions, which may already attached the\nreference to the sk object with sock_init_data().\n\nCVE-2024-40958:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetns: Make get_net_ns() handle zero refcount net\nSyzkaller hit a warning:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 3 PID: 7890 at lib/refcount.c:25 refcount_warn_saturate+0xdf/0x1d0\nModules linked in:\nCPU: 3 PID: 7890 Comm: tun Not tainted 6.10.0-rc3-00100-gcaa4f9578aba-dirty #310\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xdf/0x1d0\nCode: 41 49 04 31 ff 89 de e8 9f 1e cd fe 84 db 75 9c e8 76 26 cd fe c6 05 b6 41 49 04 01 90 48 c7 c7 b8 8e 25 86 e8 d2 05 b5 fe 90 \u003c0f\u003e 0b 90 90 e9 79 ff ff ff e8 53 26 cd fe 0f b6 1\nRSP: 0018:ffff8881067b7da0 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff811c72ac\nRDX: ffff8881026a2140 RSI: ffffffff811c72b5 RDI: 0000000000000001\nRBP: ffff8881067b7db0 R08: 0000000000000000 R09: 205b5d3730353139\nR10: 0000000000000000 R11: 205d303938375420 R12: ffff8881086500c4\nR13: ffff8881086500c4 R14: ffff8881086500b0 R15: ffff888108650040\nFS:  00007f5b2961a4c0(0000) GS:ffff88823bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055d7ed36fd18 CR3: 00000001482f6000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cTASK\u003e\n? show_regs+0xa3/0xc0\n? __warn+0xa5/0x1c0\n? refcount_warn_saturate+0xdf/0x1d0\n? report_bug+0x1fc/0x2d0\n? refcount_warn_saturate+0xdf/0x1d0\n? handle_bug+0xa1/0x110\n? exc_invalid_op+0x3c/0xb0\n? asm_exc_invalid_op+0x1f/0x30\n? __warn_printk+0xcc/0x140\n? __warn_printk+0xd5/0x140\n? refcount_warn_saturate+0xdf/0x1d0\nget_net_ns+0xa4/0xc0\n? __pfx_get_net_ns+0x10/0x10\nopen_related_ns+0x5a/0x130\n__tun_chr_ioctl+0x1616/0x2370\n? __sanitizer_cov_trace_switch+0x58/0xa0\n? __sanitizer_cov_trace_const_cmp2+0x1c/0x30\n? __pfx_tun_chr_ioctl+0x10/0x10\ntun_chr_ioctl+0x2f/0x40\n__x64_sys_ioctl+0x11b/0x160\nx64_sys_call+0x1211/0x20d0\ndo_syscall_64+0x9e/0x1d0\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f5b28f165d7\nCode: b3 66 90 48 8b 05 b1 48 2d 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 8b 0d 81 48 2d 00 8\nRSP: 002b:00007ffc2b59c5e8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f5b28f165d7\nRDX: 0000000000000000 RSI: 00000000000054e3 RDI: 0000000000000003\nRBP: 00007ffc2b59c650 R08: 00007f5b291ed8c0 R09: 00007f5b2961a4c0\nR10: 0000000029690010 R11: 0000000000000246 R12: 0000000000400730\nR13: 00007ffc2b59cf40 R14: 0000000000000000 R15: 0000000000000000\n\u003c/TASK\u003e\nKernel panic - not syncing: kernel: panic_on_warn set ...\nThis is trigger as below:\nns0                                    ns1\ntun_set_iff() //dev is tun0\ntun-\u003edev = dev\n//ip link set tun0 netns ns1\nput_net() //ref is 0\n__tun_chr_ioctl() //TUNGETDEVNETNS\nnet = dev_net(tun-\u003edev);\nopen_related_ns(\u0026net-\u003ens, get_net_ns); //ns1\nget_net_ns()\nget_net() //addition on 0\nUse maybe_get_net() in get_net_ns in case net's ref is zero to fix this\n\nCVE-2024-40959:\nIn the Linux kernel, the following vulnerability has been resolved:\nxfrm6: check ip6_dst_idev() return value in xfrm6_get_saddr()\nip6_dst_idev() can return NULL, xfrm6_get_saddr() must act accordingly.\nsyzbot reported:\nOops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 1 PID: 12 Comm: kworker/u8:1 Not tainted 6.10.0-rc2-syzkaller-00383-gb8481381d4e2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024\nWorkqueue: wg-kex-wg1 wg_packet_handshake_send_worker\nRIP: 0010:xfrm6_get_saddr+0x93/0x130 net/ipv6/xfrm6_policy.c:64\nCode: df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 97 00 00 00 4c 8b ab d8 00 00 00 48 b8 00 00 00 00 00 fc ff df 4c 89 ea 48 c1 ea 03 \u003c80\u003e 3c 02 00 0f 85 86 00 00 00 4d 8b 6d 00 e8 ca 13 47 01 48 b8 00\nRSP: 0018:ffffc90000117378 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88807b079dc0 RCX: ffffffff89a0d6d7\nRDX: 0000000000000000 RSI: ffffffff89a0d6e9 RDI: ffff88807b079e98\nRBP: ffff88807ad73248 R08: 0000000000000007 R09: fffffffffffff000\nR10: ffff88807b079dc0 R11: 0000000000000007 R12: ffffc90000117480\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff8880b9300000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f4586d00440 CR3: 0000000079042000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cTASK\u003e\nxfrm_get_saddr net/xfrm/xfrm_policy.c:2452 [inline]\nxfrm_tmpl_resolve_one net/xfrm/xfrm_policy.c:2481 [inline]\nxfrm_tmpl_resolve+0xa26/0xf10 net/xfrm/xfrm_policy.c:2541\nxfrm_resolve_and_create_bundle+0x140/0x2570 net/xfrm/xfrm_policy.c:2835\nxfrm_bundle_lookup net/xfrm/xfrm_policy.c:3070 [inline]\nxfrm_lookup_with_ifid+0x4d1/0x1e60 net/xfrm/xfrm_policy.c:3201\nxfrm_lookup net/xfrm/xfrm_policy.c:3298 [inline]\nxfrm_lookup_route+0x3b/0x200 net/xfrm/xfrm_policy.c:3309\nip6_dst_lookup_flow+0x15c/0x1d0 net/ipv6/ip6_output.c:1256\nsend6+0x611/0xd20 drivers/net/wireguard/socket.c:139\nwg_socket_send_skb_to_peer+0xf9/0x220 drivers/net/wireguard/socket.c:178\nwg_socket_send_buffer_to_peer+0x12b/0x190 drivers/net/wireguard/socket.c:200\nwg_packet_send_handshake_initiation+0x227/0x360 drivers/net/wireguard/send.c:40\nwg_packet_handshake_send_worker+0x1c/0x30 drivers/net/wireguard/send.c:51\nprocess_one_work+0x9fb/0x1b60 kernel/workqueue.c:3231\nprocess_scheduled_works kernel/workqueue.c:3312 [inline]\nworker_thread+0x6c8/0xf70 kernel/workqueue.c:3393\nkthread+0x2c1/0x3a0 kernel/kthread.c:389\nret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\nret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nCVE-2024-40960:\nIn the Linux kernel, the following vulnerability has been resolved:\nipv6: prevent possible NULL dereference in rt6_probe()\nsyzbot caught a NULL dereference in rt6_probe() [1]\nBail out if  __in6_dev_get() returns NULL.\n[1]\nOops: general protection fault, probably for non-canonical address 0xdffffc00000000cb: 0000 [#1] PREEMPT SMP KASAN PTI\nKASAN: null-ptr-deref in range [0x0000000000000658-0x000000000000065f]\nCPU: 1 PID: 22444 Comm: syz-executor.0 Not tainted 6.10.0-rc2-syzkaller-00383-gb8481381d4e2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024\nRIP: 0010:rt6_probe net/ipv6/route.c:656 [inline]\nRIP: 0010:find_match+0x8c4/0xf50 net/ipv6/route.c:758\nCode: 14 fd f7 48 8b 85 38 ff ff ff 48 c7 45 b0 00 00 00 00 48 8d b8 5c 06 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 \u003c0f\u003e b6 14 02 48 89 f8 83 e0 07 83 c0 03 38 d0 7c 08 84 d2 0f 85 19\nRSP: 0018:ffffc900034af070 EFLAGS: 00010203\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffc90004521000\nRDX: 00000000000000cb RSI: ffffffff8990d0cd RDI: 000000000000065c\nRBP: ffffc900034af150 R08: 0000000000000005 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000002 R12: 000000000000000a\nR13: 1ffff92000695e18 R14: ffff8880244a1d20 R15: 0000000000000000\nFS:  00007f4844a5a6c0(0000) GS:ffff8880b9300000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000001b31b27000 CR3: 000000002d42c000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cTASK\u003e\nrt6_nh_find_match+0xfa/0x1a0 net/ipv6/route.c:784\nnexthop_for_each_fib6_nh+0x26d/0x4a0 net/ipv4/nexthop.c:1496\n__find_rr_leaf+0x6e7/0xe00 net/ipv6/route.c:825\nfind_rr_leaf net/ipv6/route.c:853 [inline]\nrt6_select net/ipv6/route.c:897 [inline]\nfib6_table_lookup+0x57e/0xa30 net/ipv6/route.c:2195\nip6_pol_route+0x1cd/0x1150 net/ipv6/route.c:2231\npol_lookup_func include/net/ip6_fib.h:616 [inline]\nfib6_rule_lookup+0x386/0x720 net/ipv6/fib6_rules.c:121\nip6_route_output_flags_noref net/ipv6/route.c:2639 [inline]\nip6_route_output_flags+0x1d0/0x640 net/ipv6/route.c:2651\nip6_dst_lookup_tail.constprop.0+0x961/0x1760 net/ipv6/ip6_output.c:1147\nip6_dst_lookup_flow+0x99/0x1d0 net/ipv6/ip6_output.c:1250\nrawv6_sendmsg+0xdab/0x4340 net/ipv6/raw.c:898\ninet_sendmsg+0x119/0x140 net/ipv4/af_inet.c:853\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg net/socket.c:745 [inline]\nsock_write_iter+0x4b8/0x5c0 net/socket.c:1160\nnew_sync_write fs/read_write.c:497 [inline]\nvfs_write+0x6b6/0x1140 fs/read_write.c:590\nksys_write+0x1f8/0x260 fs/read_write.c:643\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCVE-2024-40972:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: do not create EA inode under buffer lock\next4_xattr_set_entry() creates new EA inodes while holding buffer lock\non the external xattr block. This is problematic as it nests all the\nallocation locking (which acquires locks on other buffers) under the\nbuffer lock. This can even deadlock when the filesystem is corrupted and\ne.g. quota file is setup to contain xattr block as data block. Move the\nallocation of EA inode out of ext4_xattr_set_entry() into the callers.\n\nCVE-2024-40977:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: mt76: mt7921s: fix potential hung tasks during chip recovery\nDuring chip recovery (e.g. chip reset), there is a possible situation that\nkernel worker reset_work is holding the lock and waiting for kernel thread\nstat_worker to be parked, while stat_worker is waiting for the release of\nthe same lock.\nIt causes a deadlock resulting in the dumping of hung tasks messages and\npossible rebooting of the device.\nThis patch prevents the execution of stat_worker during the chip recovery.\n\nCVE-2024-40978:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: qedi: Fix crash while reading debugfs attribute\nThe qedi_dbg_do_not_recover_cmd_read() function invokes sprintf() directly\non a __user pointer, which results into the crash.\nTo fix this issue, use a small local stack buffer for sprintf() and then\ncall simple_read_from_buffer(), which in turns make the copy_to_user()\ncall.\nBUG: unable to handle page fault for address: 00007f4801111000\nPGD 8000000864df6067 P4D 8000000864df6067 PUD 864df7067 PMD 846028067 PTE 0\nOops: 0002 [#1] PREEMPT SMP PTI\nHardware name: HPE ProLiant DL380 Gen10/ProLiant DL380 Gen10, BIOS U30 06/15/2023\nRIP: 0010:memcpy_orig+0xcd/0x130\nRSP: 0018:ffffb7a18c3ffc40 EFLAGS: 00010202\nRAX: 00007f4801111000 RBX: 00007f4801111000 RCX: 000000000000000f\nRDX: 000000000000000f RSI: ffffffffc0bfd7a0 RDI: 00007f4801111000\nRBP: ffffffffc0bfd7a0 R08: 725f746f6e5f6f64 R09: 3d7265766f636572\nR10: ffffb7a18c3ffd08 R11: 0000000000000000 R12: 00007f4881110fff\nR13: 000000007fffffff R14: ffffb7a18c3ffca0 R15: ffffffffc0bfd7af\nFS:  00007f480118a740(0000) GS:ffff98e38af00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f4801111000 CR3: 0000000864b8e001 CR4: 00000000007706e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\n? __die_body+0x1a/0x60\n? page_fault_oops+0x183/0x510\n? exc_page_fault+0x69/0x150\n? asm_exc_page_fault+0x22/0x30\n? memcpy_orig+0xcd/0x130\nvsnprintf+0x102/0x4c0\nsprintf+0x51/0x80\nqedi_dbg_do_not_recover_cmd_read+0x2f/0x50 [qedi 6bcfdeeecdea037da47069eca2ba717c84a77324]\nfull_proxy_read+0x50/0x80\nvfs_read+0xa5/0x2e0\n? folio_add_new_anon_rmap+0x44/0xa0\n? set_pte_at+0x15/0x30\n? do_pte_missing+0x426/0x7f0\nksys_read+0xa5/0xe0\ndo_syscall_64+0x58/0x80\n? __count_memcg_events+0x46/0x90\n? count_memcg_event_mm+0x3d/0x60\n? handle_mm_fault+0x196/0x2f0\n? do_user_addr_fault+0x267/0x890\n? exc_page_fault+0x69/0x150\nentry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x7f4800f20b4d\n\nCVE-2024-40988:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/radeon: fix UBSAN warning in kv_dpm.c\nAdds bounds check for sumo_vid_mapping_entry.\n\nCVE-2024-40989:\nIn the Linux kernel, the following vulnerability has been resolved:\nKVM: arm64: Disassociate vcpus from redistributor region on teardown\nWhen tearing down a redistributor region, make sure we don't have\nany dangling pointer to that region stored in a vcpu.\n\nCVE-2024-40995:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sched: act_api: fix possible infinite loop in tcf_idr_check_alloc()\nsyzbot found hanging tasks waiting on rtnl_lock [1]\nA reproducer is available in the syzbot bug.\nWhen a request to add multiple actions with the same index is sent, the\nsecond request will block forever on the first request. This holds\nrtnl_lock, and causes tasks to hang.\nReturn -EAGAIN to prevent infinite looping, while keeping documented\nbehavior.\n[1]\nINFO: task kworker/1:0:5088 blocked for more than 143 seconds.\nNot tainted 6.9.0-rc4-syzkaller-00173-g3cdb45594619 #0\n\"echo 0 \u003e /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\ntask:kworker/1:0 state:D stack:23744 pid:5088 tgid:5088 ppid:2 flags:0x00004000\nWorkqueue: events_power_efficient reg_check_chans_work\nCall Trace:\n\u003cTASK\u003e\ncontext_switch kernel/sched/core.c:5409 [inline]\n__schedule+0xf15/0x5d00 kernel/sched/core.c:6746\n__schedule_loop kernel/sched/core.c:6823 [inline]\nschedule+0xe7/0x350 kernel/sched/core.c:6838\nschedule_preempt_disabled+0x13/0x30 kernel/sched/core.c:6895\n__mutex_lock_common kernel/locking/mutex.c:684 [inline]\n__mutex_lock+0x5b8/0x9c0 kernel/locking/mutex.c:752\nwiphy_lock include/net/cfg80211.h:5953 [inline]\nreg_leave_invalid_chans net/wireless/reg.c:2466 [inline]\nreg_check_chans_work+0x10a/0x10e0 net/wireless/reg.c:2481\n\nCVE-2024-40997:\nIn the Linux kernel, the following vulnerability has been resolved:\ncpufreq: amd-pstate: fix memory leak on CPU EPP exit\nThe cpudata memory from kzalloc() in amd_pstate_epp_cpu_init() is\nnot freed in the analogous exit function, so fix that.\n[ rjw: Subject and changelog edits ]\n\nCVE-2024-40998:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: fix uninitialized ratelimit_state-\u003elock access in __ext4_fill_super()\nIn the following concurrency we will access the uninitialized rs-\u003elock:\next4_fill_super\next4_register_sysfs\n// sysfs registered msg_ratelimit_interval_ms\n// Other processes modify rs-\u003einterval to\n// non-zero via msg_ratelimit_interval_ms\next4_orphan_cleanup\next4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n__ext4_msg\n___ratelimit(\u0026(EXT4_SB(sb)-\u003es_msg_ratelimit_state)\nif (!rs-\u003einterval)  // do nothing if interval is 0\nreturn 1;\nraw_spin_trylock_irqsave(\u0026rs-\u003elock, flags)\nraw_spin_trylock(lock)\n_raw_spin_trylock\n__raw_spin_trylock\nspin_acquire(\u0026lock-\u003edep_map, 0, 1, _RET_IP_)\nlock_acquire\n__lock_acquire\nregister_lock_class\nassign_lock_key\ndump_stack();\nratelimit_state_init(\u0026sbi-\u003es_msg_ratelimit_state, 5 * HZ, 10);\nraw_spin_lock_init(\u0026rs-\u003elock);\n// init rs-\u003elock here\nand get the following dump_stack:\n=========================================================\nINFO: trying to register non-static key.\nThe code is fine but needs lockdep annotation, or maybe\nyou didn't initialize this object before use?\nturning off the locking correctness validator.\nCPU: 12 PID: 753 Comm: mount Tainted: G E 6.7.0-rc6-next-20231222 #504\n[...]\nCall Trace:\ndump_stack_lvl+0xc5/0x170\ndump_stack+0x18/0x30\nregister_lock_class+0x740/0x7c0\n__lock_acquire+0x69/0x13a0\nlock_acquire+0x120/0x450\n_raw_spin_trylock+0x98/0xd0\n___ratelimit+0xf6/0x220\n__ext4_msg+0x7f/0x160 [ext4]\next4_orphan_cleanup+0x665/0x740 [ext4]\n__ext4_fill_super+0x21ea/0x2b10 [ext4]\next4_fill_super+0x14d/0x360 [ext4]\n[...]\n=========================================================\nNormally interval is 0 until s_msg_ratelimit_state is initialized, so\n___ratelimit() does nothing. But registering sysfs precedes initializing\nrs-\u003elock, so it is possible to change rs-\u003einterval to a non-zero value\nvia the msg_ratelimit_interval_ms interface of sysfs while rs-\u003elock is\nuninitialized, and then a call to ext4_msg triggers the problem by\naccessing an uninitialized rs-\u003elock. Therefore register sysfs after all\ninitializations are complete to avoid such problems.\n\nCVE-2024-41005:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetpoll: Fix race condition in netpoll_owner_active\nKCSAN detected a race condition in netpoll:\nBUG: KCSAN: data-race in net_rx_action / netpoll_send_skb\nwrite (marked) to 0xffff8881164168b0 of 4 bytes by interrupt on cpu 10:\nnet_rx_action (./include/linux/netpoll.h:90 net/core/dev.c:6712 net/core/dev.c:6822)\n\u003csnip\u003e\nread to 0xffff8881164168b0 of 4 bytes by task 1 on cpu 2:\nnetpoll_send_skb (net/core/netpoll.c:319 net/core/netpoll.c:345 net/core/netpoll.c:393)\nnetpoll_send_udp (net/core/netpoll.c:?)\n\u003csnip\u003e\nvalue changed: 0x0000000a -\u003e 0xffffffff\nThis happens because netpoll_owner_active() needs to check if the\ncurrent CPU is the owner of the lock, touching napi-\u003epoll_owner\nnon atomically. The -\u003epoll_owner field contains the current CPU holding\nthe lock.\nUse an atomic read to check if the poll owner is the current CPU.\n\nCVE-2024-41007:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: avoid too many retransmit packets\nIf a TCP socket is using TCP_USER_TIMEOUT, and the other peer\nretracted its window to zero, tcp_retransmit_timer() can\nretransmit a packet every two jiffies (2 ms for HZ=1000),\nfor about 4 minutes after TCP_USER_TIMEOUT has 'expired'.\nThe fix is to make sure tcp_rtx_probe0_timed_out() takes\nicsk-\u003eicsk_user_timeout into account.\nBefore blamed commit, the socket would not timeout after\nicsk-\u003eicsk_user_timeout, but would use standard exponential\nbackoff for the retransmits.\nAlso worth noting that before commit e89688e3e978 (\"net: tcp:\nfix unexcepted socket die when snd_wnd is 0\"), the issue\nwould last 2 minutes instead of 4.\n\nCVE-2024-41008:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: change vm-\u003etask_info handling\nThis patch changes the handling and lifecycle of vm-\u003etask_info object.\nThe major changes are:\n- vm-\u003etask_info is a dynamically allocated ptr now, and its uasge is\nreference counted.\n- introducing two new helper funcs for task_info lifecycle management\n- amdgpu_vm_get_task_info: reference counts up task_info before\nreturning this info\n- amdgpu_vm_put_task_info: reference counts down task_info\n- last put to task_info() frees task_info from the vm.\nThis patch also does logistical changes required for existing usage\nof vm-\u003etask_info.\nV2: Do not block all the prints when task_info not found (Felix)\nV3: Fixed review comments from Felix\n- Fix wrong indentation\n- No debug message for -ENOMEM\n- Add NULL check for task_info\n- Do not duplicate the debug messages (ti vs no ti)\n- Get first reference of task_info in vm_init(), put last\nin vm_fini()\nV4: Fixed review comments from Felix\n- fix double reference increment in create_task_info\n- change amdgpu_vm_get_task_info_pasid\n- additional changes in amdgpu_gem.c while porting\n\nCVE-2024-41012:\nIn the Linux kernel, the following vulnerability has been resolved:\nfilelock: Remove locks reliably when fcntl/close race is detected\nWhen fcntl_setlk() races with close(), it removes the created lock with\ndo_lock_file_wait().\nHowever, LSMs can allow the first do_lock_file_wait() that created the lock\nwhile denying the second do_lock_file_wait() that tries to remove the lock.\nSeparately, posix_lock_file() could also fail to\nremove a lock due to GFP_KERNEL allocation failure (when splitting a range\nin the middle).\nAfter the bug has been triggered, use-after-free reads will occur in\nlock_get_status() when userspace reads /proc/locks. This can likely be used\nto read arbitrary kernel memory, but can't corrupt kernel memory.\nFix it by calling locks_remove_posix() instead, which is designed to\nreliably get rid of POSIX locks associated with the given file and\nfiles_struct and is also used by filp_flush().\n\nCVE-2024-41013:\nIn the Linux kernel, the following vulnerability has been resolved:\nxfs: don't walk off the end of a directory data block\nThis adds sanity checks for xfs_dir2_data_unused and xfs_dir2_data_entry\nto make sure don't stray beyond valid memory region. Before patching, the\nloop simply checks that the start offset of the dup and dep is within the\nrange. So in a crafted image, if last entry is xfs_dir2_data_unused, we\ncan change dup-\u003elength to dup-\u003elength-1 and leave 1 byte of space. In the\nnext traversal, this space will be considered as dup or dep. We may\nencounter an out of bound read when accessing the fixed members.\nIn the patch, we make sure that the remaining bytes large enough to hold\nan unused entry before accessing xfs_dir2_data_unused and\nxfs_dir2_data_unused is XFS_DIR2_DATA_ALIGN byte aligned. We also make\nsure that the remaining bytes large enough to hold a dirent with a\nsingle-byte name before accessing xfs_dir2_data_entry.\n\nCVE-2024-41014:\nIn the Linux kernel, the following vulnerability has been resolved:\nxfs: add bounds checking to xlog_recover_process_data\nThere is a lack of verification of the space occupied by fixed members\nof xlog_op_header in the xlog_recover_process_data.\nWe can create a crafted image to trigger an out of bounds read by\nfollowing these steps:\n1) Mount an image of xfs, and do some file operations to leave records\n2) Before umounting, copy the image for subsequent steps to simulate\nabnormal exit. Because umount will ensure that tail_blk and\nhead_blk are the same, which will result in the inability to enter\nxlog_recover_process_data\n3) Write a tool to parse and modify the copied image in step 2\n4) Make the end of the xlog_op_header entries only 1 byte away from\nxlog_rec_header-\u003eh_size\n5) xlog_rec_header-\u003eh_num_logops++\n6) Modify xlog_rec_header-\u003eh_crc\nFix:\nAdd a check to make sure there is sufficient space to access fixed members\nof xlog_op_header.\n\nCVE-2024-41023:\nIn the Linux kernel, the following vulnerability has been resolved:\nsched/deadline: Fix task_struct reference leak\nDuring the execution of the following stress test with linux-rt:\nstress-ng --cyclic 30 --timeout 30 --minimize --quiet\nkmemleak frequently reported a memory leak concerning the task_struct:\nunreferenced object 0xffff8881305b8000 (size 16136):\ncomm \"stress-ng\", pid 614, jiffies 4294883961 (age 286.412s)\nobject hex dump (first 32 bytes):\n02 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .@..............\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\ndebug hex dump (first 16 bytes):\n53 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00  S...............\nbacktrace:\n[\u003c00000000046b6790\u003e] dup_task_struct+0x30/0x540\n[\u003c00000000c5ca0f0b\u003e] copy_process+0x3d9/0x50e0\n[\u003c00000000ced59777\u003e] kernel_clone+0xb0/0x770\n[\u003c00000000a50befdc\u003e] __do_sys_clone+0xb6/0xf0\n[\u003c000000001dbf2008\u003e] do_syscall_64+0x5d/0xf0\n[\u003c00000000552900ff\u003e] entry_SYSCALL_64_after_hwframe+0x6e/0x76\nThe issue occurs in start_dl_timer(), which increments the task_struct\nreference count and sets a timer. The timer callback, dl_task_timer,\nis supposed to decrement the reference count upon expiration. However,\nif enqueue_task_dl() is called before the timer expires and cancels it,\nthe reference count is not decremented, leading to the leak.\nThis patch fixes the reference leak by ensuring the task_struct\nreference count is properly decremented when the timer is canceled.\n\nCVE-2024-41035:\nIn the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Fix duplicate endpoint bug by clearing reserved bits in the descriptor\nSyzbot has identified a bug in usbcore (see the Closes: tag below)\ncaused by our assumption that the reserved bits in an endpoint\ndescriptor's bEndpointAddress field will always be 0.  As a result of\nthe bug, the endpoint_is_duplicate() routine in config.c (and possibly\nother routines as well) may believe that two descriptors are for\ndistinct endpoints, even though they have the same direction and\nendpoint number.  This can lead to confusion, including the bug\nidentified by syzbot (two descriptors with matching endpoint numbers\nand directions, where one was interrupt and the other was bulk).\nTo fix the bug, we will clear the reserved bits in bEndpointAddress\nwhen we parse the descriptor.  (Note that both the USB-2.0 and USB-3.1\nspecs say these bits are \"Reserved, reset to zero\".)  This requires us\nto make a copy of the descriptor earlier in usb_parse_endpoint() and\nuse the copy instead of the original when checking for duplicates.\n\nCVE-2024-41038:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirmware: cs_dsp: Prevent buffer overrun when processing V2 alg headers\nCheck that all fields of a V2 algorithm header fit into the available\nfirmware data buffer.\nThe wmfw V2 format introduced variable-length strings in the algorithm\nblock header. This means the overall header length is variable, and the\nposition of most fields varies depending on the length of the string\nfields. Each field must be checked to ensure that it does not overflow\nthe firmware data buffer.\nAs this ia bugfix patch, the fixes avoid making any significant change to\nthe existing code. This makes it easier to review and less likely to\nintroduce new bugs.\n\nCVE-2024-41039:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirmware: cs_dsp: Fix overflow checking of wmfw header\nFix the checking that firmware file buffer is large enough for the\nwmfw header, to prevent overrunning the buffer.\nThe original code tested that the firmware data buffer contained\nenough bytes for the sums of the size of the structs\nwmfw_header + wmfw_adsp1_sizes + wmfw_footer\nBut wmfw_adsp1_sizes is only used on ADSP1 firmware. For ADSP2 and\nHalo Core the equivalent struct is wmfw_adsp2_sizes, which is\n4 bytes longer. So the length check didn't guarantee that there\nare enough bytes in the firmware buffer for a header with\nwmfw_adsp2_sizes.\nThis patch splits the length check into three separate parts. Each\nof the wmfw_header, wmfw_adsp?_sizes and wmfw_footer are checked\nseparately before they are used.\n\nCVE-2024-41040:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sched: Fix UAF when resolving a clash\nKASAN reports the following UAF:\nBUG: KASAN: slab-use-after-free in tcf_ct_flow_table_process_conn+0x12b/0x380 [act_ct]\nRead of size 1 at addr ffff888c07603600 by task handler130/6469\nCall Trace:\n\u003cIRQ\u003e\ndump_stack_lvl+0x48/0x70\nprint_address_description.constprop.0+0x33/0x3d0\nprint_report+0xc0/0x2b0\nkasan_report+0xd0/0x120\n__asan_load1+0x6c/0x80\ntcf_ct_flow_table_process_conn+0x12b/0x380 [act_ct]\ntcf_ct_act+0x886/0x1350 [act_ct]\ntcf_action_exec+0xf8/0x1f0\nfl_classify+0x355/0x360 [cls_flower]\n__tcf_classify+0x1fd/0x330\ntcf_classify+0x21c/0x3c0\nsch_handle_ingress.constprop.0+0x2c5/0x500\n__netif_receive_skb_core.constprop.0+0xb25/0x1510\n__netif_receive_skb_list_core+0x220/0x4c0\nnetif_receive_skb_list_internal+0x446/0x620\nnapi_complete_done+0x157/0x3d0\ngro_cell_poll+0xcf/0x100\n__napi_poll+0x65/0x310\nnet_rx_action+0x30c/0x5c0\n__do_softirq+0x14f/0x491\n__irq_exit_rcu+0x82/0xc0\nirq_exit_rcu+0xe/0x20\ncommon_interrupt+0xa1/0xb0\n\u003c/IRQ\u003e\n\u003cTASK\u003e\nasm_common_interrupt+0x27/0x40\nAllocated by task 6469:\nkasan_save_stack+0x38/0x70\nkasan_set_track+0x25/0x40\nkasan_save_alloc_info+0x1e/0x40\n__kasan_krealloc+0x133/0x190\nkrealloc+0xaa/0x130\nnf_ct_ext_add+0xed/0x230 [nf_conntrack]\ntcf_ct_act+0x1095/0x1350 [act_ct]\ntcf_action_exec+0xf8/0x1f0\nfl_classify+0x355/0x360 [cls_flower]\n__tcf_classify+0x1fd/0x330\ntcf_classify+0x21c/0x3c0\nsch_handle_ingress.constprop.0+0x2c5/0x500\n__netif_receive_skb_core.constprop.0+0xb25/0x1510\n__netif_receive_skb_list_core+0x220/0x4c0\nnetif_receive_skb_list_internal+0x446/0x620\nnapi_complete_done+0x157/0x3d0\ngro_cell_poll+0xcf/0x100\n__napi_poll+0x65/0x310\nnet_rx_action+0x30c/0x5c0\n__do_softirq+0x14f/0x491\nFreed by task 6469:\nkasan_save_stack+0x38/0x70\nkasan_set_track+0x25/0x40\nkasan_save_free_info+0x2b/0x60\n____kasan_slab_free+0x180/0x1f0\n__kasan_slab_free+0x12/0x30\nslab_free_freelist_hook+0xd2/0x1a0\n__kmem_cache_free+0x1a2/0x2f0\nkfree+0x78/0x120\nnf_conntrack_free+0x74/0x130 [nf_conntrack]\nnf_ct_destroy+0xb2/0x140 [nf_conntrack]\n__nf_ct_resolve_clash+0x529/0x5d0 [nf_conntrack]\nnf_ct_resolve_clash+0xf6/0x490 [nf_conntrack]\n__nf_conntrack_confirm+0x2c6/0x770 [nf_conntrack]\ntcf_ct_act+0x12ad/0x1350 [act_ct]\ntcf_action_exec+0xf8/0x1f0\nfl_classify+0x355/0x360 [cls_flower]\n__tcf_classify+0x1fd/0x330\ntcf_classify+0x21c/0x3c0\nsch_handle_ingress.constprop.0+0x2c5/0x500\n__netif_receive_skb_core.constprop.0+0xb25/0x1510\n__netif_receive_skb_list_core+0x220/0x4c0\nnetif_receive_skb_list_internal+0x446/0x620\nnapi_complete_done+0x157/0x3d0\ngro_cell_poll+0xcf/0x100\n__napi_poll+0x65/0x310\nnet_rx_action+0x30c/0x5c0\n__do_softirq+0x14f/0x491\nThe ct may be dropped if a clash has been resolved but is still passed to\nthe tcf_ct_flow_table_process_conn function for further usage. This issue\ncan be fixed by retrieving ct from skb again after confirming conntrack.\n\nCVE-2024-41041:\nIn the Linux kernel, the following vulnerability has been resolved:\nudp: Set SOCK_RCU_FREE earlier in udp_lib_get_port().\nsyzkaller triggered the warning [0] in udp_v4_early_demux().\nIn udp_v[46]_early_demux() and sk_lookup(), we do not touch the refcount\nof the looked-up sk and use sock_pfree() as skb-\u003edestructor, so we check\nSOCK_RCU_FREE to ensure that the sk is safe to access during the RCU grace\nperiod.\nCurrently, SOCK_RCU_FREE is flagged for a bound socket after being put\ninto the hash table.  Moreover, the SOCK_RCU_FREE check is done too early\nin udp_v[46]_early_demux() and sk_lookup(), so there could be a small race\nwindow:\nCPU1                                 CPU2\n----                                 ----\nudp_v4_early_demux()                 udp_lib_get_port()\n|                                    |- hlist_add_head_rcu()\n|- sk = __udp4_lib_demux_lookup()    |\n|- DEBUG_NET_WARN_ON_ONCE(sk_is_refcounted(sk));\n`- sock_set_flag(sk, SOCK_RCU_FREE)\nWe had the same bug in TCP and fixed it in commit 871019b22d1b (\"net:\nset SOCK_RCU_FREE before inserting socket into hashtable\").\nLet's apply the same fix for UDP.\n[0]:\nWARNING: CPU: 0 PID: 11198 at net/ipv4/udp.c:2599 udp_v4_early_demux+0x481/0xb70 net/ipv4/udp.c:2599\nModules linked in:\nCPU: 0 PID: 11198 Comm: syz-executor.1 Not tainted 6.9.0-g93bda33046e7 #13\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nRIP: 0010:udp_v4_early_demux+0x481/0xb70 net/ipv4/udp.c:2599\nCode: c5 7a 15 fe bb 01 00 00 00 44 89 e9 31 ff d3 e3 81 e3 bf ef ff ff 89 de e8 2c 74 15 fe 85 db 0f 85 02 06 00 00 e8 9f 7a 15 fe \u003c0f\u003e 0b e8 98 7a 15 fe 49 8d 7e 60 e8 4f 39 2f fe 49 c7 46 60 20 52\nRSP: 0018:ffffc9000ce3fa58 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff8318c92c\nRDX: ffff888036ccde00 RSI: ffffffff8318c2f1 RDI: 0000000000000001\nRBP: ffff88805a2dd6e0 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 0001ffffffffffff R12: ffff88805a2dd680\nR13: 0000000000000007 R14: ffff88800923f900 R15: ffff88805456004e\nFS:  00007fc449127640(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fc449126e38 CR3: 000000003de4b002 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\nip_rcv_finish_core.constprop.0+0xbdd/0xd20 net/ipv4/ip_input.c:349\nip_rcv_finish+0xda/0x150 net/ipv4/ip_input.c:447\nNF_HOOK include/linux/netfilter.h:314 [inline]\nNF_HOOK include/linux/netfilter.h:308 [inline]\nip_rcv+0x16c/0x180 net/ipv4/ip_input.c:569\n__netif_receive_skb_one_core+0xb3/0xe0 net/core/dev.c:5624\n__netif_receive_skb+0x21/0xd0 net/core/dev.c:5738\nnetif_receive_skb_internal net/core/dev.c:5824 [inline]\nnetif_receive_skb+0x271/0x300 net/core/dev.c:5884\ntun_rx_batched drivers/net/tun.c:1549 [inline]\ntun_get_user+0x24db/0x2c50 drivers/net/tun.c:2002\ntun_chr_write_iter+0x107/0x1a0 drivers/net/tun.c:2048\nnew_sync_write fs/read_write.c:497 [inline]\nvfs_write+0x76f/0x8d0 fs/read_write.c:590\nksys_write+0xbf/0x190 fs/read_write.c:643\n__do_sys_write fs/read_write.c:655 [inline]\n__se_sys_write fs/read_write.c:652 [inline]\n__x64_sys_write+0x41/0x50 fs/read_write.c:652\nx64_sys_call+0xe66/0x1990 arch/x86/include/generated/asm/syscalls_64.h:2\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0x4b/0x110 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x4b/0x53\nRIP: 0033:0x7fc44a68bc1f\nCode: 89 54 24 18 48 89 74 24 10 89 7c 24 08 e8 e9 cf f5 ff 48 8b 54 24 18 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 01 00 00 00 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 31 44 89 c7 48 89 44 24 08 e8 3c d0 f5 ff 48\nRSP: 002b:00007fc449126c90 EFLAGS: 00000293 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 00000000004bc050 RCX: 00007fc44a68bc1f\nR\n---truncated---\n\nCVE-2024-41044:\nIn the Linux kernel, the following vulnerability has been resolved:\nppp: reject claimed-as-LCP but actually malformed packets\nSince 'ppp_async_encode()' assumes valid LCP packets (with code\nfrom 1 to 7 inclusive), add 'ppp_check_packet()' to ensure that\nLCP packet has an actual body beyond PPP_LCP header bytes, and\nreject claimed-as-LCP but actually malformed data otherwise.\n\nCVE-2024-41055:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm: prevent derefencing NULL ptr in pfn_section_valid()\nCommit 5ec8e8ea8b77 (\"mm/sparsemem: fix race in accessing\nmemory_section-\u003eusage\") changed pfn_section_valid() to add a READ_ONCE()\ncall around \"ms-\u003eusage\" to fix a race with section_deactivate() where\nms-\u003eusage can be cleared.  The READ_ONCE() call, by itself, is not enough\nto prevent NULL pointer dereference.  We need to check its value before\ndereferencing it.\n\nCVE-2024-41056:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirmware: cs_dsp: Use strnlen() on name fields in V1 wmfw files\nUse strnlen() instead of strlen() on the algorithm and coefficient name\nstring arrays in V1 wmfw files.\nIn V1 wmfw files the name is a NUL-terminated string in a fixed-size\narray. cs_dsp should protect against overrunning the array if the NUL\nterminator is missing.\n\nCVE-2024-41060:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/radeon: check bo_va-\u003ebo is non-NULL before using it\nThe call to radeon_vm_clear_freed might clear bo_va-\u003ebo, so\nwe have to check it before dereferencing it.\n\nCVE-2024-41064:\nIn the Linux kernel, the following vulnerability has been resolved:\npowerpc/eeh: avoid possible crash when edev-\u003epdev changes\nIf a PCI device is removed during eeh_pe_report_edev(), edev-\u003epdev\nwill change and can cause a crash, hold the PCI rescan/remove lock\nwhile taking a copy of edev-\u003epdev-\u003ebus.\n\nCVE-2024-41065:\nIn the Linux kernel, the following vulnerability has been resolved:\npowerpc/pseries: Whitelist dtl slub object for copying to userspace\nReading the dispatch trace log from /sys/kernel/debug/powerpc/dtl/cpu-*\nresults in a BUG() when the config CONFIG_HARDENED_USERCOPY is enabled as\nshown below.\nkernel BUG at mm/usercopy.c:102!\nOops: Exception in kernel mode, sig: 5 [#1]\nLE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA pSeries\nModules linked in: xfs libcrc32c dm_service_time sd_mod t10_pi sg ibmvfc\nscsi_transport_fc ibmveth pseries_wdt dm_multipath dm_mirror dm_region_hash dm_log dm_mod fuse\nCPU: 27 PID: 1815 Comm: python3 Not tainted 6.10.0-rc3 #85\nHardware name: IBM,9040-MRX POWER10 (raw) 0x800200 0xf000006 of:IBM,FW1060.00 (NM1060_042) hv:phyp pSeries\nNIP:  c0000000005d23d4 LR: c0000000005d23d0 CTR: 00000000006ee6f8\nREGS: c000000120c078c0 TRAP: 0700   Not tainted  (6.10.0-rc3)\nMSR:  8000000000029033 \u003cSF,EE,ME,IR,DR,RI,LE\u003e  CR: 2828220f  XER: 0000000e\nCFAR: c0000000001fdc80 IRQMASK: 0\n[ ... GPRs omitted ... ]\nNIP [c0000000005d23d4] usercopy_abort+0x78/0xb0\nLR [c0000000005d23d0] usercopy_abort+0x74/0xb0\nCall Trace:\nusercopy_abort+0x74/0xb0 (unreliable)\n__check_heap_object+0xf8/0x120\ncheck_heap_object+0x218/0x240\n__check_object_size+0x84/0x1a4\ndtl_file_read+0x17c/0x2c4\nfull_proxy_read+0x8c/0x110\nvfs_read+0xdc/0x3a0\nksys_read+0x84/0x144\nsystem_call_exception+0x124/0x330\nsystem_call_vectored_common+0x15c/0x2ec\n--- interrupt: 3000 at 0x7fff81f3ab34\nCommit 6d07d1cd300f (\"usercopy: Restrict non-usercopy caches to size 0\")\nrequires that only whitelisted areas in slab/slub objects can be copied to\nuserspace when usercopy hardening is enabled using CONFIG_HARDENED_USERCOPY.\nDtl contains hypervisor dispatch events which are expected to be read by\nprivileged users. Hence mark this safe for user access.\nSpecify useroffset=0 and usersize=DISPATCH_LOG_BYTES to whitelist the\nentire object.\n\nCVE-2024-41071:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: mac80211: Avoid address calculations via out of bounds array indexing\nreq-\u003en_channels must be set before req-\u003echannels[] can be used.\nThis patch fixes one of the issues encountered in [1].\n[   83.964255] UBSAN: array-index-out-of-bounds in net/mac80211/scan.c:364:4\n[   83.964258] index 0 is out of range for type 'struct ieee80211_channel *[]'\n[...]\n[   83.964264] Call Trace:\n[   83.964267]  \u003cTASK\u003e\n[   83.964269]  dump_stack_lvl+0x3f/0xc0\n[   83.964274]  __ubsan_handle_out_of_bounds+0xec/0x110\n[   83.964278]  ieee80211_prep_hw_scan+0x2db/0x4b0\n[   83.964281]  __ieee80211_start_scan+0x601/0x990\n[   83.964291]  nl80211_trigger_scan+0x874/0x980\n[   83.964295]  genl_family_rcv_msg_doit+0xe8/0x160\n[   83.964298]  genl_rcv_msg+0x240/0x270\n[...]\n[1] https://bugzilla.kernel.org/show_bug.cgi?id=218810\n\nCVE-2024-41076:\nIn the Linux kernel, the following vulnerability has been resolved:\nNFSv4: Fix memory leak in nfs4_set_security_label\nWe leak nfs_fattr and nfs4_label every time we set a security xattr.\n\nCVE-2024-41090:\nIn the Linux kernel, the following vulnerability has been resolved:\ntap: add missing verification for short frame\nThe cited commit missed to check against the validity of the frame length\nin the tap_get_user_xdp() path, which could cause a corrupted skb to be\nsent downstack. Even before the skb is transmitted, the\ntap_get_user_xdp()--\u003eskb_set_network_header() may assume the size is more\nthan ETH_HLEN. Once transmitted, this could either cause out-of-bound\naccess beyond the actual length, or confuse the underlayer with incorrect\nor inconsistent header length in the skb metadata.\nIn the alternative path, tap_get_user() already prohibits short frame which\nhas the length less than Ethernet header size from being transmitted.\nThis is to drop any frame shorter than the Ethernet header size just like\nhow tap_get_user() does.\nCVE: CVE-2024-41090\n\nCVE-2024-41091:\nIn the Linux kernel, the following vulnerability has been resolved:\ntun: add missing verification for short frame\nThe cited commit missed to check against the validity of the frame length\nin the tun_xdp_one() path, which could cause a corrupted skb to be sent\ndownstack. Even before the skb is transmitted, the\ntun_xdp_one--\u003eeth_type_trans() may access the Ethernet header although it\ncan be less than ETH_HLEN. Once transmitted, this could either cause\nout-of-bound access beyond the actual length, or confuse the underlayer\nwith incorrect or inconsistent header length in the skb metadata.\nIn the alternative path, tun_get_user() already prohibits short frame which\nhas the length less than Ethernet header size from being transmitted for\nIFF_TAP.\nThis is to drop any frame shorter than the Ethernet header size just like\nhow tun_get_user() does.\nCVE: CVE-2024-41091\n\nCVE-2024-41097:\nIn the Linux kernel, the following vulnerability has been resolved:\nusb: atm: cxacru: fix endpoint checking in cxacru_bind()\nSyzbot is still reporting quite an old issue [1] that occurs due to\nincomplete checking of present usb endpoints. As such, wrong\nendpoints types may be used at urb sumbitting stage which in turn\ntriggers a warning in usb_submit_urb().\nFix the issue by verifying that required endpoint types are present\nfor both in and out endpoints, taking into account cmd endpoint type.\nUnfortunately, this patch has not been tested on real hardware.\n[1] Syzbot report:\nusb 1-1: BOGUS urb xfer, pipe 1 != type 3\nWARNING: CPU: 0 PID: 8667 at drivers/usb/core/urb.c:502 usb_submit_urb+0xed2/0x18a0 drivers/usb/core/urb.c:502\nModules linked in:\nCPU: 0 PID: 8667 Comm: kworker/0:4 Not tainted 5.14.0-rc4-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nWorkqueue: usb_hub_wq hub_event\nRIP: 0010:usb_submit_urb+0xed2/0x18a0 drivers/usb/core/urb.c:502\n...\nCall Trace:\ncxacru_cm+0x3c0/0x8e0 drivers/usb/atm/cxacru.c:649\ncxacru_card_status+0x22/0xd0 drivers/usb/atm/cxacru.c:760\ncxacru_bind+0x7ac/0x11a0 drivers/usb/atm/cxacru.c:1209\nusbatm_usb_probe+0x321/0x1ae0 drivers/usb/atm/usbatm.c:1055\ncxacru_usb_probe+0xdf/0x1e0 drivers/usb/atm/cxacru.c:1363\nusb_probe_interface+0x315/0x7f0 drivers/usb/core/driver.c:396\ncall_driver_probe drivers/base/dd.c:517 [inline]\nreally_probe+0x23c/0xcd0 drivers/base/dd.c:595\n__driver_probe_device+0x338/0x4d0 drivers/base/dd.c:747\ndriver_probe_device+0x4c/0x1a0 drivers/base/dd.c:777\n__device_attach_driver+0x20b/0x2f0 drivers/base/dd.c:894\nbus_for_each_drv+0x15f/0x1e0 drivers/base/bus.c:427\n__device_attach+0x228/0x4a0 drivers/base/dd.c:965\nbus_probe_device+0x1e4/0x290 drivers/base/bus.c:487\ndevice_add+0xc2f/0x2180 drivers/base/core.c:3354\nusb_set_configuration+0x113a/0x1910 drivers/usb/core/message.c:2170\nusb_generic_driver_probe+0xba/0x100 drivers/usb/core/generic.c:238\nusb_probe_device+0xd9/0x2c0 drivers/usb/core/driver.c:293\n\nCVE-2024-42084:\nIn the Linux kernel, the following vulnerability has been resolved:\nftruncate: pass a signed offset\nThe old ftruncate() syscall, using the 32-bit off_t misses a sign\nextension when called in compat mode on 64-bit architectures.  As a\nresult, passing a negative length accidentally succeeds in truncating\nto file size between 2GiB and 4GiB.\nChanging the type of the compat syscall to the signed compat_off_t\nchanges the behavior so it instead returns -EINVAL.\nThe native entry point, the truncate() syscall and the corresponding\nloff_t based variants are all correct already and do not suffer\nfrom this mistake.\n\nCVE-2024-42090:\nIn the Linux kernel, the following vulnerability has been resolved:\npinctrl: fix deadlock in create_pinctrl() when handling -EPROBE_DEFER\nIn create_pinctrl(), pinctrl_maps_mutex is acquired before calling\nadd_setting(). If add_setting() returns -EPROBE_DEFER, create_pinctrl()\ncalls pinctrl_free(). However, pinctrl_free() attempts to acquire\npinctrl_maps_mutex, which is already held by create_pinctrl(), leading to\na potential deadlock.\nThis patch resolves the issue by releasing pinctrl_maps_mutex before\ncalling pinctrl_free(), preventing the deadlock.\nThis bug was discovered and resolved using Coverity Static Analysis\nSecurity Testing (SAST) by Synopsys, Inc.\n\nCVE-2024-42094:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/iucv: Avoid explicit cpumask var allocation on stack\nFor CONFIG_CPUMASK_OFFSTACK=y kernel, explicit allocation of cpumask\nvariable on stack is not recommended since it can cause potential stack\noverflow.\nInstead, kernel code should always use *cpumask_var API(s) to allocate\ncpumask var in config-neutral way, leaving allocation strategy to\nCONFIG_CPUMASK_OFFSTACK.\nUse *cpumask_var API(s) to address it.\n\nCVE-2024-42096:\nIn the Linux kernel, the following vulnerability has been resolved:\nx86: stop playing stack games in profile_pc()\nThe 'profile_pc()' function is used for timer-based profiling, which\nisn't really all that relevant any more to begin with, but it also ends\nup making assumptions based on the stack layout that aren't necessarily\nvalid.\nBasically, the code tries to account the time spent in spinlocks to the\ncaller rather than the spinlock, and while I support that as a concept,\nit's not worth the code complexity or the KASAN warnings when no serious\nprofiling is done using timers anyway these days.\nAnd the code really does depend on stack layout that is only true in the\nsimplest of cases.  We've lost the comment at some point (I think when\nthe 32-bit and 64-bit code was unified), but it used to say:\nAssume the lock function has either no stack frame or a copy\nof eflags from PUSHF.\nwhich explains why it just blindly loads a word or two straight off the\nstack pointer and then takes a minimal look at the values to just check\nif they might be eflags or the return pc:\nEflags always has bits 22 and up cleared unlike kernel addresses\nbut that basic stack layout assumption assumes that there isn't any lock\ndebugging etc going on that would complicate the code and cause a stack\nframe.\nIt causes KASAN unhappiness reported for years by syzkaller [1] and\nothers [2].\nWith no real practical reason for this any more, just remove the code.\nJust for historical interest, here's some background commits relating to\nthis code from 2006:\n0cb91a229364 (\"i386: Account spinlocks to the caller during profiling for !FP kernels\")\n31679f38d886 (\"Simplify profile_pc on x86-64\")\nand a code unification from 2009:\nef4512882dbe (\"x86: time_32/64.c unify profile_pc\")\nbut the basics of this thing actually goes back to before the git tree.\n\nCVE-2024-42114:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: cfg80211: restrict NL80211_ATTR_TXQ_QUANTUM values\nsyzbot is able to trigger softlockups, setting NL80211_ATTR_TXQ_QUANTUM\nto 2^31.\nWe had a similar issue in sch_fq, fixed with commit\nd9e15a273306 (\"pkt_sched: fq: do not accept silly TCA_FQ_QUANTUM\")\nwatchdog: BUG: soft lockup - CPU#1 stuck for 26s! [kworker/1:0:24]\nModules linked in:\nirq event stamp: 131135\nhardirqs last  enabled at (131134): [\u003cffff80008ae8778c\u003e] __exit_to_kernel_mode arch/arm64/kernel/entry-common.c:85 [inline]\nhardirqs last  enabled at (131134): [\u003cffff80008ae8778c\u003e] exit_to_kernel_mode+0xdc/0x10c arch/arm64/kernel/entry-common.c:95\nhardirqs last disabled at (131135): [\u003cffff80008ae85378\u003e] __el1_irq arch/arm64/kernel/entry-common.c:533 [inline]\nhardirqs last disabled at (131135): [\u003cffff80008ae85378\u003e] el1_interrupt+0x24/0x68 arch/arm64/kernel/entry-common.c:551\nsoftirqs last  enabled at (125892): [\u003cffff80008907e82c\u003e] neigh_hh_init net/core/neighbour.c:1538 [inline]\nsoftirqs last  enabled at (125892): [\u003cffff80008907e82c\u003e] neigh_resolve_output+0x268/0x658 net/core/neighbour.c:1553\nsoftirqs last disabled at (125896): [\u003cffff80008904166c\u003e] local_bh_disable+0x10/0x34 include/linux/bottom_half.h:19\nCPU: 1 PID: 24 Comm: kworker/1:0 Not tainted 6.9.0-rc7-syzkaller-gfda5695d692c #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nWorkqueue: mld mld_ifc_work\npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __list_del include/linux/list.h:195 [inline]\npc : __list_del_entry include/linux/list.h:218 [inline]\npc : list_move_tail include/linux/list.h:310 [inline]\npc : fq_tin_dequeue include/net/fq_impl.h:112 [inline]\npc : ieee80211_tx_dequeue+0x6b8/0x3b4c net/mac80211/tx.c:3854\nlr : __list_del_entry include/linux/list.h:218 [inline]\nlr : list_move_tail include/linux/list.h:310 [inline]\nlr : fq_tin_dequeue include/net/fq_impl.h:112 [inline]\nlr : ieee80211_tx_dequeue+0x67c/0x3b4c net/mac80211/tx.c:3854\nsp : ffff800093d36700\nx29: ffff800093d36a60 x28: ffff800093d36960 x27: dfff800000000000\nx26: ffff0000d800ad50 x25: ffff0000d800abe0 x24: ffff0000d800abf0\nx23: ffff0000e0032468 x22: ffff0000e00324d4 x21: ffff0000d800abf0\nx20: ffff0000d800abf8 x19: ffff0000d800abf0 x18: ffff800093d363c0\nx17: 000000000000d476 x16: ffff8000805519dc x15: ffff7000127a6cc8\nx14: 1ffff000127a6cc8 x13: 0000000000000004 x12: ffffffffffffffff\nx11: ffff7000127a6cc8 x10: 0000000000ff0100 x9 : 0000000000000000\nx8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000\nx5 : ffff80009287aa08 x4 : 0000000000000008 x3 : ffff80008034c7fc\nx2 : ffff0000e0032468 x1 : 00000000da0e46b8 x0 : ffff0000e0032470\nCall trace:\n__list_del include/linux/list.h:195 [inline]\n__list_del_entry include/linux/list.h:218 [inline]\nlist_move_tail include/linux/list.h:310 [inline]\nfq_tin_dequeue include/net/fq_impl.h:112 [inline]\nieee80211_tx_dequeue+0x6b8/0x3b4c net/mac80211/tx.c:3854\nwake_tx_push_queue net/mac80211/util.c:294 [inline]\nieee80211_handle_wake_tx_queue+0x118/0x274 net/mac80211/util.c:315\ndrv_wake_tx_queue net/mac80211/driver-ops.h:1350 [inline]\nschedule_and_wake_txq net/mac80211/driver-ops.h:1357 [inline]\nieee80211_queue_skb+0x18e8/0x2244 net/mac80211/tx.c:1664\nieee80211_tx+0x260/0x400 net/mac80211/tx.c:1966\nieee80211_xmit+0x278/0x354 net/mac80211/tx.c:2062\n__ieee80211_subif_start_xmit+0xab8/0x122c net/mac80211/tx.c:4338\nieee80211_subif_start_xmit+0xe0/0x438 net/mac80211/tx.c:4532\n__netdev_start_xmit include/linux/netdevice.h:4903 [inline]\nnetdev_start_xmit include/linux/netdevice.h:4917 [inline]\nxmit_one net/core/dev.c:3531 [inline]\ndev_hard_start_xmit+0x27c/0x938 net/core/dev.c:3547\n__dev_queue_xmit+0x1678/0x33fc net/core/dev.c:4341\ndev_queue_xmit include/linux/netdevice.h:3091 [inline]\nneigh_resolve_output+0x558/0x658 net/core/neighbour.c:1563\nneigh_output include/net/neighbour.h:542 [inline]\nip6_fini\n---truncated---\n\nCVE-2024-42124:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: qedf: Make qedf_execute_tmf() non-preemptible\nStop calling smp_processor_id() from preemptible code in\nqedf_execute_tmf90.  This results in BUG_ON() when running an RT kernel.\n[ 659.343280] BUG: using smp_processor_id() in preemptible [00000000] code: sg_reset/3646\n[ 659.343282] caller is qedf_execute_tmf+0x8b/0x360 [qedf]\n\nCVE-2024-42131:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm: avoid overflows in dirty throttling logic\nThe dirty throttling logic is interspersed with assumptions that dirty\nlimits in PAGE_SIZE units fit into 32-bit (so that various multiplications\nfit into 64-bits).  If limits end up being larger, we will hit overflows,\npossible divisions by 0 etc.  Fix these problems by never allowing so\nlarge dirty limits as they have dubious practical value anyway.  For\ndirty_bytes / dirty_background_bytes interfaces we can just refuse to set\nso large limits.  For dirty_ratio / dirty_background_ratio it isn't so\nsimple as the dirty limit is computed from the amount of available memory\nwhich can change due to memory hotplug etc.  So when converting dirty\nlimits from ratios to numbers of pages, we just don't allow the result to\nexceed UINT_MAX.\nThis is root-only triggerable problem which occurs when the operator\nsets dirty limits to \u003e16 TB.\n\nCVE-2024-42152:\nIn the Linux kernel, the following vulnerability has been resolved:\nnvmet: fix a possible leak when destroy a ctrl during qp establishment\nIn nvmet_sq_destroy we capture sq-\u003ectrl early and if it is non-NULL we\nknow that a ctrl was allocated (in the admin connect request handler)\nand we need to release pending AERs, clear ctrl-\u003esqs and sq-\u003ectrl\n(for nvme-loop primarily), and drop the final reference on the ctrl.\nHowever, a small window is possible where nvmet_sq_destroy starts (as\na result of the client giving up and disconnecting) concurrently with\nthe nvme admin connect cmd (which may be in an early stage). But *before*\nkill_and_confirm of sq-\u003eref (i.e. the admin connect managed to get an sq\nlive reference). In this case, sq-\u003ectrl was allocated however after it was\ncaptured in a local variable in nvmet_sq_destroy.\nThis prevented the final reference drop on the ctrl.\nSolve this by re-capturing the sq-\u003ectrl after all inflight request has\ncompleted, where for sure sq-\u003ectrl reference is final, and move forward\nbased on that.\nThis issue was observed in an environment with many hosts connecting\nmultiple ctrls simoutanuosly, creating a delay in allocating a ctrl\nleading up to this race window.\n\nCVE-2024-42154:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp_metrics: validate source addr length\nI don't see anything checking that TCP_METRICS_ATTR_SADDR_IPV4\nis at least 4 bytes long, and the policy doesn't have an entry\nfor this attribute at all (neither does it for IPv6 but v6 is\nmanually validated).\n\nCVE-2024-42225:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: mt76: replace skb_put with skb_put_zero\nAvoid potentially reusing uninitialized data\n\nCVE-2024-42226:\nThis CVE ID has been rejected or withdrawn by its CVE Numbering Authority for the following reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.\n\nCVE-2024-42228:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amdgpu: Using uninitialized value *size when calling amdgpu_vce_cs_reloc\nInitialize the size before calling amdgpu_vce_cs_reloc, such as case 0x03000001.\nV2: To really improve the handling we would actually\nneed to have a separate value of 0xffffffff.(Christian)\n\nCVE-2024-42237:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirmware: cs_dsp: Validate payload length before processing block\nMove the payload length check in cs_dsp_load() and cs_dsp_coeff_load()\nto be done before the block is processed.\nThe check that the length of a block payload does not exceed the number\nof remaining bytes in the firwmware file buffer was being done near the\nend of the loop iteration. However, some code before that check used the\nlength field without validating it.\n\nCVE-2024-42238:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirmware: cs_dsp: Return error if block header overflows file\nReturn an error from cs_dsp_power_up() if a block header is longer\nthan the amount of data left in the file.\nThe previous code in cs_dsp_load() and cs_dsp_load_coeff() would loop\nwhile there was enough data left in the file for a valid region. This\nprotected against overrunning the end of the file data, but it didn't\nabort the file processing with an error.\n\nCVE-2024-42240:\nIn the Linux kernel, the following vulnerability has been resolved:\nx86/bhi: Avoid warning in #DB handler due to BHI mitigation\nWhen BHI mitigation is enabled, if SYSENTER is invoked with the TF flag set\nthen entry_SYSENTER_compat() uses CLEAR_BRANCH_HISTORY and calls the\nclear_bhb_loop() before the TF flag is cleared. This causes the #DB handler\n(exc_debug_kernel()) to issue a warning because single-step is used outside the\nentry_SYSENTER_compat() function.\nTo address this issue, entry_SYSENTER_compat() should use CLEAR_BRANCH_HISTORY\nafter making sure the TF flag is cleared.\nThe problem can be reproduced with the following sequence:\n$ cat sysenter_step.c\nint main()\n{ asm(\"pushf; pop %ax; bts $8,%ax; push %ax; popf; sysenter\"); }\n$ gcc -o sysenter_step sysenter_step.c\n$ ./sysenter_step\nSegmentation fault (core dumped)\nThe program is expected to crash, and the #DB handler will issue a warning.\nKernel log:\nWARNING: CPU: 27 PID: 7000 at arch/x86/kernel/traps.c:1009 exc_debug_kernel+0xd2/0x160\n...\nRIP: 0010:exc_debug_kernel+0xd2/0x160\n...\nCall Trace:\n\u003c#DB\u003e\n? show_regs+0x68/0x80\n? __warn+0x8c/0x140\n? exc_debug_kernel+0xd2/0x160\n? report_bug+0x175/0x1a0\n? handle_bug+0x44/0x90\n? exc_invalid_op+0x1c/0x70\n? asm_exc_invalid_op+0x1f/0x30\n? exc_debug_kernel+0xd2/0x160\nexc_debug+0x43/0x50\nasm_exc_debug+0x1e/0x40\nRIP: 0010:clear_bhb_loop+0x0/0xb0\n...\n\u003c/#DB\u003e\n\u003cTASK\u003e\n? entry_SYSENTER_compat_after_hwframe+0x6e/0x8d\n\u003c/TASK\u003e\n[ bp: Massage commit message. ]\n\nCVE-2024-42246:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet, sunrpc: Remap EPERM in case of connection failure in xs_tcp_setup_socket\nWhen using a BPF program on kernel_connect(), the call can return -EPERM. This\ncauses xs_tcp_setup_socket() to loop forever, filling up the syslog and causing\nthe kernel to potentially freeze up.\nNeil suggested:\nThis will propagate -EPERM up into other layers which might not be ready\nto handle it. It might be safer to map EPERM to an error we would be more\nlikely to expect from the network system - such as ECONNREFUSED or ENETDOWN.\nECONNREFUSED as error seems reasonable. For programs setting a different error\ncan be out of reach (see handling in 4fbac77d2d09) in particular on kernels\nwhich do not have f10d05966196 (\"bpf: Make BPF_PROG_RUN_ARRAY return -err\ninstead of allow boolean\"), thus given that it is better to simply remap for\nconsistent behavior. UDP does handle EPERM in xs_udp_send_request().\n\nCVE-2024-42265:\nIn the Linux kernel, the following vulnerability has been resolved:\nprotect the fetch of -\u003efd[fd] in do_dup2() from mispredictions\nboth callers have verified that fd is not greater than -\u003emax_fds;\nhowever, misprediction might end up with\ntofree = fdt-\u003efd[fd];\nbeing speculatively executed.  That's wrong for the same reasons\nwhy it's wrong in close_fd()/file_close_fd_locked(); the same\nsolution applies - array_index_nospec(fd, fdt-\u003emax_fds) could differ\nfrom fd only in case of speculative execution on mispredicted path.\n\nCVE-2024-42322:\nIn the Linux kernel, the following vulnerability has been resolved:\nipvs: properly dereference pe in ip_vs_add_service\nUse pe directly to resolve sparse warning:\nnet/netfilter/ipvs/ip_vs_ctl.c:1471:27: warning: dereference of noderef expression\n\nCVE-2024-43830:\nIn the Linux kernel, the following vulnerability has been resolved:\nleds: trigger: Unregister sysfs attributes before calling deactivate()\nTriggers which have trigger specific sysfs attributes typically store\nrelated data in trigger-data allocated by the activate() callback and\nfreed by the deactivate() callback.\nCalling device_remove_groups() after calling deactivate() leaves a window\nwhere the sysfs attributes show/store functions could be called after\ndeactivation and then operate on the just freed trigger-data.\nMove the device_remove_groups() call to before deactivate() to close\nthis race window.\nThis also makes the deactivation path properly do things in reverse order\nof the activation path which calls the activate() callback before calling\ndevice_add_groups().\n\nCVE-2024-43871:\nIn the Linux kernel, the following vulnerability has been resolved:\ndevres: Fix memory leakage caused by driver API devm_free_percpu()\nIt will cause memory leakage when use driver API devm_free_percpu()\nto free memory allocated by devm_alloc_percpu(), fixed by using\ndevres_release() instead of devres_destroy() within devm_free_percpu().",
    "Advisory": {
      "Severity": "Important",
      "Issued": {
        "Date": "2024-09-26"
      },
      "Updated": {
        "Date": "2024-09-27"
      },
      "Cves": [
        {
          "ID": "CVE-2021-46984",
          "CVSS3": "6.0/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-46984",
          "CWE": "CWE-125",
          "Public": "20240228"
        },
        {
          "ID": "CVE-2021-47097",
          "CVSS3": "6.0/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47097",
          "CWE": "CWE-125",
          "Public": "20240304"
        },
        {
          "ID": "CVE-2021-47101",
          "CVSS3": "6.0/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47101",
          "CWE": "CWE-457",
          "Public": "20240304"
        },
        {
          "ID": "CVE-2021-47287",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47287",
          "CWE": "CWE-402",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47289",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47289",
          "CWE": "CWE-476",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47321",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47321",
          "CWE": "CWE-416",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2021-47338",
          "CVSS3": "5.1/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47338",
          "CWE": "CWE-416",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47352",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47352",
          "CWE": "CWE-20",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47383",
          "CVSS3": "6.6/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47383",
          "CWE": "CWE-125",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47384",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47384",
          "CWE": "",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47385",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47385",
          "CWE": "CWE-476",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47386",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47386",
          "CWE": "CWE-476",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2021-47393",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47393",
          "CWE": "CWE-754",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47412",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47412",
          "CWE": "CWE-388",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47432",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47432",
          "CWE": "",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2021-47441",
          "CVSS3": "4.8/CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:L/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47441",
          "CWE": "",
          "Public": "20240522"
        },
        {
          "ID": "CVE-2021-47455",
          "CVSS3": "5.1/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:L",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47455",
          "CWE": "",
          "Public": "20240522"
        },
        {
          "ID": "CVE-2021-47466",
          "CVSS3": "7.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47466",
          "CWE": "CWE-402",
          "Public": "20240522"
        },
        {
          "ID": "CVE-2021-47497",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47497",
          "CWE": "CWE-125",
          "Public": "20240522"
        },
        {
          "ID": "CVE-2021-47527",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47527",
          "CWE": "CWE-400",
          "Public": "20240524"
        },
        {
          "ID": "CVE-2021-47560",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47560",
          "CWE": "CWE-476",
          "Public": "20240524"
        },
        {
          "ID": "CVE-2021-47582",
          "CVSS3": "3.3/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47582",
          "CWE": "CWE-667",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2021-47609",
          "CVSS3": "6.7/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47609",
          "CWE": "CWE-787",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2022-48619",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48619",
          "CWE": "CWE-400",
          "Public": "20220321"
        },
        {
          "ID": "CVE-2022-48754",
          "CVSS3": "5.6/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48754",
          "CWE": "CWE-416",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2022-48760",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48760",
          "CWE": "CWE-820",
          "Public": "20240620"
        },
        {
          "ID": "CVE-2022-48804",
          "CVSS3": "7.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48804",
          "CWE": "",
          "Public": "20240716"
        },
        {
          "ID": "CVE-2022-48836",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48836",
          "CWE": "",
          "Public": "20240716"
        },
        {
          "ID": "CVE-2022-48866",
          "CVSS3": "6.0/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48866",
          "CWE": "CWE-125",
          "Public": "20240716"
        },
        {
          "ID": "CVE-2023-52470",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52470",
          "CWE": "CWE-476",
          "Public": "20240226"
        },
        {
          "ID": "CVE-2023-52476",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52476",
          "CWE": "CWE-404",
          "Public": "20240229"
        },
        {
          "ID": "CVE-2023-52478",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52478",
          "CWE": "CWE-362",
          "Public": "20240228"
        },
        {
          "ID": "CVE-2023-52522",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52522",
          "CWE": "CWE-20",
          "Public": "20240302"
        },
        {
          "ID": "CVE-2023-52605",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52605",
          "CWE": "CWE-476",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2023-52683",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52683",
          "CWE": "",
          "Public": "20240517"
        },
        {
          "ID": "CVE-2023-52798",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52798",
          "CWE": "CWE-416",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2023-52800",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52800",
          "CWE": "CWE-413",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2023-52809",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52809",
          "CWE": "CWE-476",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2023-52817",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52817",
          "CWE": "CWE-476",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2023-52840",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52840",
          "CWE": "CWE-416",
          "Public": "20240521"
        },
        {
          "ID": "CVE-2023-6040",
          "CVSS3": "7.8/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-6040",
          "CWE": "CWE-119",
          "Public": "20240112"
        },
        {
          "ID": "CVE-2024-23848",
          "CVSS3": "6.7/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-23848",
          "CWE": "CWE-416",
          "Public": "20240123"
        },
        {
          "ID": "CVE-2024-26595",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26595",
          "CWE": "",
          "Public": "20240223"
        },
        {
          "ID": "CVE-2024-26600",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26600",
          "CWE": "CWE-476",
          "Public": "20240224"
        },
        {
          "ID": "CVE-2024-26638",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26638",
          "CWE": "CWE-456",
          "Public": "20240318"
        },
        {
          "ID": "CVE-2024-26645",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26645",
          "CWE": "CWE-362",
          "Public": "20240326"
        },
        {
          "ID": "CVE-2024-26649",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26649",
          "CWE": "CWE-476",
          "Public": "20240326"
        },
        {
          "ID": "CVE-2024-26665",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26665",
          "CWE": "CWE-125",
          "Public": "20240402"
        },
        {
          "ID": "CVE-2024-26717",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26717",
          "CWE": "CWE-476",
          "Public": "20240403"
        },
        {
          "ID": "CVE-2024-26720",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26720",
          "CWE": "CWE-369",
          "Public": "20240403"
        },
        {
          "ID": "CVE-2024-26769",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26769",
          "CWE": "CWE-833",
          "Public": "20240403"
        },
        {
          "ID": "CVE-2024-26846",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26846",
          "CWE": "CWE-362",
          "Public": "20240417"
        },
        {
          "ID": "CVE-2024-26855",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26855",
          "CWE": "CWE-690",
          "Public": "20240417"
        },
        {
          "ID": "CVE-2024-26880",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26880",
          "CWE": "CWE-99",
          "Public": "20240417"
        },
        {
          "ID": "CVE-2024-26894",
          "CVSS3": "6.0/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26894",
          "CWE": "CWE-401",
          "Public": "20240417"
        },
        {
          "ID": "CVE-2024-26923",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26923",
          "CWE": "CWE-362",
          "Public": "20240424"
        },
        {
          "ID": "CVE-2024-26939",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26939",
          "CWE": "",
          "Public": "20240501"
        },
        {
          "ID": "CVE-2024-27013",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27013",
          "CWE": "",
          "Public": "20240501"
        },
        {
          "ID": "CVE-2024-27042",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27042",
          "CWE": "",
          "Public": "20240501"
        },
        {
          "ID": "CVE-2024-35809",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35809",
          "CWE": "",
          "Public": "20240517"
        },
        {
          "ID": "CVE-2024-35877",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35877",
          "CWE": "",
          "Public": "20240519"
        },
        {
          "ID": "CVE-2024-35884",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35884",
          "CWE": "",
          "Public": "20240519"
        },
        {
          "ID": "CVE-2024-35944",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35944",
          "CWE": "",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-35989",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35989",
          "CWE": "",
          "Public": "20240520"
        },
        {
          "ID": "CVE-2024-36883",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36883",
          "CWE": "CWE-787",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36901",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36901",
          "CWE": "CWE-476",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36902",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36902",
          "CWE": "CWE-476",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36919",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36919",
          "CWE": "CWE-667",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36920",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36920",
          "CWE": "",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36922",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36922",
          "CWE": "CWE-413",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36939",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36939",
          "CWE": "CWE-99",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36953",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36953",
          "CWE": "CWE-158",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-37356",
          "CVSS3": "6.6/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-37356",
          "CWE": "CWE-125",
          "Public": "20240621"
        },
        {
          "ID": "CVE-2024-38558",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38558",
          "CWE": "CWE-665",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2024-38559",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38559",
          "CWE": "CWE-125",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2024-38570",
          "CVSS3": "5.8/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38570",
          "CWE": "CWE-416",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2024-38579",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38579",
          "CWE": "CWE-99",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2024-38581",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38581",
          "CWE": "",
          "Public": "20240619"
        },
        {
          "ID": "CVE-2024-38619",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38619",
          "CWE": "CWE-457",
          "Public": "20240620"
        },
        {
          "ID": "CVE-2024-39471",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39471",
          "CWE": "CWE-125",
          "Public": "20240625"
        },
        {
          "ID": "CVE-2024-39499",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39499",
          "CWE": "CWE-119",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-39501",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39501",
          "CWE": "",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-39506",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39506",
          "CWE": "CWE-476",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40901",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40901",
          "CWE": "",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40904",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40904",
          "CWE": "CWE-667",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40911",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40911",
          "CWE": "CWE-476",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40912",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40912",
          "CWE": "CWE-833",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40929",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40929",
          "CWE": "CWE-125",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40931",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40931",
          "CWE": "CWE-400",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40941",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40941",
          "CWE": "CWE-125",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40954",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40954",
          "CWE": "CWE-125",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-40958",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40958",
          "CWE": "CWE-416",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-40959",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40959",
          "CWE": "CWE-476",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40960",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40960",
          "CWE": "CWE-476",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40972",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40972",
          "CWE": "CWE-833",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40977",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40977",
          "CWE": "CWE-833",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40978",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40978",
          "CWE": "CWE-822",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40988",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40988",
          "CWE": "CWE-787",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40989",
          "CVSS3": "5.6/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40989",
          "CWE": "CWE-825",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40995",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40995",
          "CWE": "CWE-833",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-40997",
          "CVSS3": "5.1/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:L",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40997",
          "CWE": "CWE-402",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-40998",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40998",
          "CWE": "",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-41005",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41005",
          "CWE": "CWE-362",
          "Public": "20240712"
        },
        {
          "ID": "CVE-2024-41007",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41007",
          "CWE": "CWE-99",
          "Public": "20240715"
        },
        {
          "ID": "CVE-2024-41008",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41008",
          "CWE": "CWE-99",
          "Public": "20240716"
        },
        {
          "ID": "CVE-2024-41012",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41012",
          "CWE": "",
          "Public": "20240723"
        },
        {
          "ID": "CVE-2024-41013",
          "CVSS3": "7.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41013",
          "CWE": "CWE-125",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41014",
          "CVSS3": "6.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41014",
          "CWE": "CWE-125",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41023",
          "CVSS3": "6.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41023",
          "CWE": "CWE-401",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41035",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41035",
          "CWE": "CWE-99",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41038",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41038",
          "CWE": "CWE-122",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-41039",
          "CVSS3": "5.2/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41039",
          "CWE": "CWE-122",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41040",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41040",
          "CWE": "CWE-416",
          "Public": "20240728"
        },
        {
          "ID": "CVE-2024-41041",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41041",
          "CWE": "CWE-911",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41044",
          "CVSS3": "4.9/CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41044",
          "CWE": "CWE-20",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41055",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41055",
          "CWE": "CWE-476",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41056",
          "CVSS3": "5.2/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41056",
          "CWE": "CWE-787",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41060",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41060",
          "CWE": "CWE-20",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41064",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41064",
          "CWE": "CWE-413",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41065",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41065",
          "CWE": "CWE-99",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41071",
          "CVSS3": "7.8/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41071",
          "CWE": "CWE-787",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41076",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41076",
          "CWE": "CWE-401",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-41090",
          "CVSS3": "7.1/CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41090",
          "CWE": "CWE-20",
          "Public": "20240728"
        },
        {
          "ID": "CVE-2024-41091",
          "CVSS3": "7.1/CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41091",
          "CWE": "CWE-20",
          "Public": "20240728"
        },
        {
          "ID": "CVE-2024-41097",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-41097",
          "CWE": "CWE-99",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-42084",
          "CVSS3": "6.3/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42084",
          "CWE": "CWE-96",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-42090",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42090",
          "CWE": "CWE-833",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-42094",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42094",
          "CWE": "",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-42096",
          "CVSS3": "5.1/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42096",
          "CWE": "CWE-125",
          "Public": "20240729"
        },
        {
          "ID": "CVE-2024-42114",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42114",
          "CWE": "CWE-400",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42124",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42124",
          "CWE": "CWE-372",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42131",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42131",
          "CWE": "CWE-190",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42152",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42152",
          "CWE": "CWE-404",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42154",
          "CVSS3": "2.5/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:N",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42154",
          "CWE": "CWE-130",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42225",
          "CVSS3": "4.8/CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42225",
          "CWE": "CWE-457",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42226",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42226",
          "CWE": "CWE-822",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42228",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42228",
          "CWE": "CWE-457",
          "Public": "20240730"
        },
        {
          "ID": "CVE-2024-42237",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42237",
          "CWE": "CWE-99",
          "Public": "20240807"
        },
        {
          "ID": "CVE-2024-42238",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42238",
          "CWE": "CWE-99",
          "Public": "20240926"
        },
        {
          "ID": "CVE-2024-42240",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42240",
          "CWE": "CWE-99",
          "Public": "20240807"
        },
        {
          "ID": "CVE-2024-42246",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42246",
          "CWE": "CWE-835",
          "Public": "20240807"
        },
        {
          "ID": "CVE-2024-42265",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42265",
          "CWE": "CWE-99",
          "Public": "20240817"
        },
        {
          "ID": "CVE-2024-42322",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-42322",
          "CWE": "",
          "Public": "20240817"
        },
        {
          "ID": "CVE-2024-43830",
          "CVSS3": "6.6/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-43830",
          "CWE": "CWE-416",
          "Public": "20240817"
        },
        {
          "ID": "CVE-2024-43871",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-43871",
          "CWE": "CWE-402",
          "Public": "20240821"
        }
      ],
      "AffectedCpeList": [
        "cpe:2.3:o:openanolis:anolis_os:8:*:*:*:*:*:*:* "
      ]
    }
  },
  "Criteria": {
    "Operator": "AND",
    "Criterias": [
      {
        "Operator": "OR",
        "Criterias": null,
        "Criterions": [
          {
            "Comment": "bpftool is earlier than 0:4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924001"
          },
          {
            "Comment": "kernel is earlier than 0:4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924002"
          },
          {
            "Comment": "kernel-core is earlier than 0:core-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924003"
          },
          {
            "Comment": "kernel-cross-headers is earlier than 0:cross-headers-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924004"
          },
          {
            "Comment": "kernel-debug is earlier than 0:debug-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924005"
          },
          {
            "Comment": "kernel-debug-core is earlier than 0:debug-core-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924006"
          },
          {
            "Comment": "kernel-debug-devel is earlier than 0:debug-devel-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924007"
          },
          {
            "Comment": "kernel-debug-modules is earlier than 0:debug-modules-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924008"
          },
          {
            "Comment": "kernel-debug-modules-extra is earlier than 0:debug-modules-extra-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924009"
          },
          {
            "Comment": "kernel-devel is earlier than 0:devel-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924010"
          },
          {
            "Comment": "kernel-headers is earlier than 0:headers-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924011"
          },
          {
            "Comment": "kernel-modules is earlier than 0:modules-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924012"
          },
          {
            "Comment": "kernel-modules-extra is earlier than 0:modules-extra-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924013"
          },
          {
            "Comment": "kernel-tools is earlier than 0:tools-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924014"
          },
          {
            "Comment": "kernel-tools-libs is earlier than 0:tools-libs-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924015"
          },
          {
            "Comment": "kernel-tools-libs-devel is earlier than 0:tools-libs-devel-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924016"
          },
          {
            "Comment": "perf is earlier than 0:4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924017"
          },
          {
            "Comment": "python3-perf is earlier than 0:perf-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924018"
          },
          {
            "Comment": "kernel-abi-stablelists is earlier than 0:abi-stablelists-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924019"
          },
          {
            "Comment": "kernel-doc is earlier than 0:doc-4.18.0-553.22.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240924020"
          }
        ]
      }
    ],
    "Criterions": [
      {
        "Comment": "Anolis OS 8 is installed",
        "TestRef": "oval:cn.openanolis:tst:1"
      }
    ]
  }
}