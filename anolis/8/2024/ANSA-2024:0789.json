{
  "ID": "oval:cn.openanolis:def:20240789",
  "Version": "1",
  "Class": "patch",
  "Metadata": {
    "Title": "ANSA-2024:0789: kernel security update (Moderate)",
    "Affected": {
      "Family": "unix",
      "Platform": [
        "Anolis OS 8"
      ]
    },
    "References": [
      {
        "RefID": "ANSA-2024:0789",
        "RefURL": "https://anas.openanolis.cn/errata/detail/ANSA-2024:0789",
        "Source": "ANSA"
      }
    ],
    "Description": "Package updates are available for Anolis 8 that fix the following vulnerabilities:\n\nCVE-2021-46939:\nIn the Linux kernel, the following vulnerability has been resolved:\ntracing: Restructure trace_clock_global() to never block\nIt was reported that a fix to the ring buffer recursion detection would\ncause a hung machine when performing suspend / resume testing. The\nfollowing backtrace was extracted from debugging that case:\nCall Trace:\ntrace_clock_global+0x91/0xa0\n__rb_reserve_next+0x237/0x460\nring_buffer_lock_reserve+0x12a/0x3f0\ntrace_buffer_lock_reserve+0x10/0x50\n__trace_graph_return+0x1f/0x80\ntrace_graph_return+0xb7/0xf0\n? trace_clock_global+0x91/0xa0\nftrace_return_to_handler+0x8b/0xf0\n? pv_hash+0xa0/0xa0\nreturn_to_handler+0x15/0x30\n? ftrace_graph_caller+0xa0/0xa0\n? trace_clock_global+0x91/0xa0\n? __rb_reserve_next+0x237/0x460\n? ring_buffer_lock_reserve+0x12a/0x3f0\n? trace_event_buffer_lock_reserve+0x3c/0x120\n? trace_event_buffer_reserve+0x6b/0xc0\n? trace_event_raw_event_device_pm_callback_start+0x125/0x2d0\n? dpm_run_callback+0x3b/0xc0\n? pm_ops_is_empty+0x50/0x50\n? platform_get_irq_byname_optional+0x90/0x90\n? trace_device_pm_callback_start+0x82/0xd0\n? dpm_run_callback+0x49/0xc0\nWith the following RIP:\nRIP: 0010:native_queued_spin_lock_slowpath+0x69/0x200\nSince the fix to the recursion detection would allow a single recursion to\nhappen while tracing, this lead to the trace_clock_global() taking a spin\nlock and then trying to take it again:\nring_buffer_lock_reserve() {\ntrace_clock_global() {\narch_spin_lock() {\nqueued_spin_lock_slowpath() {\n/* lock taken */\n(something else gets traced by function graph tracer)\nring_buffer_lock_reserve() {\ntrace_clock_global() {\narch_spin_lock() {\nqueued_spin_lock_slowpath() {\n/* DEAD LOCK! */\nTracing should *never* block, as it can lead to strange lockups like the\nabove.\nRestructure the trace_clock_global() code to instead of simply taking a\nlock to update the recorded \"prev_time\" simply use it, as two events\nhappening on two different CPUs that calls this at the same time, really\ndoesn't matter which one goes first. Use a trylock to grab the lock for\nupdating the prev_time, and if it fails, simply try again the next time.\nIf it failed to be taken, that means something else is already updating\nit.\nBugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=212761\n\nCVE-2021-47018:\nIn the Linux kernel, the following vulnerability has been resolved:\npowerpc/64: Fix the definition of the fixmap area\nAt the time being, the fixmap area is defined at the top of\nthe address space or just below KASAN.\nThis definition is not valid for PPC64.\nFor PPC64, use the top of the I/O space.\nBecause of circular dependencies, it is not possible to include\nasm/fixmap.h in asm/book3s/64/pgtable.h , so define a fixed size\nAREA at the top of the I/O space for fixmap and ensure during\nbuild that the size is big enough.\n\nCVE-2021-47257:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: ieee802154: fix null deref in parse dev addr\nFix a logic error that could result in a null deref if the user sets\nthe mode incorrectly for the given addr type.\n\nCVE-2021-47284:\nIn the Linux kernel, the following vulnerability has been resolved:\nisdn: mISDN: netjet: Fix crash in nj_probe:\n'nj_setup' in netjet.c might fail with -EIO and in this case\n'card-\u003eirq' is initialized and is bigger than zero. A subsequent call to\n'nj_release' will free the irq that has not been requested.\nFix this bug by deleting the previous assignment to 'card-\u003eirq' and just\nkeep the assignment before 'request_irq'.\nThe KASAN's log reveals it:\n[    3.354615 ] WARNING: CPU: 0 PID: 1 at kernel/irq/manage.c:1826\nfree_irq+0x100/0x480\n[    3.355112 ] Modules linked in:\n[    3.355310 ] CPU: 0 PID: 1 Comm: swapper/0 Not tainted\n5.13.0-rc1-00144-g25a1298726e #13\n[    3.355816 ] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\nrel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n[    3.356552 ] RIP: 0010:free_irq+0x100/0x480\n[    3.356820 ] Code: 6e 08 74 6f 4d 89 f4 e8 5e ac 09 00 4d 8b 74 24 18\n4d 85 f6 75 e3 e8 4f ac 09 00 8b 75 c8 48 c7 c7 78 c1 2e 85 e8 e0 cf f5\nff \u003c0f\u003e 0b 48 8b 75 c0 4c 89 ff e8 72 33 0b 03 48 8b 43 40 4c 8b a0 80\n[    3.358012 ] RSP: 0000:ffffc90000017b48 EFLAGS: 00010082\n[    3.358357 ] RAX: 0000000000000000 RBX: ffff888104dc8000 RCX:\n0000000000000000\n[    3.358814 ] RDX: ffff8881003c8000 RSI: ffffffff8124a9e6 RDI:\n00000000ffffffff\n[    3.359272 ] RBP: ffffc90000017b88 R08: 0000000000000000 R09:\n0000000000000000\n[    3.359732 ] R10: ffffc900000179f0 R11: 0000000000001d04 R12:\n0000000000000000\n[    3.360195 ] R13: ffff888107dc6000 R14: ffff888107dc6928 R15:\nffff888104dc80a8\n[    3.360652 ] FS:  0000000000000000(0000) GS:ffff88817bc00000(0000)\nknlGS:0000000000000000\n[    3.361170 ] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    3.361538 ] CR2: 0000000000000000 CR3: 000000000582e000 CR4:\n00000000000006f0\n[    3.362003 ] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[    3.362175 ] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[    3.362175 ] Call Trace:\n[    3.362175 ]  nj_release+0x51/0x1e0\n[    3.362175 ]  nj_probe+0x450/0x950\n[    3.362175 ]  ? pci_device_remove+0x110/0x110\n[    3.362175 ]  local_pci_probe+0x45/0xa0\n[    3.362175 ]  pci_device_probe+0x12b/0x1d0\n[    3.362175 ]  really_probe+0x2a9/0x610\n[    3.362175 ]  driver_probe_device+0x90/0x1d0\n[    3.362175 ]  ? mutex_lock_nested+0x1b/0x20\n[    3.362175 ]  device_driver_attach+0x68/0x70\n[    3.362175 ]  __driver_attach+0x124/0x1b0\n[    3.362175 ]  ? device_driver_attach+0x70/0x70\n[    3.362175 ]  bus_for_each_dev+0xbb/0x110\n[    3.362175 ]  ? rdinit_setup+0x45/0x45\n[    3.362175 ]  driver_attach+0x27/0x30\n[    3.362175 ]  bus_add_driver+0x1eb/0x2a0\n[    3.362175 ]  driver_register+0xa9/0x180\n[    3.362175 ]  __pci_register_driver+0x82/0x90\n[    3.362175 ]  ? w6692_init+0x38/0x38\n[    3.362175 ]  nj_init+0x36/0x38\n[    3.362175 ]  do_one_initcall+0x7f/0x3d0\n[    3.362175 ]  ? rdinit_setup+0x45/0x45\n[    3.362175 ]  ? rcu_read_lock_sched_held+0x4f/0x80\n[    3.362175 ]  kernel_init_freeable+0x2aa/0x301\n[    3.362175 ]  ? rest_init+0x2c0/0x2c0\n[    3.362175 ]  kernel_init+0x18/0x190\n[    3.362175 ]  ? rest_init+0x2c0/0x2c0\n[    3.362175 ]  ? rest_init+0x2c0/0x2c0\n[    3.362175 ]  ret_from_fork+0x1f/0x30\n[    3.362175 ] Kernel panic - not syncing: panic_on_warn set ...\n[    3.362175 ] CPU: 0 PID: 1 Comm: swapper/0 Not tainted\n5.13.0-rc1-00144-g25a1298726e #13\n[    3.362175 ] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\nrel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n[    3.362175 ] Call Trace:\n[    3.362175 ]  dump_stack+0xba/0xf5\n[    3.362175 ]  ? free_irq+0x100/0x480\n[    3.362175 ]  panic+0x15a/0x3f2\n[    3.362175 ]  ? __warn+0xf2/0x150\n[    3.362175 ]  ? free_irq+0x100/0x480\n[    3.362175 ]  __warn+0x108/0x150\n[    3.362175 ]  ? free_irq+0x100/0x480\n[    3.362175 ]  report_bug+0x119/0x1c0\n[    3.362175 ]  handle_bug+0x3b/0x80\n[    3.362175 ]  exc_invalid_op+0x18/0x70\n[    3.362175 ]  asm_exc_invalid_op+0x12/0x20\n[    3.362175 ] RIP: 0010:free_irq+0x100\n---truncated---\n\nCVE-2021-47304:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: fix tcp_init_transfer() to not reset icsk_ca_initialized\nThis commit fixes a bug (found by syzkaller) that could cause spurious\ndouble-initializations for congestion control modules, which could cause\nmemory leaks or other problems for congestion control modules (like CDG)\nthat allocate memory in their init functions.\nThe buggy scenario constructed by syzkaller was something like:\n(1) create a TCP socket\n(2) initiate a TFO connect via sendto()\n(3) while socket is in TCP_SYN_SENT, call setsockopt(TCP_CONGESTION),\nwhich calls:\ntcp_set_congestion_control() -\u003e\ntcp_reinit_congestion_control() -\u003e\ntcp_init_congestion_control()\n(4) receive ACK, connection is established, call tcp_init_transfer(),\nset icsk_ca_initialized=0 (without first calling cc-\u003erelease()),\ncall tcp_init_congestion_control() again.\nNote that in this sequence tcp_init_congestion_control() is called\ntwice without a cc-\u003erelease() call in between. Thus, for CC modules\nthat allocate memory in their init() function, e.g, CDG, a memory leak\nmay occur. The syzkaller tool managed to find a reproducer that\ntriggered such a leak in CDG.\nThe bug was introduced when that commit 8919a9b31eb4 (\"tcp: Only init\ncongestion control if not initialized already\")\nintroduced icsk_ca_initialized and set icsk_ca_initialized to 0 in\ntcp_init_transfer(), missing the possibility for a sequence like the\none above, where a process could call setsockopt(TCP_CONGESTION) in\nstate TCP_SYN_SENT (i.e. after the connect() or TFO open sendmsg()),\nwhich would call tcp_init_congestion_control(). It did not intend to\nreset any initialization that the user had already explicitly made;\nit just missed the possibility of that particular sequence (which\nsyzkaller managed to find).\n\nCVE-2021-47373:\nIn the Linux kernel, the following vulnerability has been resolved:\nirqchip/gic-v3-its: Fix potential VPE leak on error\nIn its_vpe_irq_domain_alloc, when its_vpe_init() returns an error,\nthere is an off-by-one in the number of VPEs to be freed.\nFix it by simply passing the number of VPEs allocated, which is the\nindex of the loop iterating over the VPEs.\n[maz: fixed commit message]\n\nCVE-2021-47408:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: conntrack: serialize hash resizes and cleanups\nSyzbot was able to trigger the following warning [1]\nNo repro found by syzbot yet but I was able to trigger similar issue\nby having 2 scripts running in parallel, changing conntrack hash sizes,\nand:\nfor j in `seq 1 1000` ; do unshare -n /bin/true \u003e/dev/null ; done\nIt would take more than 5 minutes for net_namespace structures\nto be cleaned up.\nThis is because nf_ct_iterate_cleanup() has to restart everytime\na resize happened.\nBy adding a mutex, we can serialize hash resizes and cleanups\nand also make get_next_corpse() faster by skipping over empty\nbuckets.\nEven without resizes in the picture, this patch considerably\nspeeds up network namespace dismantles.\n[1]\nINFO: task syz-executor.0:8312 can't die for more than 144 seconds.\ntask:syz-executor.0  state:R  running task     stack:25672 pid: 8312 ppid:  6573 flags:0x00004006\nCall Trace:\ncontext_switch kernel/sched/core.c:4955 [inline]\n__schedule+0x940/0x26f0 kernel/sched/core.c:6236\npreempt_schedule_common+0x45/0xc0 kernel/sched/core.c:6408\npreempt_schedule_thunk+0x16/0x18 arch/x86/entry/thunk_64.S:35\n__local_bh_enable_ip+0x109/0x120 kernel/softirq.c:390\nlocal_bh_enable include/linux/bottom_half.h:32 [inline]\nget_next_corpse net/netfilter/nf_conntrack_core.c:2252 [inline]\nnf_ct_iterate_cleanup+0x15a/0x450 net/netfilter/nf_conntrack_core.c:2275\nnf_conntrack_cleanup_net_list+0x14c/0x4f0 net/netfilter/nf_conntrack_core.c:2469\nops_exit_list+0x10d/0x160 net/core/net_namespace.c:171\nsetup_net+0x639/0xa30 net/core/net_namespace.c:349\ncopy_net_ns+0x319/0x760 net/core/net_namespace.c:470\ncreate_new_namespaces+0x3f6/0xb20 kernel/nsproxy.c:110\nunshare_nsproxy_namespaces+0xc1/0x1f0 kernel/nsproxy.c:226\nksys_unshare+0x445/0x920 kernel/fork.c:3128\n__do_sys_unshare kernel/fork.c:3202 [inline]\n__se_sys_unshare kernel/fork.c:3200 [inline]\n__x64_sys_unshare+0x2d/0x40 kernel/fork.c:3200\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f63da68e739\nRSP: 002b:00007f63d7c05188 EFLAGS: 00000246 ORIG_RAX: 0000000000000110\nRAX: ffffffffffffffda RBX: 00007f63da792f80 RCX: 00007f63da68e739\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000040000000\nRBP: 00007f63da6e8cc4 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f63da792f80\nR13: 00007fff50b75d3f R14: 00007f63d7c05300 R15: 0000000000022000\nShowing all locks held in the system:\n1 lock held by khungtaskd/27:\n#0: ffffffff8b980020 (rcu_read_lock){....}-{1:2}, at: debug_show_all_locks+0x53/0x260 kernel/locking/lockdep.c:6446\n2 locks held by kworker/u4:2/153:\n#0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: arch_atomic64_set arch/x86/include/asm/atomic64_64.h:34 [inline]\n#0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: arch_atomic_long_set include/linux/atomic/atomic-long.h:41 [inline]\n#0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: atomic_long_set include/linux/atomic/atomic-instrumented.h:1198 [inline]\n#0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: set_work_data kernel/workqueue.c:634 [inline]\n#0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: set_work_pool_and_clear_pending kernel/workqueue.c:661 [inline]\n#0: ffff888010c69138 ((wq_completion)events_unbound){+.+.}-{0:0}, at: process_one_work+0x896/0x1690 kernel/workqueue.c:2268\n#1: ffffc9000140fdb0 ((kfence_timer).work){+.+.}-{0:0}, at: process_one_work+0x8ca/0x1690 kernel/workqueue.c:2272\n1 lock held by systemd-udevd/2970:\n1 lock held by in:imklog/6258:\n#0: ffff88807f970ff0 (\u0026f-\u003ef_pos_lock){+.+.}-{3:3}, at: __fdget_pos+0xe9/0x100 fs/file.c:990\n3 locks held by kworker/1:6/8158:\n1 lock held by syz-executor.0/8312:\n2 locks held by kworker/u4:13/9320:\n1 lock held by\n---truncated---\n\nCVE-2021-47461:\nIn the Linux kernel, the following vulnerability has been resolved:\nuserfaultfd: fix a race between writeprotect and exit_mmap()\nA race is possible when a process exits, its VMAs are removed by\nexit_mmap() and at the same time userfaultfd_writeprotect() is called.\nThe race was detected by KASAN on a development kernel, but it appears\nto be possible on vanilla kernels as well.\nUse mmget_not_zero() to prevent the race as done in other userfaultfd\noperations.\n\nCVE-2021-47468:\nIn the Linux kernel, the following vulnerability has been resolved:\nisdn: mISDN: Fix sleeping function called from invalid context\nThe driver can call card-\u003eisac.release() function from an atomic\ncontext.\nFix this by calling this function after releasing the lock.\nThe following log reveals it:\n[   44.168226 ] BUG: sleeping function called from invalid context at kernel/workqueue.c:3018\n[   44.168941 ] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 5475, name: modprobe\n[   44.169574 ] INFO: lockdep is turned off.\n[   44.169899 ] irq event stamp: 0\n[   44.170160 ] hardirqs last  enabled at (0): [\u003c0000000000000000\u003e] 0x0\n[   44.170627 ] hardirqs last disabled at (0): [\u003cffffffff814209ed\u003e] copy_process+0x132d/0x3e00\n[   44.171240 ] softirqs last  enabled at (0): [\u003cffffffff81420a1a\u003e] copy_process+0x135a/0x3e00\n[   44.171852 ] softirqs last disabled at (0): [\u003c0000000000000000\u003e] 0x0\n[   44.172318 ] Preemption disabled at:\n[   44.172320 ] [\u003cffffffffa009b0a9\u003e] nj_release+0x69/0x500 [netjet]\n[   44.174441 ] Call Trace:\n[   44.174630 ]  dump_stack_lvl+0xa8/0xd1\n[   44.174912 ]  dump_stack+0x15/0x17\n[   44.175166 ]  ___might_sleep+0x3a2/0x510\n[   44.175459 ]  ? nj_release+0x69/0x500 [netjet]\n[   44.175791 ]  __might_sleep+0x82/0xe0\n[   44.176063 ]  ? start_flush_work+0x20/0x7b0\n[   44.176375 ]  start_flush_work+0x33/0x7b0\n[   44.176672 ]  ? trace_irq_enable_rcuidle+0x85/0x170\n[   44.177034 ]  ? kasan_quarantine_put+0xaa/0x1f0\n[   44.177372 ]  ? kasan_quarantine_put+0xaa/0x1f0\n[   44.177711 ]  __flush_work+0x11a/0x1a0\n[   44.177991 ]  ? flush_work+0x20/0x20\n[   44.178257 ]  ? lock_release+0x13c/0x8f0\n[   44.178550 ]  ? __kasan_check_write+0x14/0x20\n[   44.178872 ]  ? do_raw_spin_lock+0x148/0x360\n[   44.179187 ]  ? read_lock_is_recursive+0x20/0x20\n[   44.179530 ]  ? __kasan_check_read+0x11/0x20\n[   44.179846 ]  ? do_raw_spin_unlock+0x55/0x900\n[   44.180168 ]  ? ____kasan_slab_free+0x116/0x140\n[   44.180505 ]  ? _raw_spin_unlock_irqrestore+0x41/0x60\n[   44.180878 ]  ? skb_queue_purge+0x1a3/0x1c0\n[   44.181189 ]  ? kfree+0x13e/0x290\n[   44.181438 ]  flush_work+0x17/0x20\n[   44.181695 ]  mISDN_freedchannel+0xe8/0x100\n[   44.182006 ]  isac_release+0x210/0x260 [mISDNipac]\n[   44.182366 ]  nj_release+0xf6/0x500 [netjet]\n[   44.182685 ]  nj_remove+0x48/0x70 [netjet]\n[   44.182989 ]  pci_device_remove+0xa9/0x250\n\nCVE-2021-47491:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm: khugepaged: skip huge page collapse for special files\nThe read-only THP for filesystems will collapse THP for files opened\nreadonly and mapped with VM_EXEC.  The intended usecase is to avoid TLB\nmisses for large text segments.  But it doesn't restrict the file types\nso a THP could be collapsed for a non-regular file, for example, block\ndevice, if it is opened readonly and mapped with EXEC permission.  This\nmay cause bugs, like [1] and [2].\nThis is definitely not the intended usecase, so just collapse THP for\nregular files in order to close the attack surface.\n[shy828301@gmail.com: fix vm_file check [3]]\n\nCVE-2021-47548:\nIn the Linux kernel, the following vulnerability has been resolved:\nethernet: hisilicon: hns: hns_dsaf_misc: fix a possible array overflow in hns_dsaf_ge_srst_by_port()\nThe if statement:\nif (port \u003e= DSAF_GE_NUM)\nreturn;\nlimits the value of port less than DSAF_GE_NUM (i.e., 8).\nHowever, if the value of port is 6 or 7, an array overflow could occur:\nport_rst_off = dsaf_dev-\u003emac_cb[port]-\u003eport_rst_off;\nbecause the length of dsaf_dev-\u003emac_cb is DSAF_MAX_PORT_NUM (i.e., 6).\nTo fix this possible array overflow, we first check port and if it is\ngreater than or equal to DSAF_MAX_PORT_NUM, the function returns.\n\nCVE-2021-47579:\nIn the Linux kernel, the following vulnerability has been resolved:\novl: fix warning in ovl_create_real()\nSyzbot triggered the following warning in ovl_workdir_create() -\u003e\novl_create_real():\nif (!err \u0026\u0026 WARN_ON(!newdentry-\u003ed_inode)) {\nThe reason is that the cgroup2 filesystem returns from mkdir without\ninstantiating the new dentry.\nWeird filesystems such as this will be rejected by overlayfs at a later\nstage during setup, but to prevent such a warning, call ovl_mkdir_real()\ndirectly from ovl_workdir_create() and reject this case early.\n\nCVE-2021-47624:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sunrpc: fix reference count leaks in rpc_sysfs_xprt_state_change\nThe refcount leak issues take place in an error handling path. When the\n3rd argument buf doesn't match with \"offline\", \"online\" or \"remove\", the\nfunction simply returns -EINVAL and forgets to decrease the reference\ncount of a rpc_xprt object and a rpc_xprt_switch object increased by\nrpc_sysfs_xprt_kobj_get_xprt() and\nrpc_sysfs_xprt_kobj_get_xprt_switch(), causing reference count leaks of\nboth unused objects.\nFix this issue by jumping to the error handling path labelled with\nout_put when buf matches none of \"offline\", \"online\" or \"remove\".\n\nCVE-2022-48632:\nIn the Linux kernel, the following vulnerability has been resolved:\ni2c: mlxbf: prevent stack overflow in mlxbf_i2c_smbus_start_transaction()\nmemcpy() is called in a loop while 'operation-\u003elength' upper bound\nis not checked and 'data_idx' also increments.\n\nCVE-2022-48743:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: amd-xgbe: Fix skb data length underflow\nThere will be BUG_ON() triggered in include/linux/skbuff.h leading to\nintermittent kernel panic, when the skb length underflow is detected.\nFix this by dropping the packet if such length underflows are seen\nbecause of inconsistencies in the hardware descriptors.\n\nCVE-2022-48747:\nIn the Linux kernel, the following vulnerability has been resolved:\nblock: Fix wrong offset in bio_truncate()\nbio_truncate() clears the buffer outside of last block of bdev, however\ncurrent bio_truncate() is using the wrong offset of page. So it can\nreturn the uninitialized data.\nThis happened when both of truncated/corrupted FS and userspace (via\nbdev) are trying to read the last of bdev.\n\nCVE-2022-48757:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: fix information leakage in /proc/net/ptype\nIn one net namespace, after creating a packet socket without binding\nit to a device, users in other net namespaces can observe the new\n`packet_type` added by this packet socket by reading `/proc/net/ptype`\nfile. This is minor information leakage as packet socket is\nnamespace aware.\nAdd a net pointer in `packet_type` to keep the net namespace of\nof corresponding packet socket. In `ptype_seq_show`, this net pointer\nmust be checked when it is not NULL.\n\nCVE-2023-28746:\nInformation exposure through microarchitectural state after transient execution from some register files for some Intel(R) Atom(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.\n\nCVE-2023-52451:\nIn the Linux kernel, the following vulnerability has been resolved:\npowerpc/pseries/memhp: Fix access beyond end of drmem array\ndlpar_memory_remove_by_index() may access beyond the bounds of the\ndrmem lmb array when the LMB lookup fails to match an entry with the\ngiven DRC index. When the search fails, the cursor is left pointing to\n\u0026drmem_info-\u003elmbs[drmem_info-\u003en_lmbs], which is one element past the\nlast valid entry in the array. The debug message at the end of the\nfunction then dereferences this pointer:\npr_debug(\"Failed to hot-remove memory at %llx\\n\",\nlmb-\u003ebase_addr);\nThis was found by inspection and confirmed with KASAN:\npseries-hotplug-mem: Attempting to hot-remove LMB, drc index 1234\n==================================================================\nBUG: KASAN: slab-out-of-bounds in dlpar_memory+0x298/0x1658\nRead of size 8 at addr c000000364e97fd0 by task bash/949\ndump_stack_lvl+0xa4/0xfc (unreliable)\nprint_report+0x214/0x63c\nkasan_report+0x140/0x2e0\n__asan_load8+0xa8/0xe0\ndlpar_memory+0x298/0x1658\nhandle_dlpar_errorlog+0x130/0x1d0\ndlpar_store+0x18c/0x3e0\nkobj_attr_store+0x68/0xa0\nsysfs_kf_write+0xc4/0x110\nkernfs_fop_write_iter+0x26c/0x390\nvfs_write+0x2d4/0x4e0\nksys_write+0xac/0x1a0\nsystem_call_exception+0x268/0x530\nsystem_call_vectored_common+0x15c/0x2ec\nAllocated by task 1:\nkasan_save_stack+0x48/0x80\nkasan_set_track+0x34/0x50\nkasan_save_alloc_info+0x34/0x50\n__kasan_kmalloc+0xd0/0x120\n__kmalloc+0x8c/0x320\nkmalloc_array.constprop.0+0x48/0x5c\ndrmem_init+0x2a0/0x41c\ndo_one_initcall+0xe0/0x5c0\nkernel_init_freeable+0x4ec/0x5a0\nkernel_init+0x30/0x1e0\nret_from_kernel_user_thread+0x14/0x1c\nThe buggy address belongs to the object at c000000364e80000\nwhich belongs to the cache kmalloc-128k of size 131072\nThe buggy address is located 0 bytes to the right of\nallocated 98256-byte region [c000000364e80000, c000000364e97fd0)\n==================================================================\npseries-hotplug-mem: Failed to hot-remove memory at 0\nLog failed lookups with a separate message and dereference the\ncursor only when it points to a valid entry.\n\nCVE-2023-52463:\nIn the Linux kernel, the following vulnerability has been resolved:\nefivarfs: force RO when remounting if SetVariable is not supported\nIf SetVariable at runtime is not supported by the firmware we never assign\na callback for that function. At the same time mount the efivarfs as\nRO so no one can call that.  However, we never check the permission flags\nwhen someone remounts the filesystem as RW. As a result this leads to a\ncrash looking like this:\n$ mount -o remount,rw /sys/firmware/efi/efivars\n$ efi-updatevar -f PK.auth PK\n[  303.279166] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\n[  303.280482] Mem abort info:\n[  303.280854]   ESR = 0x0000000086000004\n[  303.281338]   EC = 0x21: IABT (current EL), IL = 32 bits\n[  303.282016]   SET = 0, FnV = 0\n[  303.282414]   EA = 0, S1PTW = 0\n[  303.282821]   FSC = 0x04: level 0 translation fault\n[  303.283771] user pgtable: 4k pages, 48-bit VAs, pgdp=000000004258c000\n[  303.284913] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000\n[  303.286076] Internal error: Oops: 0000000086000004 [#1] PREEMPT SMP\n[  303.286936] Modules linked in: qrtr tpm_tis tpm_tis_core crct10dif_ce arm_smccc_trng rng_core drm fuse ip_tables x_tables ipv6\n[  303.288586] CPU: 1 PID: 755 Comm: efi-updatevar Not tainted 6.3.0-rc1-00108-gc7d0c4695c68 #1\n[  303.289748] Hardware name: Unknown Unknown Product/Unknown Product, BIOS 2023.04-00627-g88336918701d 04/01/2023\n[  303.291150] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  303.292123] pc : 0x0\n[  303.292443] lr : efivar_set_variable_locked+0x74/0xec\n[  303.293156] sp : ffff800008673c10\n[  303.293619] x29: ffff800008673c10 x28: ffff0000037e8000 x27: 0000000000000000\n[  303.294592] x26: 0000000000000800 x25: ffff000002467400 x24: 0000000000000027\n[  303.295572] x23: ffffd49ea9832000 x22: ffff0000020c9800 x21: ffff000002467000\n[  303.296566] x20: 0000000000000001 x19: 00000000000007fc x18: 0000000000000000\n[  303.297531] x17: 0000000000000000 x16: 0000000000000000 x15: 0000aaaac807ab54\n[  303.298495] x14: ed37489f673633c0 x13: 71c45c606de13f80 x12: 47464259e219acf4\n[  303.299453] x11: ffff000002af7b01 x10: 0000000000000003 x9 : 0000000000000002\n[  303.300431] x8 : 0000000000000010 x7 : ffffd49ea8973230 x6 : 0000000000a85201\n[  303.301412] x5 : 0000000000000000 x4 : ffff0000020c9800 x3 : 00000000000007fc\n[  303.302370] x2 : 0000000000000027 x1 : ffff000002467400 x0 : ffff000002467000\n[  303.303341] Call trace:\n[  303.303679]  0x0\n[  303.303938]  efivar_entry_set_get_size+0x98/0x16c\n[  303.304585]  efivarfs_file_write+0xd0/0x1a4\n[  303.305148]  vfs_write+0xc4/0x2e4\n[  303.305601]  ksys_write+0x70/0x104\n[  303.306073]  __arm64_sys_write+0x1c/0x28\n[  303.306622]  invoke_syscall+0x48/0x114\n[  303.307156]  el0_svc_common.constprop.0+0x44/0xec\n[  303.307803]  do_el0_svc+0x38/0x98\n[  303.308268]  el0_svc+0x2c/0x84\n[  303.308702]  el0t_64_sync_handler+0xf4/0x120\n[  303.309293]  el0t_64_sync+0x190/0x194\n[  303.309794] Code: ???????? ???????? ???????? ???????? (????????)\n[  303.310612] ---[ end trace 0000000000000000 ]---\nFix this by adding a .reconfigure() function to the fs operations which\nwe can use to check the requested flags and deny anything that's not RO\nif the firmware doesn't implement SetVariable at runtime.\n\nCVE-2023-52469:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrivers/amd/pm: fix a use-after-free in kv_parse_power_table\nWhen ps allocated by kzalloc equals to NULL, kv_parse_power_table\nfrees adev-\u003epm.dpm.ps that allocated before. However, after the control\nflow goes through the following call chains:\nkv_parse_power_table\n|-\u003e kv_dpm_init\n|-\u003e kv_dpm_sw_init\n|-\u003e kv_dpm_fini\nThe adev-\u003epm.dpm.ps is used in the for loop of kv_dpm_fini after its\nfirst free in kv_parse_power_table and causes a use-after-free bug.\n\nCVE-2023-52471:\nIn the Linux kernel, the following vulnerability has been resolved:\nice: Fix some null pointer dereference issues in ice_ptp.c\ndevm_kasprintf() returns a pointer to dynamically allocated memory\nwhich can be NULL upon failure.\n\nCVE-2023-52486:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm: Don't unref the same fb many times by mistake due to deadlock handling\nIf we get a deadlock after the fb lookup in drm_mode_page_flip_ioctl()\nwe proceed to unref the fb and then retry the whole thing from the top.\nBut we forget to reset the fb pointer back to NULL, and so if we then\nget another error during the retry, before the fb lookup, we proceed\nthe unref the same fb again without having gotten another reference.\nThe end result is that the fb will (eventually) end up being freed\nwhile it's still in use.\nReset fb to NULL once we've unreffed it to avoid doing it again\nuntil we've done another fb lookup.\nThis turned out to be pretty easy to hit on a DG2 when doing async\nflips (and CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y). The first symptom I\nsaw that drm_closefb() simply got stuck in a busy loop while walking\nthe framebuffer list. Fortunately I was able to convince it to oops\ninstead, and from there it was easier to track down the culprit.\n\nCVE-2023-52530:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: mac80211: fix potential key use-after-free\nWhen ieee80211_key_link() is called by ieee80211_gtk_rekey_add()\nbut returns 0 due to KRACK protection (identical key reinstall),\nieee80211_gtk_rekey_add() will still return a pointer into the\nkey, in a potential use-after-free. This normally doesn't happen\nsince it's only called by iwlwifi in case of WoWLAN rekey offload\nwhich has its own KRACK protection, but still better to fix, do\nthat by returning an error code and converting that to success on\nthe cfg80211 boundary only, leaving the error for bad callers of\nieee80211_gtk_rekey_add().\n\nCVE-2023-52619:\nIn the Linux kernel, the following vulnerability has been resolved:\npstore/ram: Fix crash when setting number of cpus to an odd number\nWhen the number of cpu cores is adjusted to 7 or other odd numbers,\nthe zone size will become an odd number.\nThe address of the zone will become:\naddr of zone0 = BASE\naddr of zone1 = BASE + zone_size\naddr of zone2 = BASE + zone_size*2\n...\nThe address of zone1/3/5/7 will be mapped to non-alignment va.\nEventually crashes will occur when accessing these va.\nSo, use ALIGN_DOWN() to make sure the zone size is even\nto avoid this bug.\n\nCVE-2023-52622:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: avoid online resizing failures due to oversized flex bg\nWhen we online resize an ext4 filesystem with a oversized flexbg_size,\nmkfs.ext4 -F -G 67108864 $dev -b 4096 100M\nmount $dev $dir\nresize2fs $dev 16G\nthe following WARN_ON is triggered:\n==================================================================\nWARNING: CPU: 0 PID: 427 at mm/page_alloc.c:4402 __alloc_pages+0x411/0x550\nModules linked in: sg(E)\nCPU: 0 PID: 427 Comm: resize2fs Tainted: G  E  6.6.0-rc5+ #314\nRIP: 0010:__alloc_pages+0x411/0x550\nCall Trace:\n\u003cTASK\u003e\n__kmalloc_large_node+0xa2/0x200\n__kmalloc+0x16e/0x290\next4_resize_fs+0x481/0xd80\n__ext4_ioctl+0x1616/0x1d90\next4_ioctl+0x12/0x20\n__x64_sys_ioctl+0xf0/0x150\ndo_syscall_64+0x3b/0x90\n==================================================================\nThis is because flexbg_size is too large and the size of the new_group_data\narray to be allocated exceeds MAX_ORDER. Currently, the minimum value of\nMAX_ORDER is 8, the minimum value of PAGE_SIZE is 4096, the corresponding\nmaximum number of groups that can be allocated is:\n(PAGE_SIZE \u003c\u003c MAX_ORDER) / sizeof(struct ext4_new_group_data) ≈ 21845\nAnd the value that is down-aligned to the power of 2 is 16384. Therefore,\nthis value is defined as MAX_RESIZE_BG, and the number of groups added\neach time does not exceed this value during resizing, and is added multiple\ntimes to complete the online resizing. The difference is that the metadata\nin a flex_bg may be more dispersed.\n\nCVE-2023-52623:\nIn the Linux kernel, the following vulnerability has been resolved:\nSUNRPC: Fix a suspicious RCU usage warning\nI received the following warning while running cthon against an ontap\nserver running pNFS:\n[   57.202521] =============================\n[   57.202522] WARNING: suspicious RCU usage\n[   57.202523] 6.7.0-rc3-g2cc14f52aeb7 #41492 Not tainted\n[   57.202525] -----------------------------\n[   57.202525] net/sunrpc/xprtmultipath.c:349 RCU-list traversed in non-reader section!!\n[   57.202527]\nother info that might help us debug this:\n[   57.202528]\nrcu_scheduler_active = 2, debug_locks = 1\n[   57.202529] no locks held by test5/3567.\n[   57.202530]\nstack backtrace:\n[   57.202532] CPU: 0 PID: 3567 Comm: test5 Not tainted 6.7.0-rc3-g2cc14f52aeb7 #41492 5b09971b4965c0aceba19f3eea324a4a806e227e\n[   57.202534] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 2/2/2022\n[   57.202536] Call Trace:\n[   57.202537]  \u003cTASK\u003e\n[   57.202540]  dump_stack_lvl+0x77/0xb0\n[   57.202551]  lockdep_rcu_suspicious+0x154/0x1a0\n[   57.202556]  rpc_xprt_switch_has_addr+0x17c/0x190 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6]\n[   57.202596]  rpc_clnt_setup_test_and_add_xprt+0x50/0x180 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6]\n[   57.202621]  ? rpc_clnt_add_xprt+0x254/0x300 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6]\n[   57.202646]  rpc_clnt_add_xprt+0x27a/0x300 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6]\n[   57.202671]  ? __pfx_rpc_clnt_setup_test_and_add_xprt+0x10/0x10 [sunrpc ebe02571b9a8ceebf7d98e71675af20c19bdb1f6]\n[   57.202696]  nfs4_pnfs_ds_connect+0x345/0x760 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9]\n[   57.202728]  ? __pfx_nfs4_test_session_trunk+0x10/0x10 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9]\n[   57.202754]  nfs4_fl_prepare_ds+0x75/0xc0 [nfs_layout_nfsv41_files e3a4187f18ae8a27b630f9feae6831b584a9360a]\n[   57.202760]  filelayout_write_pagelist+0x4a/0x200 [nfs_layout_nfsv41_files e3a4187f18ae8a27b630f9feae6831b584a9360a]\n[   57.202765]  pnfs_generic_pg_writepages+0xbe/0x230 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9]\n[   57.202788]  __nfs_pageio_add_request+0x3fd/0x520 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202813]  nfs_pageio_add_request+0x18b/0x390 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202831]  nfs_do_writepage+0x116/0x1e0 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202849]  nfs_writepages_callback+0x13/0x30 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202866]  write_cache_pages+0x265/0x450\n[   57.202870]  ? __pfx_nfs_writepages_callback+0x10/0x10 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202891]  nfs_writepages+0x141/0x230 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202913]  do_writepages+0xd2/0x230\n[   57.202917]  ? filemap_fdatawrite_wbc+0x5c/0x80\n[   57.202921]  filemap_fdatawrite_wbc+0x67/0x80\n[   57.202924]  filemap_write_and_wait_range+0xd9/0x170\n[   57.202930]  nfs_wb_all+0x49/0x180 [nfs 6c976fa593a7c2976f5a0aeb4965514a828e6902]\n[   57.202947]  nfs4_file_flush+0x72/0xb0 [nfsv4 c716d88496ded0ea6d289bbea684fa996f9b57a9]\n[   57.202969]  __se_sys_close+0x46/0xd0\n[   57.202972]  do_syscall_64+0x68/0x100\n[   57.202975]  ? do_syscall_64+0x77/0x100\n[   57.202976]  ? do_syscall_64+0x77/0x100\n[   57.202979]  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n[   57.202982] RIP: 0033:0x7fe2b12e4a94\n[   57.202985] Code: 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 80 3d d5 18 0e 00 00 74 13 b8 03 00 00 00 0f 05 \u003c48\u003e 3d 00 f0 ff ff 77 44 c3 0f 1f 00 48 83 ec 18 89 7c 24 0c e8 c3\n[   57.202987] RSP: 002b:00007ffe857ddb38 EFLAGS: 00000202 ORIG_RAX: 0000000000000003\n[   57.202989] RAX: ffffffffffffffda RBX: 00007ffe857dfd68 RCX: 00007fe2b12e4a94\n[   57.202991] RDX: 0000000000002000 RSI: 00007ffe857ddc40 RDI: 0000000000000003\n[   57.202992] RBP: 00007ffe857dfc50 R08: 7fffffffffffffff R09: 0000000065650f49\n[   57.202993] R10: 00007f\n---truncated---\n\nCVE-2023-52648:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Unmap the surface before resetting it on a plane state\nSwitch to a new plane state requires unreferencing of all held surfaces.\nIn the work required for mob cursors the mapped surfaces started being\ncached but the variable indicating whether the surface is currently\nmapped was not being reset. This leads to crashes as the duplicated\nstate, incorrectly, indicates the that surface is mapped even when\nno surface is present. That's because after unreferencing the surface\nit's perfectly possible for the plane to be backed by a bo instead of a\nsurface.\nReset the surface mapped flag when unreferencing the plane state surface\nto fix null derefs in cleanup. Fixes crashes in KDE KWin 6.0 on Wayland:\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 4 PID: 2533 Comm: kwin_wayland Not tainted 6.7.0-rc3-vmwgfx #2\nHardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\nRIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]\nCode: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 \u003c48\u003e 8b 78 28 e8 e3 f\u003e\nRSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600\nRBP: ffff969d4143dc50 R08: 0000000000000000 R09: ffffb6b98216f920\nR10: 0000000000000003 R11: ffff969e7feb3b10 R12: 0000000000000000\nR13: 0000000000000000 R14: 000000000000027b R15: ffff969d49c9fc00\nFS:  00007f1e8f1b4180(0000) GS:ffff969e75f00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000028 CR3: 0000000104006004 CR4: 00000000003706f0\nCall Trace:\n\u003cTASK\u003e\n? __die+0x23/0x70\n? page_fault_oops+0x171/0x4e0\n? exc_page_fault+0x7f/0x180\n? asm_exc_page_fault+0x26/0x30\n? vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]\ndrm_atomic_helper_cleanup_planes+0x9b/0xc0\ncommit_tail+0xd1/0x130\ndrm_atomic_helper_commit+0x11a/0x140\ndrm_atomic_commit+0x97/0xd0\n? __pfx___drm_printfn_info+0x10/0x10\ndrm_atomic_helper_update_plane+0xf5/0x160\ndrm_mode_cursor_universal+0x10e/0x270\ndrm_mode_cursor_common+0x102/0x230\n? __pfx_drm_mode_cursor2_ioctl+0x10/0x10\ndrm_ioctl_kernel+0xb2/0x110\ndrm_ioctl+0x26d/0x4b0\n? __pfx_drm_mode_cursor2_ioctl+0x10/0x10\n? __pfx_drm_ioctl+0x10/0x10\nvmw_generic_ioctl+0xa4/0x110 [vmwgfx]\n__x64_sys_ioctl+0x94/0xd0\ndo_syscall_64+0x61/0xe0\n? __x64_sys_ioctl+0xaf/0xd0\n? syscall_exit_to_user_mode+0x2b/0x40\n? do_syscall_64+0x70/0xe0\n? __x64_sys_ioctl+0xaf/0xd0\n? syscall_exit_to_user_mode+0x2b/0x40\n? do_syscall_64+0x70/0xe0\n? exc_page_fault+0x7f/0x180\nentry_SYSCALL_64_after_hwframe+0x6e/0x76\nRIP: 0033:0x7f1e93f279ed\nCode: 04 25 28 00 00 00 48 89 45 c8 31 c0 48 8d 45 10 c7 45 b0 10 00 00 00 48 89 45 b8 48 8d 45 d0 48 89 45 c0 b8 10 00 00 00 0f 05 \u003c89\u003e c2 3d 00 f0 ff f\u003e\nRSP: 002b:00007ffca0faf600 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 000055db876ed2c0 RCX: 00007f1e93f279ed\nRDX: 00007ffca0faf6c0 RSI: 00000000c02464bb RDI: 0000000000000015\nRBP: 00007ffca0faf650 R08: 000055db87184010 R09: 0000000000000007\nR10: 000055db886471a0 R11: 0000000000000246 R12: 00007ffca0faf6c0\nR13: 00000000c02464bb R14: 0000000000000015 R15: 00007ffca0faf790\n\u003c/TASK\u003e\nModules linked in: snd_seq_dummy snd_hrtimer nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_ine\u003e\nCR2: 0000000000000028\n---[ end trace 0000000000000000 ]---\nRIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]\nCode: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 \u003c48\u003e 8b 78 28 e8 e3 f\u003e\nRSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027\nRDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600\nRBP: ffff969d4143\n---truncated---\n\nCVE-2023-52653:\nIn the Linux kernel, the following vulnerability has been resolved:\nSUNRPC: fix a memleak in gss_import_v2_context\nThe ctx-\u003emech_used.data allocated by kmemdup is not freed in neither\ngss_import_v2_context nor it only caller gss_krb5_import_sec_context,\nwhich frees ctx on error.\nThus, this patch reform the last call of gss_import_v2_context to the\ngss_krb5_import_ctx_v2, preventing the memleak while keepping the return\nformation.\n\nCVE-2023-52658:\nIn the Linux kernel, the following vulnerability has been resolved:\nRevert \"net/mlx5: Block entering switchdev mode with ns inconsistency\"\nThis reverts commit 662404b24a4c4d839839ed25e3097571f5938b9b.\nThe revert is required due to the suspicion it is not good for anything\nand cause crash.\n\nCVE-2023-52662:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: fix a memleak in vmw_gmrid_man_get_node\nWhen ida_alloc_max fails, resources allocated before should be freed,\nincluding *res allocated by kmalloc and ttm_resource_init.\n\nCVE-2023-52679:\nIn the Linux kernel, the following vulnerability has been resolved:\nof: Fix double free in of_parse_phandle_with_args_map\nIn of_parse_phandle_with_args_map() the inner loop that\niterates through the map entries calls of_node_put(new)\nto free the reference acquired by the previous iteration\nof the inner loop. This assumes that the value of \"new\" is\nNULL on the first iteration of the inner loop.\nMake sure that this is true in all iterations of the outer\nloop by setting \"new\" to NULL after its value is assigned to \"cur\".\nExtend the unittest to detect the double free and add an additional\ntest case that actually triggers this path.\n\nCVE-2023-52707:\nIn the Linux kernel, the following vulnerability has been resolved:\nsched/psi: Fix use-after-free in ep_remove_wait_queue()\nIf a non-root cgroup gets removed when there is a thread that registered\ntrigger and is polling on a pressure file within the cgroup, the polling\nwaitqueue gets freed in the following path:\ndo_rmdir\ncgroup_rmdir\nkernfs_drain_open_files\ncgroup_file_release\ncgroup_pressure_release\npsi_trigger_destroy\nHowever, the polling thread still has a reference to the pressure file and\nwill access the freed waitqueue when the file is closed or upon exit:\nfput\nep_eventpoll_release\nep_free\nep_remove_wait_queue\nremove_wait_queue\nThis results in use-after-free as pasted below.\nThe fundamental problem here is that cgroup_file_release() (and\nconsequently waitqueue's lifetime) is not tied to the file's real lifetime.\nUsing wake_up_pollfree() here might be less than ideal, but it is in line\nwith the comment at commit 42288cb44c4b (\"wait: add wake_up_pollfree()\")\nsince the waitqueue's lifetime is not tied to file's one and can be\nconsidered as another special case. While this would be fixable by somehow\nmaking cgroup_file_release() be tied to the fput(), it would require\nsizable refactoring at cgroups or higher layer which might be more\njustifiable if we identify more cases like this.\nBUG: KASAN: use-after-free in _raw_spin_lock_irqsave+0x60/0xc0\nWrite of size 4 at addr ffff88810e625328 by task a.out/4404\nCPU: 19 PID: 4404 Comm: a.out Not tainted 6.2.0-rc6 #38\nHardware name: Amazon EC2 c5a.8xlarge/, BIOS 1.0 10/16/2017\nCall Trace:\n\u003cTASK\u003e\ndump_stack_lvl+0x73/0xa0\nprint_report+0x16c/0x4e0\nkasan_report+0xc3/0xf0\nkasan_check_range+0x2d2/0x310\n_raw_spin_lock_irqsave+0x60/0xc0\nremove_wait_queue+0x1a/0xa0\nep_free+0x12c/0x170\nep_eventpoll_release+0x26/0x30\n__fput+0x202/0x400\ntask_work_run+0x11d/0x170\ndo_exit+0x495/0x1130\ndo_group_exit+0x100/0x100\nget_signal+0xd67/0xde0\narch_do_signal_or_restart+0x2a/0x2b0\nexit_to_user_mode_prepare+0x94/0x100\nsyscall_exit_to_user_mode+0x20/0x40\ndo_syscall_64+0x52/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\u003c/TASK\u003e\nAllocated by task 4404:\nkasan_set_track+0x3d/0x60\n__kasan_kmalloc+0x85/0x90\npsi_trigger_create+0x113/0x3e0\npressure_write+0x146/0x2e0\ncgroup_file_write+0x11c/0x250\nkernfs_fop_write_iter+0x186/0x220\nvfs_write+0x3d8/0x5c0\nksys_write+0x90/0x110\ndo_syscall_64+0x43/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\nFreed by task 4407:\nkasan_set_track+0x3d/0x60\nkasan_save_free_info+0x27/0x40\n____kasan_slab_free+0x11d/0x170\nslab_free_freelist_hook+0x87/0x150\n__kmem_cache_free+0xcb/0x180\npsi_trigger_destroy+0x2e8/0x310\ncgroup_file_release+0x4f/0xb0\nkernfs_drain_open_files+0x165/0x1f0\nkernfs_drain+0x162/0x1a0\n__kernfs_remove+0x1fb/0x310\nkernfs_remove_by_name_ns+0x95/0xe0\ncgroup_addrm_files+0x67f/0x700\ncgroup_destroy_locked+0x283/0x3c0\ncgroup_rmdir+0x29/0x100\nkernfs_iop_rmdir+0xd1/0x140\nvfs_rmdir+0xfe/0x240\ndo_rmdir+0x13d/0x280\n__x64_sys_rmdir+0x2c/0x30\ndo_syscall_64+0x43/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nCVE-2023-52730:\nIn the Linux kernel, the following vulnerability has been resolved:\nmmc: sdio: fix possible resource leaks in some error paths\nIf sdio_add_func() or sdio_init_func() fails, sdio_remove_func() can\nnot release the resources, because the sdio function is not presented\nin these two cases, it won't call of_node_put() or put_device().\nTo fix these leaks, make sdio_func_present() only control whether\ndevice_del() needs to be called or not, then always call of_node_put()\nand put_device().\nIn error case in sdio_init_func(), the reference of 'card-\u003edev' is\nnot get, to avoid redundant put in sdio_free_func_cis(), move the\nget_device() to sdio_alloc_func() and put_device() to sdio_release_func(),\nit can keep the get/put function be balanced.\nWithout this patch, while doing fault inject test, it can get the\nfollowing leak reports, after this fix, the leak is gone.\nunreferenced object 0xffff888112514000 (size 2048):\ncomm \"kworker/3:2\", pid 65, jiffies 4294741614 (age 124.774s)\nhex dump (first 32 bytes):\n00 e0 6f 12 81 88 ff ff 60 58 8d 06 81 88 ff ff  ..o.....`X......\n10 40 51 12 81 88 ff ff 10 40 51 12 81 88 ff ff  .@Q......@Q.....\nbacktrace:\n[\u003c000000009e5931da\u003e] kmalloc_trace+0x21/0x110\n[\u003c000000002f839ccb\u003e] mmc_alloc_card+0x38/0xb0 [mmc_core]\n[\u003c0000000004adcbf6\u003e] mmc_sdio_init_card+0xde/0x170 [mmc_core]\n[\u003c000000007538fea0\u003e] mmc_attach_sdio+0xcb/0x1b0 [mmc_core]\n[\u003c00000000d4fdeba7\u003e] mmc_rescan+0x54a/0x640 [mmc_core]\nunreferenced object 0xffff888112511000 (size 2048):\ncomm \"kworker/3:2\", pid 65, jiffies 4294741623 (age 124.766s)\nhex dump (first 32 bytes):\n00 40 51 12 81 88 ff ff e0 58 8d 06 81 88 ff ff  .@Q......X......\n10 10 51 12 81 88 ff ff 10 10 51 12 81 88 ff ff  ..Q.......Q.....\nbacktrace:\n[\u003c000000009e5931da\u003e] kmalloc_trace+0x21/0x110\n[\u003c00000000fcbe706c\u003e] sdio_alloc_func+0x35/0x100 [mmc_core]\n[\u003c00000000c68f4b50\u003e] mmc_attach_sdio.cold.18+0xb1/0x395 [mmc_core]\n[\u003c00000000d4fdeba7\u003e] mmc_rescan+0x54a/0x640 [mmc_core]\n\nCVE-2023-52756:\nThis CVE ID has been rejected or withdrawn by its CVE Numbering Authority for the following reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.\n\nCVE-2023-52762:\nIn the Linux kernel, the following vulnerability has been resolved:\nvirtio-blk: fix implicit overflow on virtio_max_dma_size\nThe following codes have an implicit conversion from size_t to u32:\n(u32)max_size = (size_t)virtio_max_dma_size(vdev);\nThis may lead overflow, Ex (size_t)4G -\u003e (u32)0. Once\nvirtio_max_dma_size() has a larger size than U32_MAX, use U32_MAX\ninstead.\n\nCVE-2023-52764:\nIn the Linux kernel, the following vulnerability has been resolved:\nmedia: gspca: cpia1: shift-out-of-bounds in set_flicker\nSyzkaller reported the following issue:\nUBSAN: shift-out-of-bounds in drivers/media/usb/gspca/cpia1.c:1031:27\nshift exponent 245 is too large for 32-bit type 'int'\nWhen the value of the variable \"sd-\u003eparams.exposure.gain\" exceeds the\nnumber of bits in an integer, a shift-out-of-bounds error is reported. It\nis triggered because the variable \"currentexp\" cannot be left-shifted by\nmore than the number of bits in an integer. In order to avoid invalid\nrange during left-shift, the conditional expression is added.\n\nCVE-2023-52775:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/smc: avoid data corruption caused by decline\nWe found a data corruption issue during testing of SMC-R on Redis\napplications.\nThe benchmark has a low probability of reporting a strange error as\nshown below.\n\"Error: Protocol error, got \"\\xe2\" as reply type byte\"\nFinally, we found that the retrieved error data was as follows:\n0xE2 0xD4 0xC3 0xD9 0x04 0x00 0x2C 0x20 0xA6 0x56 0x00 0x16 0x3E 0x0C\n0xCB 0x04 0x02 0x01 0x00 0x00 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xE2\nIt is quite obvious that this is a SMC DECLINE message, which means that\nthe applications received SMC protocol message.\nWe found that this was caused by the following situations:\nclient                  server\n¦  clc proposal\n-------------\u003e\n¦  clc accept\n\u003c-------------\n¦  clc confirm\n-------------\u003e\nwait llc confirm\nsend llc confirm\n¦failed llc confirm\n¦   x------\n(after 2s)timeout\nwait llc confirm rsp\nwait decline\n(after 1s) timeout\n(after 2s) timeout\n¦   decline\n--------------\u003e\n¦   decline\n\u003c--------------\nAs a result, a decline message was sent in the implementation, and this\nmessage was read from TCP by the already-fallback connection.\nThis patch double the client timeout as 2x of the server value,\nWith this simple change, the Decline messages should never cross or\ncollide (during Confirm link timeout).\nThis issue requires an immediate solution, since the protocol updates\ninvolve a more long-term solution.\n\nCVE-2023-52777:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: ath11k: fix gtk offload status event locking\nThe ath11k active pdevs are protected by RCU but the gtk offload status\nevent handling code calling ath11k_mac_get_arvif_by_vdev_id() was not\nmarked as a read-side critical section.\nMark the code in question as an RCU read-side critical section to avoid\nany potential use-after-free issues.\nCompile tested only.\n\nCVE-2023-52784:\nIn the Linux kernel, the following vulnerability has been resolved:\nbonding: stop the device in bond_setup_by_slave()\nCommit 9eed321cde22 (\"net: lapbether: only support ethernet devices\")\nhas been able to keep syzbot away from net/lapb, until today.\nIn the following splat [1], the issue is that a lapbether device has\nbeen created on a bonding device without members. Then adding a non\nARPHRD_ETHER member forced the bonding master to change its type.\nThe fix is to make sure we call dev_close() in bond_setup_by_slave()\nso that the potential linked lapbether devices (or any other devices\nhaving assumptions on the physical device) are removed.\nA similar bug has been addressed in commit 40baec225765\n(\"bonding: fix panic on non-ARPHRD_ETHER enslave failure\")\n[1]\nskbuff: skb_under_panic: text:ffff800089508810 len:44 put:40 head:ffff0000c78e7c00 data:ffff0000c78e7bea tail:0x16 end:0x140 dev:bond0\nkernel BUG at net/core/skbuff.c:192 !\nInternal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\nModules linked in:\nCPU: 0 PID: 6007 Comm: syz-executor383 Not tainted 6.6.0-rc3-syzkaller-gbf6547d8715b #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : skb_panic net/core/skbuff.c:188 [inline]\npc : skb_under_panic+0x13c/0x140 net/core/skbuff.c:202\nlr : skb_panic net/core/skbuff.c:188 [inline]\nlr : skb_under_panic+0x13c/0x140 net/core/skbuff.c:202\nsp : ffff800096a06aa0\nx29: ffff800096a06ab0 x28: ffff800096a06ba0 x27: dfff800000000000\nx26: ffff0000ce9b9b50 x25: 0000000000000016 x24: ffff0000c78e7bea\nx23: ffff0000c78e7c00 x22: 000000000000002c x21: 0000000000000140\nx20: 0000000000000028 x19: ffff800089508810 x18: ffff800096a06100\nx17: 0000000000000000 x16: ffff80008a629a3c x15: 0000000000000001\nx14: 1fffe00036837a32 x13: 0000000000000000 x12: 0000000000000000\nx11: 0000000000000201 x10: 0000000000000000 x9 : cb50b496c519aa00\nx8 : cb50b496c519aa00 x7 : 0000000000000001 x6 : 0000000000000001\nx5 : ffff800096a063b8 x4 : ffff80008e280f80 x3 : ffff8000805ad11c\nx2 : 0000000000000001 x1 : 0000000100000201 x0 : 0000000000000086\nCall trace:\nskb_panic net/core/skbuff.c:188 [inline]\nskb_under_panic+0x13c/0x140 net/core/skbuff.c:202\nskb_push+0xf0/0x108 net/core/skbuff.c:2446\nip6gre_header+0xbc/0x738 net/ipv6/ip6_gre.c:1384\ndev_hard_header include/linux/netdevice.h:3136 [inline]\nlapbeth_data_transmit+0x1c4/0x298 drivers/net/wan/lapbether.c:257\nlapb_data_transmit+0x8c/0xb0 net/lapb/lapb_iface.c:447\nlapb_transmit_buffer+0x178/0x204 net/lapb/lapb_out.c:149\nlapb_send_control+0x220/0x320 net/lapb/lapb_subr.c:251\n__lapb_disconnect_request+0x9c/0x17c net/lapb/lapb_iface.c:326\nlapb_device_event+0x288/0x4e0 net/lapb/lapb_iface.c:492\nnotifier_call_chain+0x1a4/0x510 kernel/notifier.c:93\nraw_notifier_call_chain+0x3c/0x50 kernel/notifier.c:461\ncall_netdevice_notifiers_info net/core/dev.c:1970 [inline]\ncall_netdevice_notifiers_extack net/core/dev.c:2008 [inline]\ncall_netdevice_notifiers net/core/dev.c:2022 [inline]\n__dev_close_many+0x1b8/0x3c4 net/core/dev.c:1508\ndev_close_many+0x1e0/0x470 net/core/dev.c:1559\ndev_close+0x174/0x250 net/core/dev.c:1585\nlapbeth_device_event+0x2e4/0x958 drivers/net/wan/lapbether.c:466\nnotifier_call_chain+0x1a4/0x510 kernel/notifier.c:93\nraw_notifier_call_chain+0x3c/0x50 kernel/notifier.c:461\ncall_netdevice_notifiers_info net/core/dev.c:1970 [inline]\ncall_netdevice_notifiers_extack net/core/dev.c:2008 [inline]\ncall_netdevice_notifiers net/core/dev.c:2022 [inline]\n__dev_close_many+0x1b8/0x3c4 net/core/dev.c:1508\ndev_close_many+0x1e0/0x470 net/core/dev.c:1559\ndev_close+0x174/0x250 net/core/dev.c:1585\nbond_enslave+0x2298/0x30cc drivers/net/bonding/bond_main.c:2332\nbond_do_ioctl+0x268/0xc64 drivers/net/bonding/bond_main.c:4539\ndev_ifsioc+0x754/0x9ac\ndev_ioctl+0x4d8/0xd34 net/core/dev_ioctl.c:786\nsock_do_ioctl+0x1d4/0x2d0 net/socket.c:1217\nsock_ioctl+0x4e8/0x834 net/socket.c:1322\nvfs_ioctl fs/ioctl.c:51 [inline]\n__do_\n---truncated---\n\nCVE-2023-52791:\nIn the Linux kernel, the following vulnerability has been resolved:\ni2c: core: Run atomic i2c xfer when !preemptible\nSince bae1d3a05a8b, i2c transfers are non-atomic if preemption is\ndisabled. However, non-atomic i2c transfers require preemption (e.g. in\nwait_for_completion() while waiting for the DMA).\npanic() calls preempt_disable_notrace() before calling\nemergency_restart(). Therefore, if an i2c device is used for the\nrestart, the xfer should be atomic. This avoids warnings like:\n[   12.667612] WARNING: CPU: 1 PID: 1 at kernel/rcu/tree_plugin.h:318 rcu_note_context_switch+0x33c/0x6b0\n[   12.676926] Voluntary context switch within RCU read-side critical section!\n...\n[   12.742376]  schedule_timeout from wait_for_completion_timeout+0x90/0x114\n[   12.749179]  wait_for_completion_timeout from tegra_i2c_wait_completion+0x40/0x70\n...\n[   12.994527]  atomic_notifier_call_chain from machine_restart+0x34/0x58\n[   13.001050]  machine_restart from panic+0x2a8/0x32c\nUse !preemptible() instead, which is basically the same check as\npre-v5.2.\n\nCVE-2023-52796:\nIn the Linux kernel, the following vulnerability has been resolved:\nipvlan: add ipvlan_route_v6_outbound() helper\nInspired by syzbot reports using a stack of multiple ipvlan devices.\nReduce stack size needed in ipvlan_process_v6_outbound() by moving\nthe flowi6 struct used for the route lookup in an non inlined\nhelper. ipvlan_route_v6_outbound() needs 120 bytes on the stack,\nimmediately reclaimed.\nAlso make sure ipvlan_process_v4_outbound() is not inlined.\nWe might also have to lower MAX_NEST_DEV, because only syzbot uses\nsetups with more than four stacked devices.\nBUG: TASK stack guard page was hit at ffffc9000e803ff8 (stack is ffffc9000e804000..ffffc9000e808000)\nstack guard page: 0000 [#1] SMP KASAN\nCPU: 0 PID: 13442 Comm: syz-executor.4 Not tainted 6.1.52-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/09/2023\nRIP: 0010:kasan_check_range+0x4/0x2a0 mm/kasan/generic.c:188\nCode: 48 01 c6 48 89 c7 e8 db 4e c1 03 31 c0 5d c3 cc 0f 0b eb 02 0f 0b b8 ea ff ff ff 5d c3 cc 00 00 cc cc 00 00 cc cc 55 48 89 e5 \u003c41\u003e 57 41 56 41 55 41 54 53 b0 01 48 85 f6 0f 84 a4 01 00 00 48 89\nRSP: 0018:ffffc9000e804000 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817e5bf2\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffff887c6568\nRBP: ffffc9000e804000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: dffffc0000000001 R12: 1ffff92001d0080c\nR13: dffffc0000000000 R14: ffffffff87e6b100 R15: 0000000000000000\nFS: 00007fd0c55826c0(0000) GS:ffff8881f6800000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000e803ff8 CR3: 0000000170ef7000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003c#DF\u003e\n\u003c/#DF\u003e\n\u003cTASK\u003e\n[\u003cffffffff81f281d1\u003e] __kasan_check_read+0x11/0x20 mm/kasan/shadow.c:31\n[\u003cffffffff817e5bf2\u003e] instrument_atomic_read include/linux/instrumented.h:72 [inline]\n[\u003cffffffff817e5bf2\u003e] _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]\n[\u003cffffffff817e5bf2\u003e] cpumask_test_cpu include/linux/cpumask.h:506 [inline]\n[\u003cffffffff817e5bf2\u003e] cpu_online include/linux/cpumask.h:1092 [inline]\n[\u003cffffffff817e5bf2\u003e] trace_lock_acquire include/trace/events/lock.h:24 [inline]\n[\u003cffffffff817e5bf2\u003e] lock_acquire+0xe2/0x590 kernel/locking/lockdep.c:5632\n[\u003cffffffff8563221e\u003e] rcu_lock_acquire+0x2e/0x40 include/linux/rcupdate.h:306\n[\u003cffffffff8561464d\u003e] rcu_read_lock include/linux/rcupdate.h:747 [inline]\n[\u003cffffffff8561464d\u003e] ip6_pol_route+0x15d/0x1440 net/ipv6/route.c:2221\n[\u003cffffffff85618120\u003e] ip6_pol_route_output+0x50/0x80 net/ipv6/route.c:2606\n[\u003cffffffff856f65b5\u003e] pol_lookup_func include/net/ip6_fib.h:584 [inline]\n[\u003cffffffff856f65b5\u003e] fib6_rule_lookup+0x265/0x620 net/ipv6/fib6_rules.c:116\n[\u003cffffffff85618009\u003e] ip6_route_output_flags_noref+0x2d9/0x3a0 net/ipv6/route.c:2638\n[\u003cffffffff8561821a\u003e] ip6_route_output_flags+0xca/0x340 net/ipv6/route.c:2651\n[\u003cffffffff838bd5a3\u003e] ip6_route_output include/net/ip6_route.h:100 [inline]\n[\u003cffffffff838bd5a3\u003e] ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:473 [inline]\n[\u003cffffffff838bd5a3\u003e] ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:529 [inline]\n[\u003cffffffff838bd5a3\u003e] ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:602 [inline]\n[\u003cffffffff838bd5a3\u003e] ipvlan_queue_xmit+0xc33/0x1be0 drivers/net/ipvlan/ipvlan_core.c:677\n[\u003cffffffff838c2909\u003e] ipvlan_start_xmit+0x49/0x100 drivers/net/ipvlan/ipvlan_main.c:229\n[\u003cffffffff84d03900\u003e] netdev_start_xmit include/linux/netdevice.h:4966 [inline]\n[\u003cffffffff84d03900\u003e] xmit_one net/core/dev.c:3644 [inline]\n[\u003cffffffff84d03900\u003e] dev_hard_start_xmit+0x320/0x980 net/core/dev.c:3660\n[\u003cffffffff84d080e2\u003e] __dev_queue_xmit+0x16b2/0x3370 net/core/dev.c:4324\n[\u003cffffffff855ce4cd\u003e] dev_queue_xmit include/linux/netdevice.h:3067 [inline]\n[\u003cffffffff855ce4cd\u003e] neigh_hh_output include/net/neighbour.h:529 [inline]\n[\u003cf\n---truncated---\n\nCVE-2023-52803:\nIn the Linux kernel, the following vulnerability has been resolved:\nSUNRPC: Fix RPC client cleaned up the freed pipefs dentries\nRPC client pipefs dentries cleanup is in separated rpc_remove_pipedir()\nworkqueue,which takes care about pipefs superblock locking.\nIn some special scenarios, when kernel frees the pipefs sb of the\ncurrent client and immediately alloctes a new pipefs sb,\nrpc_remove_pipedir function would misjudge the existence of pipefs\nsb which is not the one it used to hold. As a result,\nthe rpc_remove_pipedir would clean the released freed pipefs dentries.\nTo fix this issue, rpc_remove_pipedir should check whether the\ncurrent pipefs sb is consistent with the original pipefs sb.\nThis error can be catched by KASAN:\n=========================================================\n[  250.497700] BUG: KASAN: slab-use-after-free in dget_parent+0x195/0x200\n[  250.498315] Read of size 4 at addr ffff88800a2ab804 by task kworker/0:18/106503\n[  250.500549] Workqueue: events rpc_free_client_work\n[  250.501001] Call Trace:\n[  250.502880]  kasan_report+0xb6/0xf0\n[  250.503209]  ? dget_parent+0x195/0x200\n[  250.503561]  dget_parent+0x195/0x200\n[  250.503897]  ? __pfx_rpc_clntdir_depopulate+0x10/0x10\n[  250.504384]  rpc_rmdir_depopulate+0x1b/0x90\n[  250.504781]  rpc_remove_client_dir+0xf5/0x150\n[  250.505195]  rpc_free_client_work+0xe4/0x230\n[  250.505598]  process_one_work+0x8ee/0x13b0\n...\n[   22.039056] Allocated by task 244:\n[   22.039390]  kasan_save_stack+0x22/0x50\n[   22.039758]  kasan_set_track+0x25/0x30\n[   22.040109]  __kasan_slab_alloc+0x59/0x70\n[   22.040487]  kmem_cache_alloc_lru+0xf0/0x240\n[   22.040889]  __d_alloc+0x31/0x8e0\n[   22.041207]  d_alloc+0x44/0x1f0\n[   22.041514]  __rpc_lookup_create_exclusive+0x11c/0x140\n[   22.041987]  rpc_mkdir_populate.constprop.0+0x5f/0x110\n[   22.042459]  rpc_create_client_dir+0x34/0x150\n[   22.042874]  rpc_setup_pipedir_sb+0x102/0x1c0\n[   22.043284]  rpc_client_register+0x136/0x4e0\n[   22.043689]  rpc_new_client+0x911/0x1020\n[   22.044057]  rpc_create_xprt+0xcb/0x370\n[   22.044417]  rpc_create+0x36b/0x6c0\n...\n[   22.049524] Freed by task 0:\n[   22.049803]  kasan_save_stack+0x22/0x50\n[   22.050165]  kasan_set_track+0x25/0x30\n[   22.050520]  kasan_save_free_info+0x2b/0x50\n[   22.050921]  __kasan_slab_free+0x10e/0x1a0\n[   22.051306]  kmem_cache_free+0xa5/0x390\n[   22.051667]  rcu_core+0x62c/0x1930\n[   22.051995]  __do_softirq+0x165/0x52a\n[   22.052347]\n[   22.052503] Last potentially related work creation:\n[   22.052952]  kasan_save_stack+0x22/0x50\n[   22.053313]  __kasan_record_aux_stack+0x8e/0xa0\n[   22.053739]  __call_rcu_common.constprop.0+0x6b/0x8b0\n[   22.054209]  dentry_free+0xb2/0x140\n[   22.054540]  __dentry_kill+0x3be/0x540\n[   22.054900]  shrink_dentry_list+0x199/0x510\n[   22.055293]  shrink_dcache_parent+0x190/0x240\n[   22.055703]  do_one_tree+0x11/0x40\n[   22.056028]  shrink_dcache_for_umount+0x61/0x140\n[   22.056461]  generic_shutdown_super+0x70/0x590\n[   22.056879]  kill_anon_super+0x3a/0x60\n[   22.057234]  rpc_kill_sb+0x121/0x200\n\nCVE-2023-52811:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: ibmvfc: Remove BUG_ON in the case of an empty event pool\nIn practice the driver should never send more commands than are allocated\nto a queue's event pool. In the unlikely event that this happens, the code\nasserts a BUG_ON, and in the case that the kernel is not configured to\ncrash on panic returns a junk event pointer from the empty event list\ncausing things to spiral from there. This BUG_ON is a historical artifact\nof the ibmvfc driver first being upstreamed, and it is well known now that\nthe use of BUG_ON is bad practice except in the most unrecoverable\nscenario. There is nothing about this scenario that prevents the driver\nfrom recovering and carrying on.\nRemove the BUG_ON in question from ibmvfc_get_event() and return a NULL\npointer in the case of an empty event pool. Update all call sites to\nibmvfc_get_event() to check for a NULL pointer and perfrom the appropriate\nfailure or recovery action.\n\nCVE-2023-52832:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: mac80211: don't return unset power in ieee80211_get_tx_power()\nWe can get a UBSAN warning if ieee80211_get_tx_power() returns the\nINT_MIN value mac80211 internally uses for \"unset power level\".\nUBSAN: signed-integer-overflow in net/wireless/nl80211.c:3816:5\n-2147483648 * 100 cannot be represented in type 'int'\nCPU: 0 PID: 20433 Comm: insmod Tainted: G        WC OE\nCall Trace:\ndump_stack+0x74/0x92\nubsan_epilogue+0x9/0x50\nhandle_overflow+0x8d/0xd0\n__ubsan_handle_mul_overflow+0xe/0x10\nnl80211_send_iface+0x688/0x6b0 [cfg80211]\n[...]\ncfg80211_register_wdev+0x78/0xb0 [cfg80211]\ncfg80211_netdev_notifier_call+0x200/0x620 [cfg80211]\n[...]\nieee80211_if_add+0x60e/0x8f0 [mac80211]\nieee80211_register_hw+0xda5/0x1170 [mac80211]\nIn this case, simply return an error instead, to indicate\nthat no data is available.\n\nCVE-2023-52834:\nIn the Linux kernel, the following vulnerability has been resolved:\natl1c: Work around the DMA RX overflow issue\nThis is based on alx driver commit 881d0327db37 (\"net: alx: Work around\nthe DMA RX overflow issue\").\nThe alx and atl1c drivers had RX overflow error which was why a custom\nallocator was created to avoid certain addresses. The simpler workaround\nthen created for alx driver, but not for atl1c due to lack of tester.\nInstead of using a custom allocator, check the allocated skb address and\nuse skb_reserve() to move away from problematic 0x...fc0 address.\nTested on AR8131 on Acer 4540.\n\nCVE-2023-52845:\nIn the Linux kernel, the following vulnerability has been resolved:\ntipc: Change nla_policy for bearer-related names to NLA_NUL_STRING\nsyzbot reported the following uninit-value access issue [1]:\n=====================================================\nBUG: KMSAN: uninit-value in strlen lib/string.c:418 [inline]\nBUG: KMSAN: uninit-value in strstr+0xb8/0x2f0 lib/string.c:756\nstrlen lib/string.c:418 [inline]\nstrstr+0xb8/0x2f0 lib/string.c:756\ntipc_nl_node_reset_link_stats+0x3ea/0xb50 net/tipc/node.c:2595\ngenl_family_rcv_msg_doit net/netlink/genetlink.c:971 [inline]\ngenl_family_rcv_msg net/netlink/genetlink.c:1051 [inline]\ngenl_rcv_msg+0x11ec/0x1290 net/netlink/genetlink.c:1066\nnetlink_rcv_skb+0x371/0x650 net/netlink/af_netlink.c:2545\ngenl_rcv+0x40/0x60 net/netlink/genetlink.c:1075\nnetlink_unicast_kernel net/netlink/af_netlink.c:1342 [inline]\nnetlink_unicast+0xf47/0x1250 net/netlink/af_netlink.c:1368\nnetlink_sendmsg+0x1238/0x13d0 net/netlink/af_netlink.c:1910\nsock_sendmsg_nosec net/socket.c:730 [inline]\nsock_sendmsg net/socket.c:753 [inline]\n____sys_sendmsg+0x9c2/0xd60 net/socket.c:2541\n___sys_sendmsg+0x28d/0x3c0 net/socket.c:2595\n__sys_sendmsg net/socket.c:2624 [inline]\n__do_sys_sendmsg net/socket.c:2633 [inline]\n__se_sys_sendmsg net/socket.c:2631 [inline]\n__x64_sys_sendmsg+0x307/0x490 net/socket.c:2631\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\nUninit was created at:\nslab_post_alloc_hook+0x12f/0xb70 mm/slab.h:767\nslab_alloc_node mm/slub.c:3478 [inline]\nkmem_cache_alloc_node+0x577/0xa80 mm/slub.c:3523\nkmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:559\n__alloc_skb+0x318/0x740 net/core/skbuff.c:650\nalloc_skb include/linux/skbuff.h:1286 [inline]\nnetlink_alloc_large_skb net/netlink/af_netlink.c:1214 [inline]\nnetlink_sendmsg+0xb34/0x13d0 net/netlink/af_netlink.c:1885\nsock_sendmsg_nosec net/socket.c:730 [inline]\nsock_sendmsg net/socket.c:753 [inline]\n____sys_sendmsg+0x9c2/0xd60 net/socket.c:2541\n___sys_sendmsg+0x28d/0x3c0 net/socket.c:2595\n__sys_sendmsg net/socket.c:2624 [inline]\n__do_sys_sendmsg net/socket.c:2633 [inline]\n__se_sys_sendmsg net/socket.c:2631 [inline]\n__x64_sys_sendmsg+0x307/0x490 net/socket.c:2631\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\nTIPC bearer-related names including link names must be null-terminated\nstrings. If a link name which is not null-terminated is passed through\nnetlink, strstr() and similar functions can cause buffer overrun. This\ncauses the above issue.\nThis patch changes the nla_policy for bearer-related names from NLA_STRING\nto NLA_NUL_STRING. This resolves the issue by ensuring that only\nnull-terminated strings are accepted as bearer-related names.\nsyzbot reported similar uninit-value issue related to bearer names [2]. The\nroot cause of this issue is that a non-null-terminated bearer name was\npassed. This patch also resolved this issue.\n\nCVE-2023-52847:\nIn the Linux kernel, the following vulnerability has been resolved:\nmedia: bttv: fix use after free error due to btv-\u003etimeout timer\nThere may be some a race condition between timer function\nbttv_irq_timeout and bttv_remove. The timer is setup in\nprobe and there is no timer_delete operation in remove\nfunction. When it hit kfree btv, the function might still be\ninvoked, which will cause use after free bug.\nThis bug is found by static analysis, it may be false positive.\nFix it by adding del_timer_sync invoking to the remove function.\ncpu0                cpu1\nbttv_probe\n-\u003etimer_setup\n-\u003ebttv_set_dma\n-\u003emod_timer;\nbttv_remove\n-\u003ekfree(btv);\n-\u003ebttv_irq_timeout\n-\u003eUSE btv\n\nCVE-2023-52864:\nIn the Linux kernel, the following vulnerability has been resolved:\nplatform/x86: wmi: Fix opening of char device\nSince commit fa1f68db6ca7 (\"drivers: misc: pass miscdevice pointer via\nfile private data\"), the miscdevice stores a pointer to itself inside\nfilp-\u003eprivate_data, which means that private_data will not be NULL when\nwmi_char_open() is called. This might cause memory corruption should\nwmi_char_open() be unable to find its driver, something which can\nhappen when the associated WMI device is deleted in wmi_free_devices().\nFix the problem by using the miscdevice pointer to retrieve the WMI\ndevice data associated with a char device using container_of(). This\nalso avoids wmi_char_open() picking a wrong WMI device bound to a\ndriver with the same name as the original driver.\n\nCVE-2024-21823:\nHardware logic with insecure de-synchronization in Intel(R) DSA and Intel(R) IAA for some Intel(R) 4th or 5th generation Xeon(R) processors may allow an authorized user to potentially enable denial of service via local access.\n\nCVE-2024-2201:\nA flaw was found in some Intel CPUs where mitigations for the Spectre V2/BHI vulnerability were incomplete. This issue may allow an attacker to read arbitrary memory, compromising system integrity and exposing sensitive information.\n\nCVE-2024-25739:\ncreate_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi-\u003eleb_size.\n\nCVE-2024-26586:\nIn the Linux kernel, the following vulnerability has been resolved:\nmlxsw: spectrum_acl_tcam: Fix stack corruption\nWhen tc filters are first added to a net device, the corresponding local\nport gets bound to an ACL group in the device. The group contains a list\nof ACLs. In turn, each ACL points to a different TCAM region where the\nfilters are stored. During forwarding, the ACLs are sequentially\nevaluated until a match is found.\nOne reason to place filters in different regions is when they are added\nwith decreasing priorities and in an alternating order so that two\nconsecutive filters can never fit in the same region because of their\nkey usage.\nIn Spectrum-2 and newer ASICs the firmware started to report that the\nmaximum number of ACLs in a group is more than 16, but the layout of the\nregister that configures ACL groups (PAGT) was not updated to account\nfor that. It is therefore possible to hit stack corruption [1] in the\nrare case where more than 16 ACLs in a group are required.\nFix by limiting the maximum ACL group size to the minimum between what\nthe firmware reports and the maximum ACLs that fit in the PAGT register.\nAdd a test case to make sure the machine does not crash when this\ncondition is hit.\n[1]\nKernel panic - not syncing: stack-protector: Kernel stack is corrupted in: mlxsw_sp_acl_tcam_group_update+0x116/0x120\n[...]\ndump_stack_lvl+0x36/0x50\npanic+0x305/0x330\n__stack_chk_fail+0x15/0x20\nmlxsw_sp_acl_tcam_group_update+0x116/0x120\nmlxsw_sp_acl_tcam_group_region_attach+0x69/0x110\nmlxsw_sp_acl_tcam_vchunk_get+0x492/0xa20\nmlxsw_sp_acl_tcam_ventry_add+0x25/0xe0\nmlxsw_sp_acl_rule_add+0x47/0x240\nmlxsw_sp_flower_replace+0x1a9/0x1d0\ntc_setup_cb_add+0xdc/0x1c0\nfl_hw_replace_filter+0x146/0x1f0\nfl_change+0xc17/0x1360\ntc_new_tfilter+0x472/0xb90\nrtnetlink_rcv_msg+0x313/0x3b0\nnetlink_rcv_skb+0x58/0x100\nnetlink_unicast+0x244/0x390\nnetlink_sendmsg+0x1e4/0x440\n____sys_sendmsg+0x164/0x260\n___sys_sendmsg+0x9a/0xe0\n__sys_sendmsg+0x7a/0xc0\ndo_syscall_64+0x40/0xe0\nentry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nCVE-2024-26614:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: make sure init the accept_queue's spinlocks once\nWhen I run syz's reproduction C program locally, it causes the following\nissue:\npvqspinlock: lock 0xffff9d181cd5c660 has corrupted value 0x0!\nWARNING: CPU: 19 PID: 21160 at __pv_queued_spin_unlock_slowpath (kernel/locking/qspinlock_paravirt.h:508)\nHardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\nRIP: 0010:__pv_queued_spin_unlock_slowpath (kernel/locking/qspinlock_paravirt.h:508)\nCode: 73 56 3a ff 90 c3 cc cc cc cc 8b 05 bb 1f 48 01 85 c0 74 05 c3 cc cc cc cc 8b 17 48 89 fe 48 c7 c7\n30 20 ce 8f e8 ad 56 42 ff \u003c0f\u003e 0b c3 cc cc cc cc 0f 0b 0f 1f 40 00 90 90 90 90 90 90 90 90 90\nRSP: 0018:ffffa8d200604cb8 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff9d1ef60e0908\nRDX: 00000000ffffffd8 RSI: 0000000000000027 RDI: ffff9d1ef60e0900\nRBP: ffff9d181cd5c280 R08: 0000000000000000 R09: 00000000ffff7fff\nR10: ffffa8d200604b68 R11: ffffffff907dcdc8 R12: 0000000000000000\nR13: ffff9d181cd5c660 R14: ffff9d1813a3f330 R15: 0000000000001000\nFS:  00007fa110184640(0000) GS:ffff9d1ef60c0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 000000011f65e000 CR4: 00000000000006f0\nCall Trace:\n\u003cIRQ\u003e\n_raw_spin_unlock (kernel/locking/spinlock.c:186)\ninet_csk_reqsk_queue_add (net/ipv4/inet_connection_sock.c:1321)\ninet_csk_complete_hashdance (net/ipv4/inet_connection_sock.c:1358)\ntcp_check_req (net/ipv4/tcp_minisocks.c:868)\ntcp_v4_rcv (net/ipv4/tcp_ipv4.c:2260)\nip_protocol_deliver_rcu (net/ipv4/ip_input.c:205)\nip_local_deliver_finish (net/ipv4/ip_input.c:234)\n__netif_receive_skb_one_core (net/core/dev.c:5529)\nprocess_backlog (./include/linux/rcupdate.h:779)\n__napi_poll (net/core/dev.c:6533)\nnet_rx_action (net/core/dev.c:6604)\n__do_softirq (./arch/x86/include/asm/jump_label.h:27)\ndo_softirq (kernel/softirq.c:454 kernel/softirq.c:441)\n\u003c/IRQ\u003e\n\u003cTASK\u003e\n__local_bh_enable_ip (kernel/softirq.c:381)\n__dev_queue_xmit (net/core/dev.c:4374)\nip_finish_output2 (./include/net/neighbour.h:540 net/ipv4/ip_output.c:235)\n__ip_queue_xmit (net/ipv4/ip_output.c:535)\n__tcp_transmit_skb (net/ipv4/tcp_output.c:1462)\ntcp_rcv_synsent_state_process (net/ipv4/tcp_input.c:6469)\ntcp_rcv_state_process (net/ipv4/tcp_input.c:6657)\ntcp_v4_do_rcv (net/ipv4/tcp_ipv4.c:1929)\n__release_sock (./include/net/sock.h:1121 net/core/sock.c:2968)\nrelease_sock (net/core/sock.c:3536)\ninet_wait_for_connect (net/ipv4/af_inet.c:609)\n__inet_stream_connect (net/ipv4/af_inet.c:702)\ninet_stream_connect (net/ipv4/af_inet.c:748)\n__sys_connect (./include/linux/file.h:45 net/socket.c:2064)\n__x64_sys_connect (net/socket.c:2073 net/socket.c:2070 net/socket.c:2070)\ndo_syscall_64 (arch/x86/entry/common.c:51 arch/x86/entry/common.c:82)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129)\nRIP: 0033:0x7fa10ff05a3d\nCode: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89\nc2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 8b 0d ab a3 0e 00 f7 d8 64 89 01 48\nRSP: 002b:00007fa110183de8 EFLAGS: 00000202 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 0000000020000054 RCX: 00007fa10ff05a3d\nRDX: 000000000000001c RSI: 0000000020000040 RDI: 0000000000000003\nRBP: 00007fa110183e20 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000202 R12: 00007fa110184640\nR13: 0000000000000000 R14: 00007fa10fe8b060 R15: 00007fff73e23b20\n\u003c/TASK\u003e\nThe issue triggering process is analyzed as follows:\nThread A                                       Thread B\ntcp_v4_rcv//receive ack TCP packet       inet_shutdown\ntcp_check_req                                  tcp_disconnect //disconnect sock\n...                                              tcp_set_state(sk, TCP_CLOSE)\ninet_csk_complete_hashdance                ...\ninet_csk_reqsk_queue_add         \n---truncated---\n\nCVE-2024-26640:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: add sanity checks to rx zerocopy\nTCP rx zerocopy intent is to map pages initially allocated\nfrom NIC drivers, not pages owned by a fs.\nThis patch adds to can_map_frag() these additional checks:\n- Page must not be a compound one.\n- page-\u003emapping must be NULL.\nThis fixes the panic reported by ZhangPeng.\nsyzbot was able to loopback packets built with sendfile(),\nmapping pages owned by an ext4 file to TCP rx zerocopy.\nr3 = socket$inet_tcp(0x2, 0x1, 0x0)\nmmap(\u0026(0x7f0000ff9000/0x4000)=nil, 0x4000, 0x0, 0x12, r3, 0x0)\nr4 = socket$inet_tcp(0x2, 0x1, 0x0)\nbind$inet(r4, \u0026(0x7f0000000000)={0x2, 0x4e24, @multicast1}, 0x10)\nconnect$inet(r4, \u0026(0x7f00000006c0)={0x2, 0x4e24, @empty}, 0x10)\nr5 = openat$dir(0xffffffffffffff9c, \u0026(0x7f00000000c0)='./file0\\x00',\n0x181e42, 0x0)\nfallocate(r5, 0x0, 0x0, 0x85b8)\nsendfile(r4, r5, 0x0, 0x8ba0)\ngetsockopt$inet_tcp_TCP_ZEROCOPY_RECEIVE(r4, 0x6, 0x23,\n\u0026(0x7f00000001c0)={\u0026(0x7f0000ffb000/0x3000)=nil, 0x3000, 0x0, 0x0, 0x0,\n0x0, 0x0, 0x0, 0x0}, \u0026(0x7f0000000440)=0x40)\nr6 = openat$dir(0xffffffffffffff9c, \u0026(0x7f00000000c0)='./file0\\x00',\n0x181e42, 0x0)\n\nCVE-2024-26660:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/amd/display: Implement bounds check for stream encoder creation in DCN301\n'stream_enc_regs' array is an array of dcn10_stream_enc_registers\nstructures. The array is initialized with four elements, corresponding\nto the four calls to stream_enc_regs() in the array initializer. This\nmeans that valid indices for this array are 0, 1, 2, and 3.\nThe error message 'stream_enc_regs' 4 \u003c= 5 below, is indicating that\nthere is an attempt to access this array with an index of 5, which is\nout of bounds. This could lead to undefined behavior\nHere, eng_id is used as an index to access the stream_enc_regs array. If\neng_id is 5, this would result in an out-of-bounds access on the\nstream_enc_regs array.\nThus fixing Buffer overflow error in dcn301_stream_encoder_create\nreported by Smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn301/dcn301_resource.c:1011 dcn301_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 \u003c= 5\n\nCVE-2024-26669:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sched: flower: Fix chain template offload\nWhen a qdisc is deleted from a net device the stack instructs the\nunderlying driver to remove its flow offload callback from the\nassociated filter block using the 'FLOW_BLOCK_UNBIND' command. The stack\nthen continues to replay the removal of the filters in the block for\nthis driver by iterating over the chains in the block and invoking the\n'reoffload' operation of the classifier being used. In turn, the\nclassifier in its 'reoffload' operation prepares and emits a\n'FLOW_CLS_DESTROY' command for each filter.\nHowever, the stack does not do the same for chain templates and the\nunderlying driver never receives a 'FLOW_CLS_TMPLT_DESTROY' command when\na qdisc is deleted. This results in a memory leak [1] which can be\nreproduced using [2].\nFix by introducing a 'tmplt_reoffload' operation and have the stack\ninvoke it with the appropriate arguments as part of the replay.\nImplement the operation in the sole classifier that supports chain\ntemplates (flower) by emitting the 'FLOW_CLS_TMPLT_{CREATE,DESTROY}'\ncommand based on whether a flow offload callback is being bound to a\nfilter block or being unbound from one.\nAs far as I can tell, the issue happens since cited commit which\nreordered tcf_block_offload_unbind() before tcf_block_flush_all_chains()\nin __tcf_block_put(). The order cannot be reversed as the filter block\nis expected to be freed after flushing all the chains.\n[1]\nunreferenced object 0xffff888107e28800 (size 2048):\ncomm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s)\nhex dump (first 32 bytes):\nb1 a6 7c 11 81 88 ff ff e0 5b b3 10 81 88 ff ff  ..|......[......\n01 00 00 00 00 00 00 00 e0 aa b0 84 ff ff ff ff  ................\nbacktrace:\n[\u003cffffffff81c06a68\u003e] __kmem_cache_alloc_node+0x1e8/0x320\n[\u003cffffffff81ab374e\u003e] __kmalloc+0x4e/0x90\n[\u003cffffffff832aec6d\u003e] mlxsw_sp_acl_ruleset_get+0x34d/0x7a0\n[\u003cffffffff832bc195\u003e] mlxsw_sp_flower_tmplt_create+0x145/0x180\n[\u003cffffffff832b2e1a\u003e] mlxsw_sp_flow_block_cb+0x1ea/0x280\n[\u003cffffffff83a10613\u003e] tc_setup_cb_call+0x183/0x340\n[\u003cffffffff83a9f85a\u003e] fl_tmplt_create+0x3da/0x4c0\n[\u003cffffffff83a22435\u003e] tc_ctl_chain+0xa15/0x1170\n[\u003cffffffff838a863c\u003e] rtnetlink_rcv_msg+0x3cc/0xed0\n[\u003cffffffff83ac87f0\u003e] netlink_rcv_skb+0x170/0x440\n[\u003cffffffff83ac6270\u003e] netlink_unicast+0x540/0x820\n[\u003cffffffff83ac6e28\u003e] netlink_sendmsg+0x8d8/0xda0\n[\u003cffffffff83793def\u003e] ____sys_sendmsg+0x30f/0xa80\n[\u003cffffffff8379d29a\u003e] ___sys_sendmsg+0x13a/0x1e0\n[\u003cffffffff8379d50c\u003e] __sys_sendmsg+0x11c/0x1f0\n[\u003cffffffff843b9ce0\u003e] do_syscall_64+0x40/0xe0\nunreferenced object 0xffff88816d2c0400 (size 1024):\ncomm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s)\nhex dump (first 32 bytes):\n40 00 00 00 00 00 00 00 57 f6 38 be 00 00 00 00  @.......W.8.....\n10 04 2c 6d 81 88 ff ff 10 04 2c 6d 81 88 ff ff  ..,m......,m....\nbacktrace:\n[\u003cffffffff81c06a68\u003e] __kmem_cache_alloc_node+0x1e8/0x320\n[\u003cffffffff81ab36c1\u003e] __kmalloc_node+0x51/0x90\n[\u003cffffffff81a8ed96\u003e] kvmalloc_node+0xa6/0x1f0\n[\u003cffffffff82827d03\u003e] bucket_table_alloc.isra.0+0x83/0x460\n[\u003cffffffff82828d2b\u003e] rhashtable_init+0x43b/0x7c0\n[\u003cffffffff832aed48\u003e] mlxsw_sp_acl_ruleset_get+0x428/0x7a0\n[\u003cffffffff832bc195\u003e] mlxsw_sp_flower_tmplt_create+0x145/0x180\n[\u003cffffffff832b2e1a\u003e] mlxsw_sp_flow_block_cb+0x1ea/0x280\n[\u003cffffffff83a10613\u003e] tc_setup_cb_call+0x183/0x340\n[\u003cffffffff83a9f85a\u003e] fl_tmplt_create+0x3da/0x4c0\n[\u003cffffffff83a22435\u003e] tc_ctl_chain+0xa15/0x1170\n[\u003cffffffff838a863c\u003e] rtnetlink_rcv_msg+0x3cc/0xed0\n[\u003cffffffff83ac87f0\u003e] netlink_rcv_skb+0x170/0x440\n[\u003cffffffff83ac6270\u003e] netlink_unicast+0x540/0x820\n[\u003cffffffff83ac6e28\u003e] netlink_sendmsg+0x8d8/0xda0\n[\u003cffffffff83793def\u003e] ____sys_sendmsg+0x30f/0xa80\n[2]\n# tc qdisc add dev swp1 clsact\n# tc chain add dev swp1 ingress proto ip chain 1 flower dst_ip 0.0.0.0/32\n# tc qdisc del dev\n---truncated---\n\nCVE-2024-26686:\nIn the Linux kernel, the following vulnerability has been resolved:\nfs/proc: do_task_stat: use sig-\u003estats_lock to gather the threads/children stats\nlock_task_sighand() can trigger a hard lockup.  If NR_CPUS threads call\ndo_task_stat() at the same time and the process has NR_THREADS, it will\nspin with irqs disabled O(NR_CPUS * NR_THREADS) time.\nChange do_task_stat() to use sig-\u003estats_lock to gather the statistics\noutside of -\u003esiglock protected section, in the likely case this code will\nrun lockless.\n\nCVE-2024-26698:\nIn the Linux kernel, the following vulnerability has been resolved:\nhv_netvsc: Fix race condition between netvsc_probe and netvsc_remove\nIn commit ac5047671758 (\"hv_netvsc: Disable NAPI before closing the\nVMBus channel\"), napi_disable was getting called for all channels,\nincluding all subchannels without confirming if they are enabled or not.\nThis caused hv_netvsc getting hung at napi_disable, when netvsc_probe()\nhas finished running but nvdev-\u003esubchan_work has not started yet.\nnetvsc_subchan_work() -\u003e rndis_set_subchannel() has not created the\nsub-channels and because of that netvsc_sc_open() is not running.\nnetvsc_remove() calls cancel_work_sync(\u0026nvdev-\u003esubchan_work), for which\nnetvsc_subchan_work did not run.\nnetif_napi_add() sets the bit NAPI_STATE_SCHED because it ensures NAPI\ncannot be scheduled. Then netvsc_sc_open() -\u003e napi_enable will clear the\nNAPIF_STATE_SCHED bit, so it can be scheduled. napi_disable() does the\nopposite.\nNow during netvsc_device_remove(), when napi_disable is called for those\nsubchannels, napi_disable gets stuck on infinite msleep.\nThis fix addresses this problem by ensuring that napi_disable() is not\ngetting called for non-enabled NAPI struct.\nBut netif_napi_del() is still necessary for these non-enabled NAPI struct\nfor cleanup purpose.\nCall trace:\n[  654.559417] task:modprobe        state:D stack:    0 pid: 2321 ppid:  1091 flags:0x00004002\n[  654.568030] Call Trace:\n[  654.571221]  \u003cTASK\u003e\n[  654.573790]  __schedule+0x2d6/0x960\n[  654.577733]  schedule+0x69/0xf0\n[  654.581214]  schedule_timeout+0x87/0x140\n[  654.585463]  ? __bpf_trace_tick_stop+0x20/0x20\n[  654.590291]  msleep+0x2d/0x40\n[  654.593625]  napi_disable+0x2b/0x80\n[  654.597437]  netvsc_device_remove+0x8a/0x1f0 [hv_netvsc]\n[  654.603935]  rndis_filter_device_remove+0x194/0x1c0 [hv_netvsc]\n[  654.611101]  ? do_wait_intr+0xb0/0xb0\n[  654.615753]  netvsc_remove+0x7c/0x120 [hv_netvsc]\n[  654.621675]  vmbus_remove+0x27/0x40 [hv_vmbus]\n\nCVE-2024-26704:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: fix double-free of blocks due to wrong extents moved_len\nIn ext4_move_extents(), moved_len is only updated when all moves are\nsuccessfully executed, and only discards orig_inode and donor_inode\npreallocations when moved_len is not zero. When the loop fails to exit\nafter successfully moving some extents, moved_len is not updated and\nremains at 0, so it does not discard the preallocations.\nIf the moved extents overlap with the preallocated extents, the\noverlapped extents are freed twice in ext4_mb_release_inode_pa() and\next4_process_freed_data() (as described in commit 94d7c16cbbbd (\"ext4:\nFix double-free of blocks with EXT4_IOC_MOVE_EXT\")), and bb_free is\nincremented twice. Hence when trim is executed, a zero-division bug is\ntriggered in mb_update_avg_fragment_size() because bb_free is not zero\nand bb_fragments is zero.\nTherefore, update move_len after each extent move to avoid the issue.\n\nCVE-2024-26733:\nIn the Linux kernel, the following vulnerability has been resolved:\narp: Prevent overflow in arp_req_get().\nsyzkaller reported an overflown write in arp_req_get(). [0]\nWhen ioctl(SIOCGARP) is issued, arp_req_get() looks up an neighbour\nentry and copies neigh-\u003eha to struct arpreq.arp_ha.sa_data.\nThe arp_ha here is struct sockaddr, not struct sockaddr_storage, so\nthe sa_data buffer is just 14 bytes.\nIn the splat below, 2 bytes are overflown to the next int field,\narp_flags.  We initialise the field just after the memcpy(), so it's\nnot a problem.\nHowever, when dev-\u003eaddr_len is greater than 22 (e.g. MAX_ADDR_LEN),\narp_netmask is overwritten, which could be set as htonl(0xFFFFFFFFUL)\nin arp_ioctl() before calling arp_req_get().\nTo avoid the overflow, let's limit the max length of memcpy().\nNote that commit b5f0de6df6dc (\"net: dev: Convert sa_data to flexible\narray in struct sockaddr\") just silenced syzkaller.\n[0]:\nmemcpy: detected field-spanning write (size 16) of single field \"r-\u003earp_ha.sa_data\" at net/ipv4/arp.c:1128 (size 14)\nWARNING: CPU: 0 PID: 144638 at net/ipv4/arp.c:1128 arp_req_get+0x411/0x4a0 net/ipv4/arp.c:1128\nModules linked in:\nCPU: 0 PID: 144638 Comm: syz-executor.4 Not tainted 6.1.74 #31\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-5 04/01/2014\nRIP: 0010:arp_req_get+0x411/0x4a0 net/ipv4/arp.c:1128\nCode: fd ff ff e8 41 42 de fb b9 0e 00 00 00 4c 89 fe 48 c7 c2 20 6d ab 87 48 c7 c7 80 6d ab 87 c6 05 25 af 72 04 01 e8 5f 8d ad fb \u003c0f\u003e 0b e9 6c fd ff ff e8 13 42 de fb be 03 00 00 00 4c 89 e7 e8 a6\nRSP: 0018:ffffc900050b7998 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: ffff88803a815000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffffff8641a44a RDI: 0000000000000001\nRBP: ffffc900050b7a98 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 203a7970636d656d R12: ffff888039c54000\nR13: 1ffff92000a16f37 R14: ffff88803a815084 R15: 0000000000000010\nFS:  00007f172bf306c0(0000) GS:ffff88805aa00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f172b3569f0 CR3: 0000000057f12005 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\narp_ioctl+0x33f/0x4b0 net/ipv4/arp.c:1261\ninet_ioctl+0x314/0x3a0 net/ipv4/af_inet.c:981\nsock_do_ioctl+0xdf/0x260 net/socket.c:1204\nsock_ioctl+0x3ef/0x650 net/socket.c:1321\nvfs_ioctl fs/ioctl.c:51 [inline]\n__do_sys_ioctl fs/ioctl.c:870 [inline]\n__se_sys_ioctl fs/ioctl.c:856 [inline]\n__x64_sys_ioctl+0x18e/0x220 fs/ioctl.c:856\ndo_syscall_x64 arch/x86/entry/common.c:51 [inline]\ndo_syscall_64+0x37/0x90 arch/x86/entry/common.c:81\nentry_SYSCALL_64_after_hwframe+0x64/0xce\nRIP: 0033:0x7f172b262b8d\nCode: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f172bf300b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007f172b3abf80 RCX: 00007f172b262b8d\nRDX: 0000000020000000 RSI: 0000000000008954 RDI: 0000000000000003\nRBP: 00007f172b2d3493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007f172b3abf80 R15: 00007f172bf10000\n\u003c/TASK\u003e\n\nCVE-2024-26740:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sched: act_mirred: use the backlog for mirred ingress\nThe test Davide added in commit ca22da2fbd69 (\"act_mirred: use the backlog\nfor nested calls to mirred ingress\") hangs our testing VMs every 10 or so\nruns, with the familiar tcp_v4_rcv -\u003e tcp_v4_rcv deadlock reported by\nlockdep.\nThe problem as previously described by Davide (see Link) is that\nif we reverse flow of traffic with the redirect (egress -\u003e ingress)\nwe may reach the same socket which generated the packet. And we may\nstill be holding its socket lock. The common solution to such deadlocks\nis to put the packet in the Rx backlog, rather than run the Rx path\ninline. Do that for all egress -\u003e ingress reversals, not just once\nwe started to nest mirred calls.\nIn the past there was a concern that the backlog indirection will\nlead to loss of error reporting / less accurate stats. But the current\nworkaround does not seem to address the issue.\n\nCVE-2024-26772:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: avoid allocating blocks from corrupted group in ext4_mb_find_by_goal()\nPlaces the logic for checking if the group's block bitmap is corrupt under\nthe protection of the group lock to avoid allocating blocks from the group\nwith a corrupted block bitmap.\n\nCVE-2024-26773:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: avoid allocating blocks from corrupted group in ext4_mb_try_best_found()\nDetermine if the group block bitmap is corrupted before using ac_b_ex in\next4_mb_try_best_found() to avoid allocating blocks from a group with a\ncorrupted block bitmap in the following concurrency and making the\nsituation worse.\next4_mb_regular_allocator\next4_lock_group(sb, group)\next4_mb_good_group\n// check if the group bbitmap is corrupted\next4_mb_complex_scan_group\n// Scan group gets ac_b_ex but doesn't use it\next4_unlock_group(sb, group)\next4_mark_group_bitmap_corrupted(group)\n// The block bitmap was corrupted during\n// the group unlock gap.\next4_mb_try_best_found\next4_lock_group(ac-\u003eac_sb, group)\next4_mb_use_best_found\nmb_mark_used\n// Allocating blocks in block bitmap corrupted group\n\nCVE-2024-26802:\nIn the Linux kernel, the following vulnerability has been resolved:\nstmmac: Clear variable when destroying workqueue\nCurrently when suspending driver and stopping workqueue it is checked whether\nworkqueue is not NULL and if so, it is destroyed.\nFunction destroy_workqueue() does drain queue and does clear variable, but\nit does not set workqueue variable to NULL. This can cause kernel/module\npanic if code attempts to clear workqueue that was not initialized.\nThis scenario is possible when resuming suspended driver in stmmac_resume(),\nbecause there is no handling for failed stmmac_hw_setup(),\nwhich can fail and return if DMA engine has failed to initialize,\nand workqueue is initialized after DMA engine.\nShould DMA engine fail to initialize, resume will proceed normally,\nbut interface won't work and TX queue will eventually timeout,\ncausing 'Reset adapter' error.\nThis then does destroy workqueue during reset process.\nAnd since workqueue is initialized after DMA engine and can be skipped,\nit will cause kernel/module panic.\nTo secure against this possible crash, set workqueue variable to NULL when\ndestroying workqueue.\nLog/backtrace from crash goes as follows:\n[88.031977]------------[ cut here ]------------\n[88.031985]NETDEV WATCHDOG: eth0 (sxgmac): transmit queue 1 timed out\n[88.032017]WARNING: CPU: 0 PID: 0 at net/sched/sch_generic.c:477 dev_watchdog+0x390/0x398\n\u003cSkipping backtrace for watchdog timeout\u003e\n[88.032251]---[ end trace e70de432e4d5c2c0 ]---\n[88.032282]sxgmac 16d88000.ethernet eth0: Reset adapter.\n[88.036359]------------[ cut here ]------------\n[88.036519]Call trace:\n[88.036523] flush_workqueue+0x3e4/0x430\n[88.036528] drain_workqueue+0xc4/0x160\n[88.036533] destroy_workqueue+0x40/0x270\n[88.036537] stmmac_fpe_stop_wq+0x4c/0x70\n[88.036541] stmmac_release+0x278/0x280\n[88.036546] __dev_close_many+0xcc/0x158\n[88.036551] dev_close_many+0xbc/0x190\n[88.036555] dev_close.part.0+0x70/0xc0\n[88.036560] dev_close+0x24/0x30\n[88.036564] stmmac_service_task+0x110/0x140\n[88.036569] process_one_work+0x1d8/0x4a0\n[88.036573] worker_thread+0x54/0x408\n[88.036578] kthread+0x164/0x170\n[88.036583] ret_from_fork+0x10/0x20\n[88.036588]---[ end trace e70de432e4d5c2c1 ]---\n[88.036597]Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004\n\nCVE-2024-26810:\nIn the Linux kernel, the following vulnerability has been resolved:\nvfio/pci: Lock external INTx masking ops\nMask operations through config space changes to DisINTx may race INTx\nconfiguration changes via ioctl.  Create wrappers that add locking for\npaths outside of the core interrupt code.\nIn particular, irq_type is updated holding igate, therefore testing\nis_intx() requires holding igate.  For example clearing DisINTx from\nconfig space can otherwise race changes of the interrupt configuration.\nThis aligns interfaces which may trigger the INTx eventfd into two\ncamps, one side serialized by igate and the other only enabled while\nINTx is configured.  A subsequent patch introduces synchronization for\nthe latter flows.\n\nCVE-2024-26837:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: bridge: switchdev: Skip MDB replays of deferred events on offload\nBefore this change, generation of the list of MDB events to replay\nwould race against the creation of new group memberships, either from\nthe IGMP/MLD snooping logic or from user configuration.\nWhile new memberships are immediately visible to walkers of\nbr-\u003emdb_list, the notification of their existence to switchdev event\nsubscribers is deferred until a later point in time. So if a replay\nlist was generated during a time that overlapped with such a window,\nit would also contain a replay of the not-yet-delivered event.\nThe driver would thus receive two copies of what the bridge internally\nconsidered to be one single event. On destruction of the bridge, only\na single membership deletion event was therefore sent. As a\nconsequence of this, drivers which reference count memberships (at\nleast DSA), would be left with orphan groups in their hardware\ndatabase when the bridge was destroyed.\nThis is only an issue when replaying additions. While deletion events\nmay still be pending on the deferred queue, they will already have\nbeen removed from br-\u003emdb_list, so no duplicates can be generated in\nthat scenario.\nTo a user this meant that old group memberships, from a bridge in\nwhich a port was previously attached, could be reanimated (in\nhardware) when the port joined a new bridge, without the new bridge's\nknowledge.\nFor example, on an mv88e6xxx system, create a snooping bridge and\nimmediately add a port to it:\nroot@infix-06-0b-00:~$ ip link add dev br0 up type bridge mcast_snooping 1 \u0026\u0026 \\\n\u003e ip link set dev x3 up master br0\nAnd then destroy the bridge:\nroot@infix-06-0b-00:~$ ip link del dev br0\nroot@infix-06-0b-00:~$ mvls atu\nADDRESS             FID  STATE      Q  F  0  1  2  3  4  5  6  7  8  9  a\nDEV:0 Marvell 88E6393X\n33:33:00:00:00:6a     1  static     -  -  0  .  .  .  .  .  .  .  .  .  .\n33:33:ff:87:e4:3f     1  static     -  -  0  .  .  .  .  .  .  .  .  .  .\nff:ff:ff:ff:ff:ff     1  static     -  -  0  1  2  3  4  5  6  7  8  9  a\nroot@infix-06-0b-00:~$\nThe two IPv6 groups remain in the hardware database because the\nport (x3) is notified of the host's membership twice: once via the\noriginal event and once via a replay. Since only a single delete\nnotification is sent, the count remains at 1 when the bridge is\ndestroyed.\nThen add the same port (or another port belonging to the same hardware\ndomain) to a new bridge, this time with snooping disabled:\nroot@infix-06-0b-00:~$ ip link add dev br1 up type bridge mcast_snooping 0 \u0026\u0026 \\\n\u003e ip link set dev x3 up master br1\nAll multicast, including the two IPv6 groups from br0, should now be\nflooded, according to the policy of br1. But instead the old\nmemberships are still active in the hardware database, causing the\nswitch to only forward traffic to those groups towards the CPU (port\n0).\nEliminate the race in two steps:\n1. Grab the write-side lock of the MDB while generating the replay\nlist.\nThis prevents new memberships from showing up while we are generating\nthe replay list. But it leaves the scenario in which a deferred event\nwas already generated, but not delivered, before we grabbed the\nlock. Therefore:\n2. Make sure that no deferred version of a replay event is already\nenqueued to the switchdev deferred queue, before adding it to the\nreplay list, when replaying additions.\n\nCVE-2024-26840:\nIn the Linux kernel, the following vulnerability has been resolved:\ncachefiles: fix memory leak in cachefiles_add_cache()\nThe following memory leak was reported after unbinding /dev/cachefiles:\n==================================================================\nunreferenced object 0xffff9b674176e3c0 (size 192):\ncomm \"cachefilesd2\", pid 680, jiffies 4294881224\nhex dump (first 32 bytes):\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nbacktrace (crc ea38a44b):\n[\u003cffffffff8eb8a1a5\u003e] kmem_cache_alloc+0x2d5/0x370\n[\u003cffffffff8e917f86\u003e] prepare_creds+0x26/0x2e0\n[\u003cffffffffc002eeef\u003e] cachefiles_determine_cache_security+0x1f/0x120\n[\u003cffffffffc00243ec\u003e] cachefiles_add_cache+0x13c/0x3a0\n[\u003cffffffffc0025216\u003e] cachefiles_daemon_write+0x146/0x1c0\n[\u003cffffffff8ebc4a3b\u003e] vfs_write+0xcb/0x520\n[\u003cffffffff8ebc5069\u003e] ksys_write+0x69/0xf0\n[\u003cffffffff8f6d4662\u003e] do_syscall_64+0x72/0x140\n[\u003cffffffff8f8000aa\u003e] entry_SYSCALL_64_after_hwframe+0x6e/0x76\n==================================================================\nPut the reference count of cache_cred in cachefiles_daemon_unbind() to\nfix the problem. And also put cache_cred in cachefiles_add_cache() error\nbranch to avoid memory leaks.\n\nCVE-2024-26843:\nIn the Linux kernel, the following vulnerability has been resolved:\nefi: runtime: Fix potential overflow of soft-reserved region size\nmd_size will have been narrowed if we have \u003e= 4GB worth of pages in a\nsoft-reserved region.\n\nCVE-2024-26852:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/ipv6: avoid possible UAF in ip6_route_mpath_notify()\nsyzbot found another use-after-free in ip6_route_mpath_notify() [1]\nCommit f7225172f25a (\"net/ipv6: prevent use after free in\nip6_route_mpath_notify\") was not able to fix the root cause.\nWe need to defer the fib6_info_release() calls after\nip6_route_mpath_notify(), in the cleanup phase.\n[1]\nBUG: KASAN: slab-use-after-free in rt6_fill_node+0x1460/0x1ac0\nRead of size 4 at addr ffff88809a07fc64 by task syz-executor.2/23037\nCPU: 0 PID: 23037 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-01035-gea7f3cfaa588 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024\nCall Trace:\n\u003cTASK\u003e\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0x1e7/0x2e0 lib/dump_stack.c:106\nprint_address_description mm/kasan/report.c:377 [inline]\nprint_report+0x167/0x540 mm/kasan/report.c:488\nkasan_report+0x142/0x180 mm/kasan/report.c:601\nrt6_fill_node+0x1460/0x1ac0\ninet6_rt_notify+0x13b/0x290 net/ipv6/route.c:6184\nip6_route_mpath_notify net/ipv6/route.c:5198 [inline]\nip6_route_multipath_add net/ipv6/route.c:5404 [inline]\ninet6_rtm_newroute+0x1d0f/0x2300 net/ipv6/route.c:5517\nrtnetlink_rcv_msg+0x885/0x1040 net/core/rtnetlink.c:6597\nnetlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543\nnetlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]\nnetlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367\nnetlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg+0x221/0x270 net/socket.c:745\n____sys_sendmsg+0x525/0x7d0 net/socket.c:2584\n___sys_sendmsg net/socket.c:2638 [inline]\n__sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667\ndo_syscall_64+0xf9/0x240\nentry_SYSCALL_64_after_hwframe+0x6f/0x77\nRIP: 0033:0x7f73dd87dda9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f73de6550c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f73dd9ac050 RCX: 00007f73dd87dda9\nRDX: 0000000000000000 RSI: 0000000020000140 RDI: 0000000000000005\nRBP: 00007f73dd8ca47a R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000006e R14: 00007f73dd9ac050 R15: 00007ffdbdeb7858\n\u003c/TASK\u003e\nAllocated by task 23037:\nkasan_save_stack mm/kasan/common.c:47 [inline]\nkasan_save_track+0x3f/0x80 mm/kasan/common.c:68\npoison_kmalloc_redzone mm/kasan/common.c:372 [inline]\n__kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:389\nkasan_kmalloc include/linux/kasan.h:211 [inline]\n__do_kmalloc_node mm/slub.c:3981 [inline]\n__kmalloc+0x22e/0x490 mm/slub.c:3994\nkmalloc include/linux/slab.h:594 [inline]\nkzalloc include/linux/slab.h:711 [inline]\nfib6_info_alloc+0x2e/0xf0 net/ipv6/ip6_fib.c:155\nip6_route_info_create+0x445/0x12b0 net/ipv6/route.c:3758\nip6_route_multipath_add net/ipv6/route.c:5298 [inline]\ninet6_rtm_newroute+0x744/0x2300 net/ipv6/route.c:5517\nrtnetlink_rcv_msg+0x885/0x1040 net/core/rtnetlink.c:6597\nnetlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543\nnetlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]\nnetlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367\nnetlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg+0x221/0x270 net/socket.c:745\n____sys_sendmsg+0x525/0x7d0 net/socket.c:2584\n___sys_sendmsg net/socket.c:2638 [inline]\n__sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667\ndo_syscall_64+0xf9/0x240\nentry_SYSCALL_64_after_hwframe+0x6f/0x77\nFreed by task 16:\nkasan_save_stack mm/kasan/common.c:47 [inline]\nkasan_save_track+0x3f/0x80 mm/kasan/common.c:68\nkasan_save_free_info+0x4e/0x60 mm/kasan/generic.c:640\npoison_slab_object+0xa6/0xe0 m\n---truncated---\n\nCVE-2024-26853:\nIn the Linux kernel, the following vulnerability has been resolved:\nigc: avoid returning frame twice in XDP_REDIRECT\nWhen a frame can not be transmitted in XDP_REDIRECT\n(e.g. due to a full queue), it is necessary to free\nit by calling xdp_return_frame_rx_napi.\nHowever, this is the responsibility of the caller of\nthe ndo_xdp_xmit (see for example bq_xmit_all in\nkernel/bpf/devmap.c) and thus calling it inside\nigc_xdp_xmit (which is the ndo_xdp_xmit of the igc\ndriver) as well will lead to memory corruption.\nIn fact, bq_xmit_all expects that it can return all\nframes after the last successfully transmitted one.\nTherefore, break for the first not transmitted frame,\nbut do not call xdp_return_frame_rx_napi in igc_xdp_xmit.\nThis is equally implemented in other Intel drivers\nsuch as the igb.\nThere are two alternatives to this that were rejected:\n1. Return num_frames as all the frames would have been\ntransmitted and release them inside igc_xdp_xmit.\nWhile it might work technically, it is not what\nthe return value is meant to represent (i.e. the\nnumber of SUCCESSFULLY transmitted packets).\n2. Rework kernel/bpf/devmap.c and all drivers to\nsupport non-consecutively dropped packets.\nBesides being complex, it likely has a negative\nperformance impact without a significant gain\nsince it is anyway unlikely that the next frame\ncan be transmitted if the previous one was dropped.\nThe memory corruption can be reproduced with\nthe following script which leads to a kernel panic\nafter a few seconds.  It basically generates more\ntraffic than a i225 NIC can transmit and pushes it\nvia XDP_REDIRECT from a virtual interface to the\nphysical interface where frames get dropped.\n#!/bin/bash\nINTERFACE=enp4s0\nINTERFACE_IDX=`cat /sys/class/net/$INTERFACE/ifindex`\nsudo ip link add dev veth1 type veth peer name veth2\nsudo ip link set up $INTERFACE\nsudo ip link set up veth1\nsudo ip link set up veth2\ncat \u003c\u003c EOF \u003e redirect.bpf.c\nSEC(\"prog\")\nint redirect(struct xdp_md *ctx)\n{\nreturn bpf_redirect($INTERFACE_IDX, 0);\n}\nchar _license[] SEC(\"license\") = \"GPL\";\nEOF\nclang -O2 -g -Wall -target bpf -c redirect.bpf.c -o redirect.bpf.o\nsudo ip link set veth2 xdp obj redirect.bpf.o\ncat \u003c\u003c EOF \u003e pass.bpf.c\nSEC(\"prog\")\nint pass(struct xdp_md *ctx)\n{\nreturn XDP_PASS;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\nEOF\nclang -O2 -g -Wall -target bpf -c pass.bpf.c -o pass.bpf.o\nsudo ip link set $INTERFACE xdp obj pass.bpf.o\ncat \u003c\u003c EOF \u003e trafgen.cfg\n{\n/* Ethernet Header */\n0xe8, 0x6a, 0x64, 0x41, 0xbf, 0x46,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\nconst16(ETH_P_IP),\n/* IPv4 Header */\n0b01000101, 0,   # IPv4 version, IHL, TOS\nconst16(1028),   # IPv4 total length (UDP length + 20 bytes (IP header))\nconst16(2),      # IPv4 ident\n0b01000000, 0,   # IPv4 flags, fragmentation off\n64,              # IPv4 TTL\n17,              # Protocol UDP\ncsumip(14, 33),  # IPv4 checksum\n/* UDP Header */\n10,  0, 1, 1,    # IP Src - adapt as needed\n10,  0, 1, 2,    # IP Dest - adapt as needed\nconst16(6666),   # UDP Src Port\nconst16(6666),   # UDP Dest Port\nconst16(1008),   # UDP length (UDP header 8 bytes + payload length)\ncsumudp(14, 34), # UDP checksum\n/* Payload */\nfill('W', 1000),\n}\nEOF\nsudo trafgen -i trafgen.cfg -b3000MB -o veth1 --cpp\n\nCVE-2024-26870:\nIn the Linux kernel, the following vulnerability has been resolved:\nNFSv4.2: fix nfs4_listxattr kernel BUG at mm/usercopy.c:102\nA call to listxattr() with a buffer size = 0 returns the actual\nsize of the buffer needed for a subsequent call. When size \u003e 0,\nnfs4_listxattr() does not return an error because either\ngeneric_listxattr() or nfs4_listxattr_nfs4_label() consumes\nexactly all the bytes then size is 0 when calling\nnfs4_listxattr_nfs4_user() which then triggers the following\nkernel BUG:\n[   99.403778] kernel BUG at mm/usercopy.c:102!\n[   99.404063] Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n[   99.408463] CPU: 0 PID: 3310 Comm: python3 Not tainted 6.6.0-61.fc40.aarch64 #1\n[   99.415827] Call trace:\n[   99.415985]  usercopy_abort+0x70/0xa0\n[   99.416227]  __check_heap_object+0x134/0x158\n[   99.416505]  check_heap_object+0x150/0x188\n[   99.416696]  __check_object_size.part.0+0x78/0x168\n[   99.416886]  __check_object_size+0x28/0x40\n[   99.417078]  listxattr+0x8c/0x120\n[   99.417252]  path_listxattr+0x78/0xe0\n[   99.417476]  __arm64_sys_listxattr+0x28/0x40\n[   99.417723]  invoke_syscall+0x78/0x100\n[   99.417929]  el0_svc_common.constprop.0+0x48/0xf0\n[   99.418186]  do_el0_svc+0x24/0x38\n[   99.418376]  el0_svc+0x3c/0x110\n[   99.418554]  el0t_64_sync_handler+0x120/0x130\n[   99.418788]  el0t_64_sync+0x194/0x198\n[   99.418994] Code: aa0003e3 d000a3e0 91310000 97f49bdb (d4210000)\nIssue is reproduced when generic_listxattr() returns 'system.nfs4_acl',\nthus calling lisxattr() with size = 16 will trigger the bug.\nAdd check on nfs4_listxattr() to return ERANGE error when it is\ncalled with size \u003e 0 and the return value is greater than size.\n\nCVE-2024-26878:\nIn the Linux kernel, the following vulnerability has been resolved:\nquota: Fix potential NULL pointer dereference\nBelow race may cause NULL pointer dereference\nP1P2\ndquot_free_inodequota_off\ndrop_dquot_ref\nremove_dquot_ref\ndquots = i_dquot(inode)\ndquots = i_dquot(inode)\nsrcu_read_lock\ndquots[cnt]) != NULL (1)\ndquots[type] = NULL (2)\nspin_lock(\u0026dquots[cnt]-\u003edq_dqb_lock) (3)\n....\nIf dquot_free_inode(or other routines) checks inode's quota pointers (1)\nbefore quota_off sets it to NULL(2) and use it (3) after that, NULL pointer\ndereference will be triggered.\nSo let's fix it by using a temporary pointer to avoid this issue.\n\nCVE-2024-26908:\nThis CVE ID has been rejected or withdrawn by its CVE Numbering Authority for the following reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.\n\nCVE-2024-26921:\nIn the Linux kernel, the following vulnerability has been resolved:\ninet: inet_defrag: prevent sk release while still in use\nip_local_out() and other functions can pass skb-\u003esk as function argument.\nIf the skb is a fragment and reassembly happens before such function call\nreturns, the sk must not be released.\nThis affects skb fragments reassembled via netfilter or similar\nmodules, e.g. openvswitch or ct_act.c, when run as part of tx pipeline.\nEric Dumazet made an initial analysis of this bug.  Quoting Eric:\nCalling ip_defrag() in output path is also implying skb_orphan(),\nwhich is buggy because output path relies on sk not disappearing.\nA relevant old patch about the issue was :\n8282f27449bf (\"inet: frag: Always orphan skbs inside ip_defrag()\")\n[..]\nnet/ipv4/ip_output.c depends on skb-\u003esk being set, and probably to an\ninet socket, not an arbitrary one.\nIf we orphan the packet in ipvlan, then downstream things like FQ\npacket scheduler will not work properly.\nWe need to change ip_defrag() to only use skb_orphan() when really\nneeded, ie whenever frag_list is going to be used.\nEric suggested to stash sk in fragment queue and made an initial patch.\nHowever there is a problem with this:\nIf skb is refragmented again right after, ip_do_fragment() will copy\nhead-\u003esk to the new fragments, and sets up destructor to sock_wfree.\nIOW, we have no choice but to fix up sk_wmem accouting to reflect the\nfully reassembled skb, else wmem will underflow.\nThis change moves the orphan down into the core, to last possible moment.\nAs ip_defrag_offset is aliased with sk_buff-\u003esk member, we must move the\noffset into the FRAG_CB, else skb-\u003esk gets clobbered.\nThis allows to delay the orphaning long enough to learn if the skb has\nto be queued or if the skb is completing the reasm queue.\nIn the former case, things work as before, skb is orphaned.  This is\nsafe because skb gets queued/stolen and won't continue past reasm engine.\nIn the latter case, we will steal the skb-\u003esk reference, reattach it to\nthe head skb, and fix up wmem accouting when inet_frag inflates truesize.\n\nCVE-2024-26925:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: release mutex after nft_gc_seq_end from abort path\nThe commit mutex should not be released during the critical section\nbetween nft_gc_seq_begin() and nft_gc_seq_end(), otherwise, async GC\nworker could collect expired objects and get the released commit lock\nwithin the same GC sequence.\nnf_tables_module_autoload() temporarily releases the mutex to load\nmodule dependencies, then it goes back to replay the transaction again.\nMove it at the end of the abort phase after nft_gc_seq_end() is called.\n\nCVE-2024-26940:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Create debugfs ttm_resource_manager entry only if needed\nThe driver creates /sys/kernel/debug/dri/0/mob_ttm even when the\ncorresponding ttm_resource_manager is not allocated.\nThis leads to a crash when trying to read from this file.\nAdd a check to create mob_ttm, system_mob_ttm, and gmr_ttm debug file\nonly when the corresponding ttm_resource_manager is allocated.\ncrash\u003e bt\nPID: 3133409  TASK: ffff8fe4834a5000  CPU: 3    COMMAND: \"grep\"\n#0 [ffffb954506b3b20] machine_kexec at ffffffffb2a6bec3\n#1 [ffffb954506b3b78] __crash_kexec at ffffffffb2bb598a\n#2 [ffffb954506b3c38] crash_kexec at ffffffffb2bb68c1\n#3 [ffffb954506b3c50] oops_end at ffffffffb2a2a9b1\n#4 [ffffb954506b3c70] no_context at ffffffffb2a7e913\n#5 [ffffb954506b3cc8] __bad_area_nosemaphore at ffffffffb2a7ec8c\n#6 [ffffb954506b3d10] do_page_fault at ffffffffb2a7f887\n#7 [ffffb954506b3d40] page_fault at ffffffffb360116e\n[exception RIP: ttm_resource_manager_debug+0x11]\nRIP: ffffffffc04afd11  RSP: ffffb954506b3df0  RFLAGS: 00010246\nRAX: ffff8fe41a6d1200  RBX: 0000000000000000  RCX: 0000000000000940\nRDX: 0000000000000000  RSI: ffffffffc04b4338  RDI: 0000000000000000\nRBP: ffffb954506b3e08   R8: ffff8fee3ffad000   R9: 0000000000000000\nR10: ffff8fe41a76a000  R11: 0000000000000001  R12: 00000000ffffffff\nR13: 0000000000000001  R14: ffff8fe5bb6f3900  R15: ffff8fe41a6d1200\nORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n#8 [ffffb954506b3e00] ttm_resource_manager_show at ffffffffc04afde7 [ttm]\n#9 [ffffb954506b3e30] seq_read at ffffffffb2d8f9f3\nRIP: 00007f4c4eda8985  RSP: 00007ffdbba9e9f8  RFLAGS: 00000246\nRAX: ffffffffffffffda  RBX: 000000000037e000  RCX: 00007f4c4eda8985\nRDX: 000000000037e000  RSI: 00007f4c41573000  RDI: 0000000000000003\nRBP: 000000000037e000   R8: 0000000000000000   R9: 000000000037fe30\nR10: 0000000000000000  R11: 0000000000000246  R12: 00007f4c41573000\nR13: 0000000000000003  R14: 00007f4c41572010  R15: 0000000000000003\nORIG_RAX: 0000000000000000  CS: 0033  SS: 002b\n\nCVE-2024-26958:\nIn the Linux kernel, the following vulnerability has been resolved:\nnfs: fix UAF in direct writes\nIn production we have been hitting the following warning consistently\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 17 PID: 1800359 at lib/refcount.c:28 refcount_warn_saturate+0x9c/0xe0\nWorkqueue: nfsiod nfs_direct_write_schedule_work [nfs]\nRIP: 0010:refcount_warn_saturate+0x9c/0xe0\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\n? __warn+0x9f/0x130\n? refcount_warn_saturate+0x9c/0xe0\n? report_bug+0xcc/0x150\n? handle_bug+0x3d/0x70\n? exc_invalid_op+0x16/0x40\n? asm_exc_invalid_op+0x16/0x20\n? refcount_warn_saturate+0x9c/0xe0\nnfs_direct_write_schedule_work+0x237/0x250 [nfs]\nprocess_one_work+0x12f/0x4a0\nworker_thread+0x14e/0x3b0\n? ZSTD_getCParams_internal+0x220/0x220\nkthread+0xdc/0x120\n? __btf_name_valid+0xa0/0xa0\nret_from_fork+0x1f/0x30\nThis is because we're completing the nfs_direct_request twice in a row.\nThe source of this is when we have our commit requests to submit, we\nprocess them and send them off, and then in the completion path for the\ncommit requests we have\nif (nfs_commit_end(cinfo.mds))\nnfs_direct_write_complete(dreq);\nHowever since we're submitting asynchronous requests we sometimes have\none that completes before we submit the next one, so we end up calling\ncomplete on the nfs_direct_request twice.\nThe only other place we use nfs_generic_commit_list() is in\n__nfs_commit_inode, which wraps this call in a\nnfs_commit_begin();\nnfs_commit_end();\nWhich is a common pattern for this style of completion handling, one\nthat is also repeated in the direct code with get_dreq()/put_dreq()\ncalls around where we process events as well as in the completion paths.\nFix this by using the same pattern for the commit requests.\nBefore with my 200 node rocksdb stress running this warning would pop\nevery 10ish minutes.  With my patch the stress test has been running for\nseveral hours without popping.\n\nCVE-2024-26960:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm: swap: fix race between free_swap_and_cache() and swapoff()\nThere was previously a theoretical window where swapoff() could run and\nteardown a swap_info_struct while a call to free_swap_and_cache() was\nrunning in another thread.  This could cause, amongst other bad\npossibilities, swap_page_trans_huge_swapped() (called by\nfree_swap_and_cache()) to access the freed memory for swap_map.\nThis is a theoretical problem and I haven't been able to provoke it from a\ntest case.  But there has been agreement based on code review that this is\npossible (see link below).\nFix it by using get_swap_device()/put_swap_device(), which will stall\nswapoff().  There was an extra check in _swap_info_get() to confirm that\nthe swap entry was not free.  This isn't present in get_swap_device()\nbecause it doesn't make sense in general due to the race between getting\nthe reference and swapoff.  So I've added an equivalent check directly in\nfree_swap_and_cache().\nDetails of how to provoke one possible issue (thanks to David Hildenbrand\nfor deriving this):\n--8\u003c-----\n__swap_entry_free() might be the last user and result in\n\"count == SWAP_HAS_CACHE\".\nswapoff-\u003etry_to_unuse() will stop as soon as soon as si-\u003einuse_pages==0.\nSo the question is: could someone reclaim the folio and turn\nsi-\u003einuse_pages==0, before we completed swap_page_trans_huge_swapped().\nImagine the following: 2 MiB folio in the swapcache. Only 2 subpages are\nstill references by swap entries.\nProcess 1 still references subpage 0 via swap entry.\nProcess 2 still references subpage 1 via swap entry.\nProcess 1 quits. Calls free_swap_and_cache().\n-\u003e count == SWAP_HAS_CACHE\n[then, preempted in the hypervisor etc.]\nProcess 2 quits. Calls free_swap_and_cache().\n-\u003e count == SWAP_HAS_CACHE\nProcess 2 goes ahead, passes swap_page_trans_huge_swapped(), and calls\n__try_to_reclaim_swap().\n__try_to_reclaim_swap()-\u003efolio_free_swap()-\u003edelete_from_swap_cache()-\u003e\nput_swap_folio()-\u003efree_swap_slot()-\u003eswapcache_free_entries()-\u003e\nswap_entry_free()-\u003eswap_range_free()-\u003e\n...\nWRITE_ONCE(si-\u003einuse_pages, si-\u003einuse_pages - nr_entries);\nWhat stops swapoff to succeed after process 2 reclaimed the swap cache\nbut before process1 finished its call to swap_page_trans_huge_swapped()?\n--8\u003c-----\n\nCVE-2024-26961:\nIn the Linux kernel, the following vulnerability has been resolved:\nmac802154: fix llsec key resources release in mac802154_llsec_key_del\nmac802154_llsec_key_del() can free resources of a key directly without\nfollowing the RCU rules for waiting before the end of a grace period. This\nmay lead to use-after-free in case llsec_lookup_key() is traversing the\nlist of keys in parallel with a key deletion:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 4 PID: 16000 at lib/refcount.c:25 refcount_warn_saturate+0x162/0x2a0\nModules linked in:\nCPU: 4 PID: 16000 Comm: wpan-ping Not tainted 6.7.0 #19\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nRIP: 0010:refcount_warn_saturate+0x162/0x2a0\nCall Trace:\n\u003cTASK\u003e\nllsec_lookup_key.isra.0+0x890/0x9e0\nmac802154_llsec_encrypt+0x30c/0x9c0\nieee802154_subif_start_xmit+0x24/0x1e0\ndev_hard_start_xmit+0x13e/0x690\nsch_direct_xmit+0x2ae/0xbc0\n__dev_queue_xmit+0x11dd/0x3c20\ndgram_sendmsg+0x90b/0xd60\n__sys_sendto+0x466/0x4c0\n__x64_sys_sendto+0xe0/0x1c0\ndo_syscall_64+0x45/0xf0\nentry_SYSCALL_64_after_hwframe+0x6e/0x76\nAlso, ieee802154_llsec_key_entry structures are not freed by\nmac802154_llsec_key_del():\nunreferenced object 0xffff8880613b6980 (size 64):\ncomm \"iwpan\", pid 2176, jiffies 4294761134 (age 60.475s)\nhex dump (first 32 bytes):\n78 0d 8f 18 80 88 ff ff 22 01 00 00 00 00 ad de  x.......\".......\n00 00 00 00 00 00 00 00 03 00 cd ab 00 00 00 00  ................\nbacktrace:\n[\u003cffffffff81dcfa62\u003e] __kmem_cache_alloc_node+0x1e2/0x2d0\n[\u003cffffffff81c43865\u003e] kmalloc_trace+0x25/0xc0\n[\u003cffffffff88968b09\u003e] mac802154_llsec_key_add+0xac9/0xcf0\n[\u003cffffffff8896e41a\u003e] ieee802154_add_llsec_key+0x5a/0x80\n[\u003cffffffff8892adc6\u003e] nl802154_add_llsec_key+0x426/0x5b0\n[\u003cffffffff86ff293e\u003e] genl_family_rcv_msg_doit+0x1fe/0x2f0\n[\u003cffffffff86ff46d1\u003e] genl_rcv_msg+0x531/0x7d0\n[\u003cffffffff86fee7a9\u003e] netlink_rcv_skb+0x169/0x440\n[\u003cffffffff86ff1d88\u003e] genl_rcv+0x28/0x40\n[\u003cffffffff86fec15c\u003e] netlink_unicast+0x53c/0x820\n[\u003cffffffff86fecd8b\u003e] netlink_sendmsg+0x93b/0xe60\n[\u003cffffffff86b91b35\u003e] ____sys_sendmsg+0xac5/0xca0\n[\u003cffffffff86b9c3dd\u003e] ___sys_sendmsg+0x11d/0x1c0\n[\u003cffffffff86b9c65a\u003e] __sys_sendmsg+0xfa/0x1d0\n[\u003cffffffff88eadbf5\u003e] do_syscall_64+0x45/0xf0\n[\u003cffffffff890000ea\u003e] entry_SYSCALL_64_after_hwframe+0x6e/0x76\nHandle the proper resource release in the RCU callback function\nmac802154_llsec_key_del_rcu().\nNote that if llsec_lookup_key() finds a key, it gets a refcount via\nllsec_key_get() and locally copies key id from key_entry (which is a\nlist element). So it's safe to call llsec_key_put() and free the list\nentry after the RCU grace period elapses.\nFound by Linux Verification Center (linuxtesting.org).\n\nCVE-2024-27010:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sched: Fix mirred deadlock on device recursion\nWhen the mirred action is used on a classful egress qdisc and a packet is\nmirrored or redirected to self we hit a qdisc lock deadlock.\nSee trace below.\n[..... other info removed for brevity....]\n[   82.890906]\n[   82.890906] ============================================\n[   82.890906] WARNING: possible recursive locking detected\n[   82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G        W\n[   82.890906] --------------------------------------------\n[   82.890906] ping/418 is trying to acquire lock:\n[   82.890906] ffff888006994110 (\u0026sch-\u003eq.lock){+.-.}-{3:3}, at:\n__dev_queue_xmit+0x1778/0x3550\n[   82.890906]\n[   82.890906] but task is already holding lock:\n[   82.890906] ffff888006994110 (\u0026sch-\u003eq.lock){+.-.}-{3:3}, at:\n__dev_queue_xmit+0x1778/0x3550\n[   82.890906]\n[   82.890906] other info that might help us debug this:\n[   82.890906]  Possible unsafe locking scenario:\n[   82.890906]\n[   82.890906]        CPU0\n[   82.890906]        ----\n[   82.890906]   lock(\u0026sch-\u003eq.lock);\n[   82.890906]   lock(\u0026sch-\u003eq.lock);\n[   82.890906]\n[   82.890906]  *** DEADLOCK ***\n[   82.890906]\n[..... other info removed for brevity....]\nExample setup (eth0-\u003eeth0) to recreate\ntc qdisc add dev eth0 root handle 1: htb default 30\ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\\naction mirred egress redirect dev eth0\nAnother example(eth0-\u003eeth1-\u003eeth0) to recreate\ntc qdisc add dev eth0 root handle 1: htb default 30\ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\\naction mirred egress redirect dev eth1\ntc qdisc add dev eth1 root handle 1: htb default 30\ntc filter add dev eth1 handle 1: protocol ip prio 2 matchall \\\naction mirred egress redirect dev eth0\nWe fix this by adding an owner field (CPU id) to struct Qdisc set after\nroot qdisc is entered. When the softirq enters it a second time, if the\nqdisc owner is the same CPU, the packet is dropped to break the loop.\n\nCVE-2024-27011:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: fix memleak in map from abort path\nThe delete set command does not rely on the transaction object for\nelement removal, therefore, a combination of delete element + delete set\nfrom the abort path could result in restoring twice the refcount of the\nmapping.\nCheck for inactive element in the next generation for the delete element\ncommand in the abort path, skip restoring state if next generation bit\nhas been already cleared. This is similar to the activate logic using\nthe set walk iterator.\n[ 6170.286929] ------------[ cut here ]------------\n[ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.287071] Modules linked in: [...]\n[ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365\n[ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 \u003c0f\u003e 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f\n[ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202\n[ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000\n[ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750\n[ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55\n[ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10\n[ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100\n[ 6170.287940] FS:  0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000\n[ 6170.287948] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0\n[ 6170.287962] Call Trace:\n[ 6170.287967]  \u003cTASK\u003e\n[ 6170.287973]  ? __warn+0x9f/0x1a0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1/0x1e0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1/0x1e0\n[ 6170.288104]  ? handle_bug+0x3c/0x70\n[ 6170.288112]  ? exc_invalid_op+0x17/0x40\n[ 6170.288120]  ? asm_exc_invalid_op+0x1a/0x20\n[ 6170.288132]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]\n[ 6170.288243]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288366]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]\n[ 6170.288483]  nf_tables_trans_destroy_work+0x588/0x590 [nf_tables]\n\nCVE-2024-27019:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: Fix potential data-race in __nft_obj_type_get()\nnft_unregister_obj() can concurrent with __nft_obj_type_get(),\nand there is not any protection when iterate over nf_tables_objects\nlist in __nft_obj_type_get(). Therefore, there is potential data-race\nof nf_tables_objects list entry.\nUse list_for_each_entry_rcu() to iterate over nf_tables_objects\nlist in __nft_obj_type_get(), and use rcu_read_lock() in the caller\nnft_obj_type_get() to protect the entire type query process.\n\nCVE-2024-27020:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: Fix potential data-race in __nft_expr_type_get()\nnft_unregister_expr() can concurrent with __nft_expr_type_get(),\nand there is not any protection when iterate over nf_tables_expressions\nlist in __nft_expr_type_get(). Therefore, there is potential data-race\nof nf_tables_expressions list entry.\nUse list_for_each_entry_rcu() to iterate over nf_tables_expressions\nlist in __nft_expr_type_get(), and use rcu_read_lock() in the caller\nnft_expr_type_get() to protect the entire type query process.\n\nCVE-2024-27025:\nIn the Linux kernel, the following vulnerability has been resolved:\nnbd: null check for nla_nest_start\nnla_nest_start() may fail and return NULL. Insert a check and set errno\nbased on other call sites within the same source code.\n\nCVE-2024-27065:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: do not compare internal table flags on updates\nRestore skipping transaction if table update does not modify flags.\n\nCVE-2024-27388:\nIn the Linux kernel, the following vulnerability has been resolved:\nSUNRPC: fix some memleaks in gssx_dec_option_array\nThe creds and oa-\u003edata need to be freed in the error-handling paths after\ntheir allocation. So this patch add these deallocations in the\ncorresponding paths.\n\nCVE-2024-27395:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: openvswitch: Fix Use-After-Free in ovs_ct_exit\nSince kfree_rcu, which is called in the hlist_for_each_entry_rcu traversal\nof ovs_ct_limit_exit, is not part of the RCU read critical section, it\nis possible that the RCU grace period will pass during the traversal and\nthe key will be free.\nTo prevent this, it should be changed to hlist_for_each_entry_safe.\n\nCVE-2024-27434:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: iwlwifi: mvm: don't set the MFP flag for the GTK\nThe firmware doesn't need the MFP flag for the GTK, it can even make the\nfirmware crash. in case the AP is configured with: group cipher TKIP and\nMFPC. We would send the GTK with cipher = TKIP and MFP which is of course\nnot possible.\n\nCVE-2024-31076:\nIn the Linux kernel, the following vulnerability has been resolved:\ngenirq/cpuhotplug, x86/vector: Prevent vector leak during CPU offline\nThe absence of IRQD_MOVE_PCNTXT prevents immediate effectiveness of\ninterrupt affinity reconfiguration via procfs. Instead, the change is\ndeferred until the next instance of the interrupt being triggered on the\noriginal CPU.\nWhen the interrupt next triggers on the original CPU, the new affinity is\nenforced within __irq_move_irq(). A vector is allocated from the new CPU,\nbut the old vector on the original CPU remains and is not immediately\nreclaimed. Instead, apicd-\u003emove_in_progress is flagged, and the reclaiming\nprocess is delayed until the next trigger of the interrupt on the new CPU.\nUpon the subsequent triggering of the interrupt on the new CPU,\nirq_complete_move() adds a task to the old CPU's vector_cleanup list if it\nremains online. Subsequently, the timer on the old CPU iterates over its\nvector_cleanup list, reclaiming old vectors.\nHowever, a rare scenario arises if the old CPU is outgoing before the\ninterrupt triggers again on the new CPU.\nIn that case irq_force_complete_move() is not invoked on the outgoing CPU\nto reclaim the old apicd-\u003eprev_vector because the interrupt isn't currently\naffine to the outgoing CPU, and irq_needs_fixup() returns false. Even\nthough __vector_schedule_cleanup() is later called on the new CPU, it\ndoesn't reclaim apicd-\u003eprev_vector; instead, it simply resets both\napicd-\u003emove_in_progress and apicd-\u003eprev_vector to 0.\nAs a result, the vector remains unreclaimed in vector_matrix, leading to a\nCPU vector leak.\nTo address this issue, move the invocation of irq_force_complete_move()\nbefore the irq_needs_fixup() call to reclaim apicd-\u003eprev_vector, if the\ninterrupt is currently or used to be affine to the outgoing CPU.\nAdditionally, reclaim the vector in __vector_schedule_cleanup() as well,\nfollowing a warning message, although theoretically it should never see\napicd-\u003emove_in_progress with apicd-\u003eprev_cpu pointing to an offline CPU.\n\nCVE-2024-33621:\nIn the Linux kernel, the following vulnerability has been resolved:\nipvlan: Dont Use skb-\u003esk in ipvlan_process_v{4,6}_outbound\nRaw packet from PF_PACKET socket ontop of an IPv6-backed ipvlan device will\nhit WARN_ON_ONCE() in sk_mc_loop() through sch_direct_xmit() path.\nWARNING: CPU: 2 PID: 0 at net/core/sock.c:775 sk_mc_loop+0x2d/0x70\nModules linked in: sch_netem ipvlan rfkill cirrus drm_shmem_helper sg drm_kms_helper\nCPU: 2 PID: 0 Comm: swapper/2 Kdump: loaded Not tainted 6.9.0+ #279\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nRIP: 0010:sk_mc_loop+0x2d/0x70\nCode: fa 0f 1f 44 00 00 65 0f b7 15 f7 96 a3 4f 31 c0 66 85 d2 75 26 48 85 ff 74 1c\nRSP: 0018:ffffa9584015cd78 EFLAGS: 00010212\nRAX: 0000000000000011 RBX: ffff91e585793e00 RCX: 0000000002c6a001\nRDX: 0000000000000000 RSI: 0000000000000040 RDI: ffff91e589c0f000\nRBP: ffff91e5855bd100 R08: 0000000000000000 R09: 3d00545216f43d00\nR10: ffff91e584fdcc50 R11: 00000060dd8616f4 R12: ffff91e58132d000\nR13: ffff91e584fdcc68 R14: ffff91e5869ce800 R15: ffff91e589c0f000\nFS:  0000000000000000(0000) GS:ffff91e898100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f788f7c44c0 CR3: 0000000008e1a000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\u003cIRQ\u003e\n? __warn (kernel/panic.c:693)\n? sk_mc_loop (net/core/sock.c:760)\n? report_bug (lib/bug.c:201 lib/bug.c:219)\n? handle_bug (arch/x86/kernel/traps.c:239)\n? exc_invalid_op (arch/x86/kernel/traps.c:260 (discriminator 1))\n? asm_exc_invalid_op (./arch/x86/include/asm/idtentry.h:621)\n? sk_mc_loop (net/core/sock.c:760)\nip6_finish_output2 (net/ipv6/ip6_output.c:83 (discriminator 1))\n? nf_hook_slow (net/netfilter/core.c:626)\nip6_finish_output (net/ipv6/ip6_output.c:222)\n? __pfx_ip6_finish_output (net/ipv6/ip6_output.c:215)\nipvlan_xmit_mode_l3 (drivers/net/ipvlan/ipvlan_core.c:602) ipvlan\nipvlan_start_xmit (drivers/net/ipvlan/ipvlan_main.c:226) ipvlan\ndev_hard_start_xmit (net/core/dev.c:3594)\nsch_direct_xmit (net/sched/sch_generic.c:343)\n__qdisc_run (net/sched/sch_generic.c:416)\nnet_tx_action (net/core/dev.c:5286)\nhandle_softirqs (kernel/softirq.c:555)\n__irq_exit_rcu (kernel/softirq.c:589)\nsysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1043)\nThe warning triggers as this:\npacket_sendmsg\npacket_snd //skb-\u003esk is packet sk\n__dev_queue_xmit\n__dev_xmit_skb //q-\u003eenqueue is not NULL\n__qdisc_run\nsch_direct_xmit\ndev_hard_start_xmit\nipvlan_start_xmit\nipvlan_xmit_mode_l3 //l3 mode\nipvlan_process_outbound //vepa flag\nipvlan_process_v6_outbound\nip6_local_out\n__ip6_finish_output\nip6_finish_output2 //multicast packet\nsk_mc_loop //sk-\u003esk_family is AF_PACKET\nCall ip{6}_local_out() with NULL sk in ipvlan as other tunnels to fix this.\n\nCVE-2024-35790:\nIn the Linux kernel, the following vulnerability has been resolved:\nusb: typec: altmodes/displayport: create sysfs nodes as driver's default device attribute group\nThe DisplayPort driver's sysfs nodes may be present to the userspace before\ntypec_altmode_set_drvdata() completes in dp_altmode_probe. This means that\na sysfs read can trigger a NULL pointer error by deferencing dp-\u003ehpd in\nhpd_show or dp-\u003elock in pin_assignment_show, as dev_get_drvdata() returns\nNULL in those cases.\nRemove manual sysfs node creation in favor of adding attribute group as\ndefault for devices bound to the driver. The ATTRIBUTE_GROUPS() macro is\nnot used here otherwise the path to the sysfs nodes is no longer compliant\nwith the ABI.\n\nCVE-2024-35801:\nIn the Linux kernel, the following vulnerability has been resolved:\nx86/fpu: Keep xfd_state in sync with MSR_IA32_XFD\nCommit 672365477ae8 (\"x86/fpu: Update XFD state where required\") and\ncommit 8bf26758ca96 (\"x86/fpu: Add XFD state to fpstate\") introduced a\nper CPU variable xfd_state to keep the MSR_IA32_XFD value cached, in\norder to avoid unnecessary writes to the MSR.\nOn CPU hotplug MSR_IA32_XFD is reset to the init_fpstate.xfd, which\nwipes out any stale state. But the per CPU cached xfd value is not\nreset, which brings them out of sync.\nAs a consequence a subsequent xfd_update_state() might fail to update\nthe MSR which in turn can result in XRSTOR raising a #NM in kernel\nspace, which crashes the kernel.\nTo fix this, introduce xfd_set_state() to write xfd_state together\nwith MSR_IA32_XFD, and use it in all places that set MSR_IA32_XFD.\n\nCVE-2024-35807:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: fix corruption during on-line resize\nWe observed a corruption during on-line resize of a file system that is\nlarger than 16 TiB with 4k block size. With having more then 2^32 blocks\nresize_inode is turned off by default by mke2fs. The issue can be\nreproduced on a smaller file system for convenience by explicitly\nturning off resize_inode. An on-line resize across an 8 GiB boundary (the\nsize of a meta block group in this setup) then leads to a corruption:\ndev=/dev/\u003csome_dev\u003e # should be \u003e= 16 GiB\nmkdir -p /corruption\n/sbin/mke2fs -t ext4 -b 4096 -O ^resize_inode $dev $((2 * 2**21 - 2**15))\nmount -t ext4 $dev /corruption\ndd if=/dev/zero bs=4096 of=/corruption/test count=$((2*2**21 - 4*2**15))\nsha1sum /corruption/test\n# 79d2658b39dcfd77274e435b0934028adafaab11  /corruption/test\n/sbin/resize2fs $dev $((2*2**21))\n# drop page cache to force reload the block from disk\necho 1 \u003e /proc/sys/vm/drop_caches\nsha1sum /corruption/test\n# 3c2abc63cbf1a94c9e6977e0fbd72cd832c4d5c3  /corruption/test\n2^21 = 2^15*2^6 equals 8 GiB whereof 2^15 is the number of blocks per\nblock group and 2^6 are the number of block groups that make a meta\nblock group.\nThe last checksum might be different depending on how the file is laid\nout across the physical blocks. The actual corruption occurs at physical\nblock 63*2^15 = 2064384 which would be the location of the backup of the\nmeta block group's block descriptor. During the on-line resize the file\nsystem will be converted to meta_bg starting at s_first_meta_bg which is\n2 in the example - meaning all block groups after 16 GiB. However, in\next4_flex_group_add we might add block groups that are not part of the\nfirst meta block group yet. In the reproducer we achieved this by\nsubstracting the size of a whole block group from the point where the\nmeta block group would start. This must be considered when updating the\nbackup block group descriptors to follow the non-meta_bg layout. The fix\nis to add a test whether the group to add is already part of the meta\nblock group or not.\n\nCVE-2024-35810:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Fix the lifetime of the bo cursor memory\nThe cleanup can be dispatched while the atomic update is still active,\nwhich means that the memory acquired in the atomic update needs to\nnot be invalidated by the cleanup. The buffer objects in vmw_plane_state\ninstead of using the builtin map_and_cache were trying to handle\nthe lifetime of the mapped memory themselves, leading to crashes.\nUse the map_and_cache instead of trying to manage the lifetime of the\nbuffer objects held by the vmw_plane_state.\nFixes kernel oops'es in IGT's kms_cursor_legacy forked-bo.\n\nCVE-2024-35814:\nIn the Linux kernel, the following vulnerability has been resolved:\nswiotlb: Fix double-allocation of slots due to broken alignment handling\nCommit bbb73a103fbb (\"swiotlb: fix a braino in the alignment check fix\"),\nwhich was a fix for commit 0eee5ae10256 (\"swiotlb: fix slot alignment\nchecks\"), causes a functional regression with vsock in a virtual machine\nusing bouncing via a restricted DMA SWIOTLB pool.\nWhen virtio allocates the virtqueues for the vsock device using\ndma_alloc_coherent(), the SWIOTLB search can return page-unaligned\nallocations if 'area-\u003eindex' was left unaligned by a previous allocation\nfrom the buffer:\n# Final address in brackets is the SWIOTLB address returned to the caller\n| virtio-pci 0000:00:07.0: orig_addr 0x0 alloc_size 0x2000, iotlb_align_mask 0x800 stride 0x2: got slot 1645-1649/7168 (0x98326800)\n| virtio-pci 0000:00:07.0: orig_addr 0x0 alloc_size 0x2000, iotlb_align_mask 0x800 stride 0x2: got slot 1649-1653/7168 (0x98328800)\n| virtio-pci 0000:00:07.0: orig_addr 0x0 alloc_size 0x2000, iotlb_align_mask 0x800 stride 0x2: got slot 1653-1657/7168 (0x9832a800)\nThis ends badly (typically buffer corruption and/or a hang) because\nswiotlb_alloc() is expecting a page-aligned allocation and so blindly\nreturns a pointer to the 'struct page' corresponding to the allocation,\ntherefore double-allocating the first half (2KiB slot) of the 4KiB page.\nFix the problem by treating the allocation alignment separately to any\nadditional alignment requirements from the device, using the maximum\nof the two as the stride to search the buffer slots and taking care\nto ensure a minimum of page-alignment for buffers larger than a page.\nThis also resolves swiotlb allocation failures occuring due to the\ninclusion of ~PAGE_MASK in 'iotlb_align_mask' for large allocations and\nresulting in alignment requirements exceeding swiotlb_max_mapping_size().\n\nCVE-2024-35823:\nIn the Linux kernel, the following vulnerability has been resolved:\nvt: fix unicode buffer corruption when deleting characters\nThis is the same issue that was fixed for the VGA text buffer in commit\n39cdb68c64d8 (\"vt: fix memory overlapping when deleting chars in the\nbuffer\"). The cure is also the same i.e. replace memcpy() with memmove()\ndue to the overlaping buffers.\n\nCVE-2024-35824:\nIn the Linux kernel, the following vulnerability has been resolved:\nmisc: lis3lv02d_i2c: Fix regulators getting en-/dis-abled twice on suspend/resume\nWhen not configured for wakeup lis3lv02d_i2c_suspend() will call\nlis3lv02d_poweroff() even if the device has already been turned off\nby the runtime-suspend handler and if configured for wakeup and\nthe device is runtime-suspended at this point then it is not turned\nback on to serve as a wakeup source.\nBefore commit b1b9f7a49440 (\"misc: lis3lv02d_i2c: Add missing setting\nof the reg_ctrl callback\"), lis3lv02d_poweroff() failed to disable\nthe regulators which as a side effect made calling poweroff() twice ok.\nNow that poweroff() correctly disables the regulators, doing this twice\ntriggers a WARN() in the regulator core:\nunbalanced disables for regulator-dummy\nWARNING: CPU: 1 PID: 92 at drivers/regulator/core.c:2999 _regulator_disable\n...\nFix lis3lv02d_i2c_suspend() to not call poweroff() a second time if\nalready runtime-suspended and add a poweron() call when necessary to\nmake wakeup work.\nlis3lv02d_i2c_resume() has similar issues, with an added weirness that\nit always powers on the device if it is runtime suspended, after which\nthe first runtime-resume will call poweron() again, causing the enabled\ncount for the regulator to increase by 1 every suspend/resume. These\nunbalanced regulator_enable() calls cause the regulator to never\nbe turned off and trigger the following WARN() on driver unbind:\nWARNING: CPU: 1 PID: 1724 at drivers/regulator/core.c:2396 _regulator_put\nFix this by making lis3lv02d_i2c_resume() mirror the new suspend().\n\nCVE-2024-35847:\nIn the Linux kernel, the following vulnerability has been resolved:\nirqchip/gic-v3-its: Prevent double free on error\nThe error handling path in its_vpe_irq_domain_alloc() causes a double free\nwhen its_vpe_init() fails after successfully allocating at least one\ninterrupt. This happens because its_vpe_irq_domain_free() frees the\ninterrupts along with the area bitmap and the vprop_page and\nits_vpe_irq_domain_alloc() subsequently frees the area bitmap and the\nvprop_page again.\nFix this by unconditionally invoking its_vpe_irq_domain_free() which\nhandles all cases correctly and by removing the bitmap/vprop_page freeing\nfrom its_vpe_irq_domain_alloc().\n[ tglx: Massaged change log ]\n\nCVE-2024-35876:\nThis CVE ID has been rejected or withdrawn by its CVE Numbering Authority for the following reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.\n\nCVE-2024-35893:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/sched: act_skbmod: prevent kernel-infoleak\nsyzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to user space [1].\nThe issue here is that 'struct tc_skbmod' has a four bytes hole.\nWe need to clear the structure before filling fields.\n[1]\nBUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\nBUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\nBUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\nBUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\nBUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271 [inline]\nBUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\ninstrument_copy_to_user include/linux/instrumented.h:114 [inline]\ncopy_to_user_iter lib/iov_iter.c:24 [inline]\niterate_ubuf include/linux/iov_iter.h:29 [inline]\niterate_and_advance2 include/linux/iov_iter.h:245 [inline]\niterate_and_advance include/linux/iov_iter.h:271 [inline]\n_copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\ncopy_to_iter include/linux/uio.h:196 [inline]\nsimple_copy_to_iter net/core/datagram.c:532 [inline]\n__skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\nskb_copy_datagram_iter+0x5c/0x200 net/core/datagram.c:546\nskb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\nnetlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\nsock_recvmsg_nosec net/socket.c:1046 [inline]\nsock_recvmsg+0x2c4/0x340 net/socket.c:1068\n__sys_recvfrom+0x35a/0x5f0 net/socket.c:2242\n__do_sys_recvfrom net/socket.c:2260 [inline]\n__se_sys_recvfrom net/socket.c:2256 [inline]\n__x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\ndo_syscall_64+0xd5/0x1f0\nentry_SYSCALL_64_after_hwframe+0x6d/0x75\nUninit was stored to memory at:\npskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\nnetlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\nnetlink_unicast+0x9f/0x1260 net/netlink/af_netlink.c:1351\nnlmsg_unicast include/net/netlink.h:1144 [inline]\nnlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\nrtnetlink_send+0x73/0x90 net/core/rtnetlink.c:741\nrtnetlink_maybe_send include/linux/rtnetlink.h:17 [inline]\ntcf_add_notify net/sched/act_api.c:2048 [inline]\ntcf_action_add net/sched/act_api.c:2071 [inline]\ntc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\nrtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\nnetlink_rcv_skb+0x375/0x650 net/netlink/af_netlink.c:2559\nrtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\nnetlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\nnetlink_unicast+0xf4c/0x1260 net/netlink/af_netlink.c:1361\nnetlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg+0x30f/0x380 net/socket.c:745\n____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n__sys_sendmsg net/socket.c:2667 [inline]\n__do_sys_sendmsg net/socket.c:2676 [inline]\n__se_sys_sendmsg net/socket.c:2674 [inline]\n__x64_sys_sendmsg+0x307/0x4a0 net/socket.c:2674\ndo_syscall_64+0xd5/0x1f0\nentry_SYSCALL_64_after_hwframe+0x6d/0x75\nUninit was stored to memory at:\n__nla_put lib/nlattr.c:1041 [inline]\nnla_put+0x1c6/0x230 lib/nlattr.c:1099\ntcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\ntcf_action_dump_old net/sched/act_api.c:1191 [inline]\ntcf_action_dump_1+0x85e/0x970 net/sched/act_api.c:1227\ntcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\ntca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\ntcf_add_notify_msg net/sched/act_api.c:2023 [inline]\ntcf_add_notify net/sched/act_api.c:2042 [inline]\ntcf_action_add net/sched/act_api.c:2071 [inline]\ntc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\nrtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\nnetlink_rcv_skb+0x375/0x650 net/netlink/af_netli\n---truncated---\n\nCVE-2024-35896:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: validate user input for expected length\nI got multiple syzbot reports showing old bugs exposed\nby BPF after commit 20f2505fb436 (\"bpf: Try to avoid kzalloc\nin cgroup/{s,g}etsockopt\")\nsetsockopt() @optlen argument should be taken into account\nbefore copying data.\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in do_replace net/ipv4/netfilter/ip_tables.c:1111 [inline]\nBUG: KASAN: slab-out-of-bounds in do_ipt_set_ctl+0x902/0x3dd0 net/ipv4/netfilter/ip_tables.c:1627\nRead of size 96 at addr ffff88802cd73da0 by task syz-executor.4/7238\nCPU: 1 PID: 7238 Comm: syz-executor.4 Not tainted 6.9.0-rc2-next-20240403-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n\u003cTASK\u003e\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\nprint_address_description mm/kasan/report.c:377 [inline]\nprint_report+0x169/0x550 mm/kasan/report.c:488\nkasan_report+0x143/0x180 mm/kasan/report.c:601\nkasan_check_range+0x282/0x290 mm/kasan/generic.c:189\n__asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105\ncopy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\ncopy_from_sockptr include/linux/sockptr.h:55 [inline]\ndo_replace net/ipv4/netfilter/ip_tables.c:1111 [inline]\ndo_ipt_set_ctl+0x902/0x3dd0 net/ipv4/netfilter/ip_tables.c:1627\nnf_setsockopt+0x295/0x2c0 net/netfilter/nf_sockopt.c:101\ndo_sock_setsockopt+0x3af/0x720 net/socket.c:2311\n__sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n__do_sys_setsockopt net/socket.c:2343 [inline]\n__se_sys_setsockopt net/socket.c:2340 [inline]\n__x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\ndo_syscall_64+0xfb/0x240\nentry_SYSCALL_64_after_hwframe+0x72/0x7a\nRIP: 0033:0x7fd22067dde9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fd21f9ff0c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 00007fd2207abf80 RCX: 00007fd22067dde9\nRDX: 0000000000000040 RSI: 0000000000000000 RDI: 0000000000000003\nRBP: 00007fd2206ca47a R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000020000880 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007fd2207abf80 R15: 00007ffd2d0170d8\n\u003c/TASK\u003e\nAllocated by task 7238:\nkasan_save_stack mm/kasan/common.c:47 [inline]\nkasan_save_track+0x3f/0x80 mm/kasan/common.c:68\npoison_kmalloc_redzone mm/kasan/common.c:370 [inline]\n__kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:387\nkasan_kmalloc include/linux/kasan.h:211 [inline]\n__do_kmalloc_node mm/slub.c:4069 [inline]\n__kmalloc_noprof+0x200/0x410 mm/slub.c:4082\nkmalloc_noprof include/linux/slab.h:664 [inline]\n__cgroup_bpf_run_filter_setsockopt+0xd47/0x1050 kernel/bpf/cgroup.c:1869\ndo_sock_setsockopt+0x6b4/0x720 net/socket.c:2293\n__sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n__do_sys_setsockopt net/socket.c:2343 [inline]\n__se_sys_setsockopt net/socket.c:2340 [inline]\n__x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\ndo_syscall_64+0xfb/0x240\nentry_SYSCALL_64_after_hwframe+0x72/0x7a\nThe buggy address belongs to the object at ffff88802cd73da0\nwhich belongs to the cache kmalloc-8 of size 8\nThe buggy address is located 0 bytes inside of\nallocated 1-byte region [ffff88802cd73da0, ffff88802cd73da1)\nThe buggy address belongs to the physical page:\npage: refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff88802cd73020 pfn:0x2cd73\nflags: 0xfff80000000000(node=0|zone=1|lastcpupid=0xfff)\npage_type: 0xffffefff(slab)\nraw: 00fff80000000000 ffff888015041280 dead000000000100 dead000000000122\nraw: ffff88802cd73020 000000008080007f 00000001ffffefff 00\n---truncated---\n\nCVE-2024-35897:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: discard table flag update with pending basechain deletion\nHook unregistration is deferred to the commit phase, same occurs with\nhook updates triggered by the table dormant flag. When both commands are\ncombined, this results in deleting a basechain while leaving its hook\nstill registered in the core.\n\nCVE-2024-35899:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: flush pending destroy work before exit_net release\nSimilar to 2c9f0293280e (\"netfilter: nf_tables: flush pending destroy\nwork before netlink notifier\") to address a race between exit_net and\nthe destroy workqueue.\nThe trace below shows an element to be released via destroy workqueue\nwhile exit_net path (triggered via module removal) has already released\nthe set that is used in such transaction.\n[ 1360.547789] BUG: KASAN: slab-use-after-free in nf_tables_trans_destroy_work+0x3f5/0x590 [nf_tables]\n[ 1360.547861] Read of size 8 at addr ffff888140500cc0 by task kworker/4:1/152465\n[ 1360.547870] CPU: 4 PID: 152465 Comm: kworker/4:1 Not tainted 6.8.0+ #359\n[ 1360.547882] Workqueue: events nf_tables_trans_destroy_work [nf_tables]\n[ 1360.547984] Call Trace:\n[ 1360.547991]  \u003cTASK\u003e\n[ 1360.547998]  dump_stack_lvl+0x53/0x70\n[ 1360.548014]  print_report+0xc4/0x610\n[ 1360.548026]  ? __virt_addr_valid+0xba/0x160\n[ 1360.548040]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[ 1360.548054]  ? nf_tables_trans_destroy_work+0x3f5/0x590 [nf_tables]\n[ 1360.548176]  kasan_report+0xae/0xe0\n[ 1360.548189]  ? nf_tables_trans_destroy_work+0x3f5/0x590 [nf_tables]\n[ 1360.548312]  nf_tables_trans_destroy_work+0x3f5/0x590 [nf_tables]\n[ 1360.548447]  ? __pfx_nf_tables_trans_destroy_work+0x10/0x10 [nf_tables]\n[ 1360.548577]  ? _raw_spin_unlock_irq+0x18/0x30\n[ 1360.548591]  process_one_work+0x2f1/0x670\n[ 1360.548610]  worker_thread+0x4d3/0x760\n[ 1360.548627]  ? __pfx_worker_thread+0x10/0x10\n[ 1360.548640]  kthread+0x16b/0x1b0\n[ 1360.548653]  ? __pfx_kthread+0x10/0x10\n[ 1360.548665]  ret_from_fork+0x2f/0x50\n[ 1360.548679]  ? __pfx_kthread+0x10/0x10\n[ 1360.548690]  ret_from_fork_asm+0x1a/0x30\n[ 1360.548707]  \u003c/TASK\u003e\n[ 1360.548719] Allocated by task 192061:\n[ 1360.548726]  kasan_save_stack+0x20/0x40\n[ 1360.548739]  kasan_save_track+0x14/0x30\n[ 1360.548750]  __kasan_kmalloc+0x8f/0xa0\n[ 1360.548760]  __kmalloc_node+0x1f1/0x450\n[ 1360.548771]  nf_tables_newset+0x10c7/0x1b50 [nf_tables]\n[ 1360.548883]  nfnetlink_rcv_batch+0xbc4/0xdc0 [nfnetlink]\n[ 1360.548909]  nfnetlink_rcv+0x1a8/0x1e0 [nfnetlink]\n[ 1360.548927]  netlink_unicast+0x367/0x4f0\n[ 1360.548935]  netlink_sendmsg+0x34b/0x610\n[ 1360.548944]  ____sys_sendmsg+0x4d4/0x510\n[ 1360.548953]  ___sys_sendmsg+0xc9/0x120\n[ 1360.548961]  __sys_sendmsg+0xbe/0x140\n[ 1360.548971]  do_syscall_64+0x55/0x120\n[ 1360.548982]  entry_SYSCALL_64_after_hwframe+0x55/0x5d\n[ 1360.548994] Freed by task 192222:\n[ 1360.548999]  kasan_save_stack+0x20/0x40\n[ 1360.549009]  kasan_save_track+0x14/0x30\n[ 1360.549019]  kasan_save_free_info+0x3b/0x60\n[ 1360.549028]  poison_slab_object+0x100/0x180\n[ 1360.549036]  __kasan_slab_free+0x14/0x30\n[ 1360.549042]  kfree+0xb6/0x260\n[ 1360.549049]  __nft_release_table+0x473/0x6a0 [nf_tables]\n[ 1360.549131]  nf_tables_exit_net+0x170/0x240 [nf_tables]\n[ 1360.549221]  ops_exit_list+0x50/0xa0\n[ 1360.549229]  free_exit_list+0x101/0x140\n[ 1360.549236]  unregister_pernet_operations+0x107/0x160\n[ 1360.549245]  unregister_pernet_subsys+0x1c/0x30\n[ 1360.549254]  nf_tables_module_exit+0x43/0x80 [nf_tables]\n[ 1360.549345]  __do_sys_delete_module+0x253/0x370\n[ 1360.549352]  do_syscall_64+0x55/0x120\n[ 1360.549360]  entry_SYSCALL_64_after_hwframe+0x55/0x5d\n(gdb) list *__nft_release_table+0x473\n0x1e033 is in __nft_release_table (net/netfilter/nf_tables_api.c:11354).\n11349           list_for_each_entry_safe(flowtable, nf, \u0026table-\u003eflowtables, list) {\n11350                   list_del(\u0026flowtable-\u003elist);\n11351                   nft_use_dec(\u0026table-\u003euse);\n11352                   nf_tables_flowtable_destroy(flowtable);\n11353           }\n11354           list_for_each_entry_safe(set, ns, \u0026table-\u003esets, list) {\n11355                   list_del(\u0026set-\u003elist);\n11356                   nft_use_dec(\u0026table-\u003euse);\n11357                   if (set-\u003eflags \u0026 (NFT_SET_MAP | NFT_SET_OBJECT))\n11358                           nft_map_deactivat\n---truncated---\n\nCVE-2024-35900:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: reject new basechain after table flag update\nWhen dormant flag is toggled, hooks are disabled in the commit phase by\niterating over current chains in table (existing and new).\nThe following configuration allows for an inconsistent state:\nadd table x\nadd chain x y { type filter hook input priority 0; }\nadd table x { flags dormant; }\nadd chain x w { type filter hook input priority 1; }\nwhich triggers the following warning when trying to unregister chain w\nwhich is already unregistered.\n[  127.322252] WARNING: CPU: 7 PID: 1211 at net/netfilter/core.c:50                                                                     1 __nf_unregister_net_hook+0x21a/0x260\n[...]\n[  127.322519] Call Trace:\n[  127.322521]  \u003cTASK\u003e\n[  127.322524]  ? __warn+0x9f/0x1a0\n[  127.322531]  ? __nf_unregister_net_hook+0x21a/0x260\n[  127.322537]  ? report_bug+0x1b1/0x1e0\n[  127.322545]  ? handle_bug+0x3c/0x70\n[  127.322552]  ? exc_invalid_op+0x17/0x40\n[  127.322556]  ? asm_exc_invalid_op+0x1a/0x20\n[  127.322563]  ? kasan_save_free_info+0x3b/0x60\n[  127.322570]  ? __nf_unregister_net_hook+0x6a/0x260\n[  127.322577]  ? __nf_unregister_net_hook+0x21a/0x260\n[  127.322583]  ? __nf_unregister_net_hook+0x6a/0x260\n[  127.322590]  ? __nf_tables_unregister_hook+0x8a/0xe0 [nf_tables]\n[  127.322655]  nft_table_disable+0x75/0xf0 [nf_tables]\n[  127.322717]  nf_tables_commit+0x2571/0x2620 [nf_tables]\n\nCVE-2024-35910:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: properly terminate timers for kernel sockets\nWe had various syzbot reports about tcp timers firing after\nthe corresponding netns has been dismantled.\nFortunately Josef Bacik could trigger the issue more often,\nand could test a patch I wrote two years ago.\nWhen TCP sockets are closed, we call inet_csk_clear_xmit_timers()\nto 'stop' the timers.\ninet_csk_clear_xmit_timers() can be called from any context,\nincluding when socket lock is held.\nThis is the reason it uses sk_stop_timer(), aka del_timer().\nThis means that ongoing timers might finish much later.\nFor user sockets, this is fine because each running timer\nholds a reference on the socket, and the user socket holds\na reference on the netns.\nFor kernel sockets, we risk that the netns is freed before\ntimer can complete, because kernel sockets do not hold\nreference on the netns.\nThis patch adds inet_csk_clear_xmit_timers_sync() function\nthat using sk_stop_timer_sync() to make sure all timers\nare terminated before the kernel socket is released.\nModules using kernel sockets close them in their netns exit()\nhandler.\nAlso add sock_not_owned_by_me() helper to get LOCKDEP\nsupport : inet_csk_clear_xmit_timers_sync() must not be called\nwhile socket lock is held.\nIt is very possible we can revert in the future commit\n3a58f13a881e (\"net: rds: acquire refcount on TCP sockets\")\nwhich attempted to solve the issue in rds only.\n(net/smc/af_smc.c and net/mptcp/subflow.c have similar code)\nWe probably can remove the check_net() tests from\ntcp_out_of_resources() and __tcp_close() in the future.\n\nCVE-2024-35912:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: iwlwifi: mvm: rfi: fix potential response leaks\nIf the rx payload length check fails, or if kmemdup() fails,\nwe still need to free the command response. Fix that.\n\nCVE-2024-35924:\nIn the Linux kernel, the following vulnerability has been resolved:\nusb: typec: ucsi: Limit read size on v1.2\nBetween UCSI 1.2 and UCSI 2.0, the size of the MESSAGE_IN region was\nincreased from 16 to 256. In order to avoid overflowing reads for older\nsystems, add a mechanism to use the read UCSI version to truncate read\nsizes on UCSI v1.2.\n\nCVE-2024-35925:\nIn the Linux kernel, the following vulnerability has been resolved:\nblock: prevent division by zero in blk_rq_stat_sum()\nThe expression dst-\u003enr_samples + src-\u003enr_samples may\nhave zero value on overflow. It is necessary to add\na check to avoid division by zero.\nFound by Linux Verification Center (linuxtesting.org) with Svace.\n\nCVE-2024-35930:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Fix possible memory leak in lpfc_rcv_padisc()\nThe call to lpfc_sli4_resume_rpi() in lpfc_rcv_padisc() may return an\nunsuccessful status.  In such cases, the elsiocb is not issued, the\ncompletion is not called, and thus the elsiocb resource is leaked.\nCheck return value after calling lpfc_sli4_resume_rpi() and conditionally\nrelease the elsiocb resource.\n\nCVE-2024-35937:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: cfg80211: check A-MSDU format more carefully\nIf it looks like there's another subframe in the A-MSDU\nbut the header isn't fully there, we can end up reading\ndata out of bounds, only to discard later. Make this a\nbit more careful and check if the subframe header can\neven be present.\n\nCVE-2024-35938:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: ath11k: decrease MHI channel buffer length to 8KB\nCurrently buf_len field of ath11k_mhi_config_qca6390 is assigned\nwith 0, making MHI use a default size, 64KB, to allocate channel\nbuffers. This is likely to fail in some scenarios where system\nmemory is highly fragmented and memory compaction or reclaim is\nnot allowed.\nThere is a fail report which is caused by it:\nkworker/u32:45: page allocation failure: order:4, mode:0x40c00(GFP_NOIO|__GFP_COMP), nodemask=(null),cpuset=/,mems_allowed=0\nCPU: 0 PID: 19318 Comm: kworker/u32:45 Not tainted 6.8.0-rc3-1.gae4495f-default #1 openSUSE Tumbleweed (unreleased) 493b6d5b382c603654d7a81fc3c144d59a1dfceb\nWorkqueue: events_unbound async_run_entry_fn\nCall Trace:\n\u003cTASK\u003e\ndump_stack_lvl+0x47/0x60\nwarn_alloc+0x13a/0x1b0\n? srso_alias_return_thunk+0x5/0xfbef5\n? __alloc_pages_direct_compact+0xab/0x210\n__alloc_pages_slowpath.constprop.0+0xd3e/0xda0\n__alloc_pages+0x32d/0x350\n? mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n__kmalloc_large_node+0x72/0x110\n__kmalloc+0x37c/0x480\n? mhi_map_single_no_bb+0x77/0xf0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n? mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\nmhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n__mhi_prepare_for_transfer+0x44/0x80 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\n? __pfx_____mhi_prepare_for_transfer+0x10/0x10 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]\ndevice_for_each_child+0x5c/0xa0\n? __pfx_pci_pm_resume+0x10/0x10\nath11k_core_resume+0x65/0x100 [ath11k a5094e22d7223135c40d93c8f5321cf09fd85e4e]\n? srso_alias_return_thunk+0x5/0xfbef5\nath11k_pci_pm_resume+0x32/0x60 [ath11k_pci 830b7bfc3ea80ebef32e563cafe2cb55e9cc73ec]\n? srso_alias_return_thunk+0x5/0xfbef5\ndpm_run_callback+0x8c/0x1e0\ndevice_resume+0x104/0x340\n? __pfx_dpm_watchdog_handler+0x10/0x10\nasync_resume+0x1d/0x30\nasync_run_entry_fn+0x32/0x120\nprocess_one_work+0x168/0x330\nworker_thread+0x2f5/0x410\n? __pfx_worker_thread+0x10/0x10\nkthread+0xe8/0x120\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x34/0x50\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1b/0x30\n\u003c/TASK\u003e\nActually those buffers are used only by QMI target -\u003e host communication.\nAnd for WCN6855 and QCA6390, the largest packet size for that is less\nthan 6KB. So change buf_len field to 8KB, which results in order 1\nallocation if page size is 4KB. In this way, we can at least save some\nmemory, and as well as decrease the possibility of allocation failure\nin those scenarios.\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30\n\nCVE-2024-35946:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: rtw89: fix null pointer access when abort scan\nDuring cancel scan we might use vif that weren't scanning.\nFix this by using the actual scanning vif.\n\nCVE-2024-35947:\nIn the Linux kernel, the following vulnerability has been resolved:\ndyndbg: fix old BUG_ON in \u003econtrol parser\nFix a BUG_ON from 2009.  Even if it looks \"unreachable\" (I didn't\nreally look), lets make sure by removing it, doing pr_err and return\n-EINVAL instead.\n\nCVE-2024-35952:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/ast: Fix soft lockup\nThere is a while-loop in ast_dp_set_on_off() that could lead to\ninfinite-loop. This is because the register, VGACRI-Dx, checked in\nthis API is a scratch register actually controlled by a MCU, named\nDPMCU, in BMC.\nThese scratch registers are protected by scu-lock. If suc-lock is not\noff, DPMCU can not update these registers and then host will have soft\nlockup due to never updated status.\nDPMCU is used to control DP and relative registers to handshake with\nhost's VGA driver. Even the most time-consuming task, DP's link\ntraining, is less than 100ms. 200ms should be enough.\n\nCVE-2024-36000:\nIn the Linux kernel, the following vulnerability has been resolved:\nmm/hugetlb: fix missing hugetlb_lock for resv uncharge\nThere is a recent report on UFFDIO_COPY over hugetlb:\nhttps://lore.kernel.org/all/000000000000ee06de0616177560@google.com/\n350:lockdep_assert_held(\u0026hugetlb_lock);\nShould be an issue in hugetlb but triggered in an userfault context, where\nit goes into the unlikely path where two threads modifying the resv map\ntogether.  Mike has a fix in that path for resv uncharge but it looks like\nthe locking criteria was overlooked: hugetlb_cgroup_uncharge_folio_rsvd()\nwill update the cgroup pointer, so it requires to be called with the lock\nheld.\n\nCVE-2024-36005:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nf_tables: honor table dormant flag from netdev release event path\nCheck for table dormant flag otherwise netdev release event path tries\nto unregister an already unregistered hook.\n[524854.857999] ------------[ cut here ]------------\n[524854.858010] WARNING: CPU: 0 PID: 3386599 at net/netfilter/core.c:501 __nf_unregister_net_hook+0x21a/0x260\n[...]\n[524854.858848] CPU: 0 PID: 3386599 Comm: kworker/u32:2 Not tainted 6.9.0-rc3+ #365\n[524854.858869] Workqueue: netns cleanup_net\n[524854.858886] RIP: 0010:__nf_unregister_net_hook+0x21a/0x260\n[524854.858903] Code: 24 e8 aa 73 83 ff 48 63 43 1c 83 f8 01 0f 85 3d ff ff ff e8 98 d1 f0 ff 48 8b 3c 24 e8 8f 73 83 ff 48 63 43 1c e9 26 ff ff ff \u003c0f\u003e 0b 48 83 c4 18 48 c7 c7 00 68 e9 82 5b 5d 41 5c 41 5d 41 5e 41\n[524854.858914] RSP: 0018:ffff8881e36d79e0 EFLAGS: 00010246\n[524854.858926] RAX: 0000000000000000 RBX: ffff8881339ae790 RCX: ffffffff81ba524a\n[524854.858936] RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff8881c8a16438\n[524854.858945] RBP: ffff8881c8a16438 R08: 0000000000000001 R09: ffffed103c6daf34\n[524854.858954] R10: ffff8881e36d79a7 R11: 0000000000000000 R12: 0000000000000005\n[524854.858962] R13: ffff8881c8a16000 R14: 0000000000000000 R15: ffff8881351b5a00\n[524854.858971] FS:  0000000000000000(0000) GS:ffff888390800000(0000) knlGS:0000000000000000\n[524854.858982] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[524854.858991] CR2: 00007fc9be0f16f4 CR3: 00000001437cc004 CR4: 00000000001706f0\n[524854.859000] Call Trace:\n[524854.859006]  \u003cTASK\u003e\n[524854.859013]  ? __warn+0x9f/0x1a0\n[524854.859027]  ? __nf_unregister_net_hook+0x21a/0x260\n[524854.859044]  ? report_bug+0x1b1/0x1e0\n[524854.859060]  ? handle_bug+0x3c/0x70\n[524854.859071]  ? exc_invalid_op+0x17/0x40\n[524854.859083]  ? asm_exc_invalid_op+0x1a/0x20\n[524854.859100]  ? __nf_unregister_net_hook+0x6a/0x260\n[524854.859116]  ? __nf_unregister_net_hook+0x21a/0x260\n[524854.859135]  nf_tables_netdev_event+0x337/0x390 [nf_tables]\n[524854.859304]  ? __pfx_nf_tables_netdev_event+0x10/0x10 [nf_tables]\n[524854.859461]  ? packet_notifier+0xb3/0x360\n[524854.859476]  ? _raw_spin_unlock_irqrestore+0x11/0x40\n[524854.859489]  ? dcbnl_netdevice_event+0x35/0x140\n[524854.859507]  ? __pfx_nf_tables_netdev_event+0x10/0x10 [nf_tables]\n[524854.859661]  notifier_call_chain+0x7d/0x140\n[524854.859677]  unregister_netdevice_many_notify+0x5e1/0xae0\n\nCVE-2024-36006:\nIn the Linux kernel, the following vulnerability has been resolved:\nmlxsw: spectrum_acl_tcam: Fix incorrect list API usage\nBoth the function that migrates all the chunks within a region and the\nfunction that migrates all the entries within a chunk call\nlist_first_entry() on the respective lists without checking that the\nlists are not empty. This is incorrect usage of the API, which leads to\nthe following warning [1].\nFix by returning if the lists are empty as there is nothing to migrate\nin this case.\n[1]\nWARNING: CPU: 0 PID: 6437 at drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c:1266 mlxsw_sp_acl_tcam_vchunk_migrate_all+0x1f1/0\u003e\nModules linked in:\nCPU: 0 PID: 6437 Comm: kworker/0:37 Not tainted 6.9.0-rc3-custom-00883-g94a65f079ef6 #39\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:mlxsw_sp_acl_tcam_vchunk_migrate_all+0x1f1/0x2c0\n[...]\nCall Trace:\n\u003cTASK\u003e\nmlxsw_sp_acl_tcam_vregion_rehash_work+0x6c/0x4a0\nprocess_one_work+0x151/0x370\nworker_thread+0x2cb/0x3e0\nkthread+0xd0/0x100\nret_from_fork+0x34/0x50\nret_from_fork_asm+0x1a/0x30\n\u003c/TASK\u003e\n\nCVE-2024-36010:\nIn the Linux kernel, the following vulnerability has been resolved:\nigb: Fix string truncation warnings in igb_set_fw_version\nCommit 1978d3ead82c (\"intel: fix string truncation warnings\")\nfixes '-Wformat-truncation=' warnings in igb_main.c by using kasprintf.\ndrivers/net/ethernet/intel/igb/igb_main.c:3092:53: warning：‘%d’ directive output may be truncated writing between 1 and 5 bytes into a region of size between 1 and 13 [-Wformat-truncation=]\n3092 |                                  \"%d.%d, 0x%08x, %d.%d.%d\",\n|                                                     ^~\ndrivers/net/ethernet/intel/igb/igb_main.c:3092:34: note：directive argument in the range [0, 65535]\n3092 |                                  \"%d.%d, 0x%08x, %d.%d.%d\",\n|                                  ^~~~~~~~~~~~~~~~~~~~~~~~~\ndrivers/net/ethernet/intel/igb/igb_main.c:3092:34: note：directive argument in the range [0, 65535]\ndrivers/net/ethernet/intel/igb/igb_main.c:3090:25: note：‘snprintf’ output between 23 and 43 bytes into a destination of size 32\nkasprintf() returns a pointer to dynamically allocated memory\nwhich can be NULL upon failure.\nFix this warning by using a larger space for adapter-\u003efw_version,\nand then fall back and continue to use snprintf.\n\nCVE-2024-36016:\nIn the Linux kernel, the following vulnerability has been resolved:\ntty: n_gsm: fix possible out-of-bounds in gsm0_receive()\nAssuming the following:\n- side A configures the n_gsm in basic option mode\n- side B sends the header of a basic option mode frame with data length 1\n- side A switches to advanced option mode\n- side B sends 2 data bytes which exceeds gsm-\u003elen\nReason: gsm-\u003elen is not used in advanced option mode.\n- side A switches to basic option mode\n- side B keeps sending until gsm0_receive() writes past gsm-\u003ebuf\nReason: Neither gsm-\u003estate nor gsm-\u003elen have been reset after\nreconfiguration.\nFix this by changing gsm-\u003ecount to gsm-\u003elen comparison from equal to less\nthan. Also add upper limit checks against the constant MAX_MRU in\ngsm0_receive() and gsm1_receive() to harden against memory corruption of\ngsm-\u003elen and gsm-\u003emru.\nAll other checks remain as we still need to limit the data according to the\nuser configuration and actual payload size.\n\nCVE-2024-36017:\nIn the Linux kernel, the following vulnerability has been resolved:\nrtnetlink: Correct nested IFLA_VF_VLAN_LIST attribute validation\nEach attribute inside a nested IFLA_VF_VLAN_LIST is assumed to be a\nstruct ifla_vf_vlan_info so the size of such attribute needs to be at least\nof sizeof(struct ifla_vf_vlan_info) which is 14 bytes.\nThe current size validation in do_setvfinfo is against NLA_HDRLEN (4 bytes)\nwhich is less than sizeof(struct ifla_vf_vlan_info) so this validation\nis not enough and a too small attribute might be cast to a\nstruct ifla_vf_vlan_info, this might result in an out of bands\nread access when accessing the saved (casted) entry in ivvl.\n\nCVE-2024-36020:\nIn the Linux kernel, the following vulnerability has been resolved:\ni40e: fix vf may be used uninitialized in this function warning\nTo fix the regression introduced by commit 52424f974bc5, which causes\nservers hang in very hard to reproduce conditions with resets races.\nUsing two sources for the information is the root cause.\nIn this function before the fix bumping v didn't mean bumping vf\npointer. But the code used this variables interchangeably, so stale vf\ncould point to different/not intended vf.\nRemove redundant \"v\" variable and iterate via single VF pointer across\nwhole function instead to guarantee VF pointer validity.\n\nCVE-2024-36025:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: qla2xxx: Fix off by one in qla_edif_app_getstats()\nThe app_reply-\u003eelem[] array is allocated earlier in this function and it\nhas app_req.num_ports elements.  Thus this \u003e comparison needs to be \u003e= to\nprevent memory corruption.\n\nCVE-2024-36270:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: tproxy: bail out if IP has been disabled on the device\nsyzbot reports:\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN PTI\nKASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f]\n[..]\nRIP: 0010:nf_tproxy_laddr4+0xb7/0x340 net/ipv4/netfilter/nf_tproxy_ipv4.c:62\nCall Trace:\nnft_tproxy_eval_v4 net/netfilter/nft_tproxy.c:56 [inline]\nnft_tproxy_eval+0xa9a/0x1a00 net/netfilter/nft_tproxy.c:168\n__in_dev_get_rcu() can return NULL, so check for this.\n\nCVE-2024-36286:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: nfnetlink_queue: acquire rcu_read_lock() in instance_destroy_rcu()\nsyzbot reported that nf_reinject() could be called without rcu_read_lock() :\nWARNING: suspicious RCU usage\n6.9.0-rc7-syzkaller-02060-g5c1672705a1a #0 Not tainted\nnet/netfilter/nfnetlink_queue.c:263 suspicious rcu_dereference_check() usage!\nother info that might help us debug this:\nrcu_scheduler_active = 2, debug_locks = 1\n2 locks held by syz-executor.4/13427:\n#0: ffffffff8e334f60 (rcu_callback){....}-{0:0}, at: rcu_lock_acquire include/linux/rcupdate.h:329 [inline]\n#0: ffffffff8e334f60 (rcu_callback){....}-{0:0}, at: rcu_do_batch kernel/rcu/tree.c:2190 [inline]\n#0: ffffffff8e334f60 (rcu_callback){....}-{0:0}, at: rcu_core+0xa86/0x1830 kernel/rcu/tree.c:2471\n#1: ffff88801ca92958 (\u0026inst-\u003elock){+.-.}-{2:2}, at: spin_lock_bh include/linux/spinlock.h:356 [inline]\n#1: ffff88801ca92958 (\u0026inst-\u003elock){+.-.}-{2:2}, at: nfqnl_flush net/netfilter/nfnetlink_queue.c:405 [inline]\n#1: ffff88801ca92958 (\u0026inst-\u003elock){+.-.}-{2:2}, at: instance_destroy_rcu+0x30/0x220 net/netfilter/nfnetlink_queue.c:172\nstack backtrace:\nCPU: 0 PID: 13427 Comm: syz-executor.4 Not tainted 6.9.0-rc7-syzkaller-02060-g5c1672705a1a #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024\nCall Trace:\n\u003cIRQ\u003e\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\nlockdep_rcu_suspicious+0x221/0x340 kernel/locking/lockdep.c:6712\nnf_reinject net/netfilter/nfnetlink_queue.c:323 [inline]\nnfqnl_reinject+0x6ec/0x1120 net/netfilter/nfnetlink_queue.c:397\nnfqnl_flush net/netfilter/nfnetlink_queue.c:410 [inline]\ninstance_destroy_rcu+0x1ae/0x220 net/netfilter/nfnetlink_queue.c:172\nrcu_do_batch kernel/rcu/tree.c:2196 [inline]\nrcu_core+0xafd/0x1830 kernel/rcu/tree.c:2471\nhandle_softirqs+0x2d6/0x990 kernel/softirq.c:554\n__do_softirq kernel/softirq.c:588 [inline]\ninvoke_softirq kernel/softirq.c:428 [inline]\n__irq_exit_rcu+0xf4/0x1c0 kernel/softirq.c:637\nirq_exit_rcu+0x9/0x30 kernel/softirq.c:649\ninstr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1043 [inline]\nsysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1043\n\u003c/IRQ\u003e\n\u003cTASK\u003e\n\nCVE-2024-36489:\nIn the Linux kernel, the following vulnerability has been resolved:\ntls: fix missing memory barrier in tls_init\nIn tls_init(), a write memory barrier is missing, and store-store\nreordering may cause NULL dereference in tls_{setsockopt,getsockopt}.\nCPU0                               CPU1\n-----                              -----\n// In tls_init()\n// In tls_ctx_create()\nctx = kzalloc()\nctx-\u003esk_proto = READ_ONCE(sk-\u003esk_prot) -(1)\n// In update_sk_prot()\nWRITE_ONCE(sk-\u003esk_prot, tls_prots)     -(2)\n// In sock_common_setsockopt()\nREAD_ONCE(sk-\u003esk_prot)-\u003esetsockopt()\n// In tls_{setsockopt,getsockopt}()\nctx-\u003esk_proto-\u003esetsockopt()    -(3)\nIn the above scenario, when (1) and (2) are reordered, (3) can observe\nthe NULL value of ctx-\u003esk_proto, causing NULL dereference.\nTo fix it, we rely on rcu_assign_pointer() which implies the release\nbarrier semantic. By moving rcu_assign_pointer() after ctx-\u003esk_proto is\ninitialized, we can ensure that ctx-\u003esk_proto are visible when\nchanging sk-\u003esk_prot.\n\nCVE-2024-36886:\nIn the Linux kernel, the following vulnerability has been resolved:\ntipc: fix UAF in error path\nSam Page (sam4k) working with Trend Micro Zero Day Initiative reported\na UAF in the tipc_buf_append() error path:\nBUG: KASAN: slab-use-after-free in kfree_skb_list_reason+0x47e/0x4c0\nlinux/net/core/skbuff.c:1183\nRead of size 8 at addr ffff88804d2a7c80 by task poc/8034\nCPU: 1 PID: 8034 Comm: poc Not tainted 6.8.2 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.0-debian-1.16.0-5 04/01/2014\nCall Trace:\n\u003cIRQ\u003e\n__dump_stack linux/lib/dump_stack.c:88\ndump_stack_lvl+0xd9/0x1b0 linux/lib/dump_stack.c:106\nprint_address_description linux/mm/kasan/report.c:377\nprint_report+0xc4/0x620 linux/mm/kasan/report.c:488\nkasan_report+0xda/0x110 linux/mm/kasan/report.c:601\nkfree_skb_list_reason+0x47e/0x4c0 linux/net/core/skbuff.c:1183\nskb_release_data+0x5af/0x880 linux/net/core/skbuff.c:1026\nskb_release_all linux/net/core/skbuff.c:1094\n__kfree_skb linux/net/core/skbuff.c:1108\nkfree_skb_reason+0x12d/0x210 linux/net/core/skbuff.c:1144\nkfree_skb linux/./include/linux/skbuff.h:1244\ntipc_buf_append+0x425/0xb50 linux/net/tipc/msg.c:186\ntipc_link_input+0x224/0x7c0 linux/net/tipc/link.c:1324\ntipc_link_rcv+0x76e/0x2d70 linux/net/tipc/link.c:1824\ntipc_rcv+0x45f/0x10f0 linux/net/tipc/node.c:2159\ntipc_udp_recv+0x73b/0x8f0 linux/net/tipc/udp_media.c:390\nudp_queue_rcv_one_skb+0xad2/0x1850 linux/net/ipv4/udp.c:2108\nudp_queue_rcv_skb+0x131/0xb00 linux/net/ipv4/udp.c:2186\nudp_unicast_rcv_skb+0x165/0x3b0 linux/net/ipv4/udp.c:2346\n__udp4_lib_rcv+0x2594/0x3400 linux/net/ipv4/udp.c:2422\nip_protocol_deliver_rcu+0x30c/0x4e0 linux/net/ipv4/ip_input.c:205\nip_local_deliver_finish+0x2e4/0x520 linux/net/ipv4/ip_input.c:233\nNF_HOOK linux/./include/linux/netfilter.h:314\nNF_HOOK linux/./include/linux/netfilter.h:308\nip_local_deliver+0x18e/0x1f0 linux/net/ipv4/ip_input.c:254\ndst_input linux/./include/net/dst.h:461\nip_rcv_finish linux/net/ipv4/ip_input.c:449\nNF_HOOK linux/./include/linux/netfilter.h:314\nNF_HOOK linux/./include/linux/netfilter.h:308\nip_rcv+0x2c5/0x5d0 linux/net/ipv4/ip_input.c:569\n__netif_receive_skb_one_core+0x199/0x1e0 linux/net/core/dev.c:5534\n__netif_receive_skb+0x1f/0x1c0 linux/net/core/dev.c:5648\nprocess_backlog+0x101/0x6b0 linux/net/core/dev.c:5976\n__napi_poll.constprop.0+0xba/0x550 linux/net/core/dev.c:6576\nnapi_poll linux/net/core/dev.c:6645\nnet_rx_action+0x95a/0xe90 linux/net/core/dev.c:6781\n__do_softirq+0x21f/0x8e7 linux/kernel/softirq.c:553\ndo_softirq linux/kernel/softirq.c:454\ndo_softirq+0xb2/0xf0 linux/kernel/softirq.c:441\n\u003c/IRQ\u003e\n\u003cTASK\u003e\n__local_bh_enable_ip+0x100/0x120 linux/kernel/softirq.c:381\nlocal_bh_enable linux/./include/linux/bottom_half.h:33\nrcu_read_unlock_bh linux/./include/linux/rcupdate.h:851\n__dev_queue_xmit+0x871/0x3ee0 linux/net/core/dev.c:4378\ndev_queue_xmit linux/./include/linux/netdevice.h:3169\nneigh_hh_output linux/./include/net/neighbour.h:526\nneigh_output linux/./include/net/neighbour.h:540\nip_finish_output2+0x169f/0x2550 linux/net/ipv4/ip_output.c:235\n__ip_finish_output linux/net/ipv4/ip_output.c:313\n__ip_finish_output+0x49e/0x950 linux/net/ipv4/ip_output.c:295\nip_finish_output+0x31/0x310 linux/net/ipv4/ip_output.c:323\nNF_HOOK_COND linux/./include/linux/netfilter.h:303\nip_output+0x13b/0x2a0 linux/net/ipv4/ip_output.c:433\ndst_output linux/./include/net/dst.h:451\nip_local_out linux/net/ipv4/ip_output.c:129\nip_send_skb+0x3e5/0x560 linux/net/ipv4/ip_output.c:1492\nudp_send_skb+0x73f/0x1530 linux/net/ipv4/udp.c:963\nudp_sendmsg+0x1a36/0x2b40 linux/net/ipv4/udp.c:1250\ninet_sendmsg+0x105/0x140 linux/net/ipv4/af_inet.c:850\nsock_sendmsg_nosec linux/net/socket.c:730\n__sock_sendmsg linux/net/socket.c:745\n__sys_sendto+0x42c/0x4e0 linux/net/socket.c:2191\n__do_sys_sendto linux/net/socket.c:2203\n__se_sys_sendto linux/net/socket.c:2199\n__x64_sys_sendto+0xe0/0x1c0 linux/net/socket.c:2199\ndo_syscall_x64 linux/arch/x86/entry/common.c:52\ndo_syscall_\n---truncated---\n\nCVE-2024-36889:\nIn the Linux kernel, the following vulnerability has been resolved:\nmptcp: ensure snd_nxt is properly initialized on connect\nChristoph reported a splat hinting at a corrupted snd_una:\nWARNING: CPU: 1 PID: 38 at net/mptcp/protocol.c:1005 __mptcp_clean_una+0x4b3/0x620 net/mptcp/protocol.c:1005\nModules linked in:\nCPU: 1 PID: 38 Comm: kworker/1:1 Not tainted 6.9.0-rc1-gbbeac67456c9 #59\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014\nWorkqueue: events mptcp_worker\nRIP: 0010:__mptcp_clean_una+0x4b3/0x620 net/mptcp/protocol.c:1005\nCode: be 06 01 00 00 bf 06 01 00 00 e8 a8 12 e7 fe e9 00 fe ff ff e8\n8e 1a e7 fe 0f b7 ab 3e 02 00 00 e9 d3 fd ff ff e8 7d 1a e7 fe\n\u003c0f\u003e 0b 4c 8b bb e0 05 00 00 e9 74 fc ff ff e8 6a 1a e7 fe 0f 0b e9\nRSP: 0018:ffffc9000013fd48 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: ffff8881029bd280 RCX: ffffffff82382fe4\nRDX: ffff8881003cbd00 RSI: ffffffff823833c3 RDI: 0000000000000001\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: fefefefefefefeff R12: ffff888138ba8000\nR13: 0000000000000106 R14: ffff8881029bd908 R15: ffff888126560000\nFS:  0000000000000000(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f604a5dae38 CR3: 0000000101dac002 CR4: 0000000000170ef0\nCall Trace:\n\u003cTASK\u003e\n__mptcp_clean_una_wakeup net/mptcp/protocol.c:1055 [inline]\nmptcp_clean_una_wakeup net/mptcp/protocol.c:1062 [inline]\n__mptcp_retrans+0x7f/0x7e0 net/mptcp/protocol.c:2615\nmptcp_worker+0x434/0x740 net/mptcp/protocol.c:2767\nprocess_one_work+0x1e0/0x560 kernel/workqueue.c:3254\nprocess_scheduled_works kernel/workqueue.c:3335 [inline]\nworker_thread+0x3c7/0x640 kernel/workqueue.c:3416\nkthread+0x121/0x170 kernel/kthread.c:388\nret_from_fork+0x44/0x50 arch/x86/kernel/process.c:147\nret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:243\n\u003c/TASK\u003e\nWhen fallback to TCP happens early on a client socket, snd_nxt\nis not yet initialized and any incoming ack will copy such value\ninto snd_una. If the mptcp worker (dumbly) tries mptcp-level\nre-injection after such ack, that would unconditionally trigger a send\nbuffer cleanup using 'bad' snd_una values.\nWe could easily disable re-injection for fallback sockets, but such\ndumb behavior already helped catching a few subtle issues and a very\nlow to zero impact in practice.\nInstead address the issue always initializing snd_nxt (and write_seq,\nfor consistency) at connect time.\n\nCVE-2024-36896:\nIn the Linux kernel, the following vulnerability has been resolved:\nUSB: core: Fix access violation during port device removal\nTesting with KASAN and syzkaller revealed a bug in port.c:disable_store():\nusb_hub_to_struct_hub() can return NULL if the hub that the port belongs to\nis concurrently removed, but the function does not check for this\npossibility before dereferencing the returned value.\nIt turns out that the first dereference is unnecessary, since hub-\u003eintfdev\nis the parent of the port device, so it can be changed easily.  Adding a\ncheck for hub == NULL prevents further problems.\nThe same bug exists in the disable_show() routine, and it can be fixed the\nsame way.\n\nCVE-2024-36904:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: Use refcount_inc_not_zero() in tcp_twsk_unique().\nAnderson Nascimento reported a use-after-free splat in tcp_twsk_unique()\nwith nice analysis.\nSince commit ec94c2696f0b (\"tcp/dccp: avoid one atomic operation for\ntimewait hashdance\"), inet_twsk_hashdance() sets TIME-WAIT socket's\nsk_refcnt after putting it into ehash and releasing the bucket lock.\nThus, there is a small race window where other threads could try to\nreuse the port during connect() and call sock_hold() in tcp_twsk_unique()\nfor the TIME-WAIT socket with zero refcnt.\nIf that happens, the refcnt taken by tcp_twsk_unique() is overwritten\nand sock_put() will cause underflow, triggering a real use-after-free\nsomewhere else.\nTo avoid the use-after-free, we need to use refcount_inc_not_zero() in\ntcp_twsk_unique() and give up on reusing the port if it returns false.\n[0]:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 0 PID: 1039313 at lib/refcount.c:25 refcount_warn_saturate+0xe5/0x110\nCPU: 0 PID: 1039313 Comm: trigger Not tainted 6.8.6-200.fc39.x86_64 #1\nHardware name: VMware, Inc. VMware20,1/440BX Desktop Reference Platform, BIOS VMW201.00V.21805430.B64.2305221830 05/22/2023\nRIP: 0010:refcount_warn_saturate+0xe5/0x110\nCode: 42 8e ff 0f 0b c3 cc cc cc cc 80 3d aa 13 ea 01 00 0f 85 5e ff ff ff 48 c7 c7 f8 8e b7 82 c6 05 96 13 ea 01 01 e8 7b 42 8e ff \u003c0f\u003e 0b c3 cc cc cc cc 48 c7 c7 50 8f b7 82 c6 05 7a 13 ea 01 01 e8\nRSP: 0018:ffffc90006b43b60 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff888009bb3ef0 RCX: 0000000000000027\nRDX: ffff88807be218c8 RSI: 0000000000000001 RDI: ffff88807be218c0\nRBP: 0000000000069d70 R08: 0000000000000000 R09: ffffc90006b439f0\nR10: ffffc90006b439e8 R11: 0000000000000003 R12: ffff8880029ede84\nR13: 0000000000004e20 R14: ffffffff84356dc0 R15: ffff888009bb3ef0\nFS:  00007f62c10926c0(0000) GS:ffff88807be00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020ccb000 CR3: 000000004628c005 CR4: 0000000000f70ef0\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\n? refcount_warn_saturate+0xe5/0x110\n? __warn+0x81/0x130\n? refcount_warn_saturate+0xe5/0x110\n? report_bug+0x171/0x1a0\n? refcount_warn_saturate+0xe5/0x110\n? handle_bug+0x3c/0x80\n? exc_invalid_op+0x17/0x70\n? asm_exc_invalid_op+0x1a/0x20\n? refcount_warn_saturate+0xe5/0x110\ntcp_twsk_unique+0x186/0x190\n__inet_check_established+0x176/0x2d0\n__inet_hash_connect+0x74/0x7d0\n? __pfx___inet_check_established+0x10/0x10\ntcp_v4_connect+0x278/0x530\n__inet_stream_connect+0x10f/0x3d0\ninet_stream_connect+0x3a/0x60\n__sys_connect+0xa8/0xd0\n__x64_sys_connect+0x18/0x20\ndo_syscall_64+0x83/0x170\nentry_SYSCALL_64_after_hwframe+0x78/0x80\nRIP: 0033:0x7f62c11a885d\nCode: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 8b 0d a3 45 0c 00 f7 d8 64 89 01 48\nRSP: 002b:00007f62c1091e58 EFLAGS: 00000296 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 0000000020ccb004 RCX: 00007f62c11a885d\nRDX: 0000000000000010 RSI: 0000000020ccb000 RDI: 0000000000000003\nRBP: 00007f62c1091e90 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000296 R12: 00007f62c10926c0\nR13: ffffffffffffff88 R14: 0000000000000000 R15: 00007ffe237885b0\n\u003c/TASK\u003e\n\nCVE-2024-36905:\nIn the Linux kernel, the following vulnerability has been resolved:\ntcp: defer shutdown(SEND_SHUTDOWN) for TCP_SYN_RECV sockets\nTCP_SYN_RECV state is really special, it is only used by\ncross-syn connections, mostly used by fuzzers.\nIn the following crash [1], syzbot managed to trigger a divide\nby zero in tcp_rcv_space_adjust()\nA socket makes the following state transitions,\nwithout ever calling tcp_init_transfer(),\nmeaning tcp_init_buffer_space() is also not called.\nTCP_CLOSE\nconnect()\nTCP_SYN_SENT\nTCP_SYN_RECV\nshutdown() -\u003e tcp_shutdown(sk, SEND_SHUTDOWN)\nTCP_FIN_WAIT1\nTo fix this issue, change tcp_shutdown() to not\nperform a TCP_SYN_RECV -\u003e TCP_FIN_WAIT1 transition,\nwhich makes no sense anyway.\nWhen tcp_rcv_state_process() later changes socket state\nfrom TCP_SYN_RECV to TCP_ESTABLISH, then look at\nsk-\u003esk_shutdown to finally enter TCP_FIN_WAIT1 state,\nand send a FIN packet from a sane socket state.\nThis means tcp_send_fin() can now be called from BH\ncontext, and must use GFP_ATOMIC allocations.\n[1]\ndivide error: 0000 [#1] PREEMPT SMP KASAN NOPTI\nCPU: 1 PID: 5084 Comm: syz-executor358 Not tainted 6.9.0-rc6-syzkaller-00022-g98369dccd2f8 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nRIP: 0010:tcp_rcv_space_adjust+0x2df/0x890 net/ipv4/tcp_input.c:767\nCode: e3 04 4c 01 eb 48 8b 44 24 38 0f b6 04 10 84 c0 49 89 d5 0f 85 a5 03 00 00 41 8b 8e c8 09 00 00 89 e8 29 c8 48 0f af c3 31 d2 \u003c48\u003e f7 f1 48 8d 1c 43 49 8d 96 76 08 00 00 48 89 d0 48 c1 e8 03 48\nRSP: 0018:ffffc900031ef3f0 EFLAGS: 00010246\nRAX: 0c677a10441f8f42 RBX: 000000004fb95e7e RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: 0000000027d4b11f R08: ffffffff89e535a4 R09: 1ffffffff25e6ab7\nR10: dffffc0000000000 R11: ffffffff8135e920 R12: ffff88802a9f8d30\nR13: dffffc0000000000 R14: ffff88802a9f8d00 R15: 1ffff1100553f2da\nFS:  00005555775c0380(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f1155bf2304 CR3: 000000002b9f2000 CR4: 0000000000350ef0\nCall Trace:\n\u003cTASK\u003e\ntcp_recvmsg_locked+0x106d/0x25a0 net/ipv4/tcp.c:2513\ntcp_recvmsg+0x25d/0x920 net/ipv4/tcp.c:2578\ninet6_recvmsg+0x16a/0x730 net/ipv6/af_inet6.c:680\nsock_recvmsg_nosec net/socket.c:1046 [inline]\nsock_recvmsg+0x109/0x280 net/socket.c:1068\n____sys_recvmsg+0x1db/0x470 net/socket.c:2803\n___sys_recvmsg net/socket.c:2845 [inline]\ndo_recvmmsg+0x474/0xae0 net/socket.c:2939\n__sys_recvmmsg net/socket.c:3018 [inline]\n__do_sys_recvmmsg net/socket.c:3041 [inline]\n__se_sys_recvmmsg net/socket.c:3034 [inline]\n__x64_sys_recvmmsg+0x199/0x250 net/socket.c:3034\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7faeb6363db9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 c1 17 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u003c48\u003e 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffcc1997168 EFLAGS: 00000246 ORIG_RAX: 000000000000012b\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007faeb6363db9\nRDX: 0000000000000001 RSI: 0000000020000bc0 RDI: 0000000000000005\nRBP: 0000000000000000 R08: 0000000000000000 R09: 000000000000001c\nR10: 0000000000000122 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000001\n\nCVE-2024-36917:\nIn the Linux kernel, the following vulnerability has been resolved:\nblock: fix overflow in blk_ioctl_discard()\nThere is no check for overflow of 'start + len' in blk_ioctl_discard().\nHung task occurs if submit an discard ioctl with the following param:\nstart = 0x80000000000ff000, len = 0x8000000000fff000;\nAdd the overflow validation now.\n\nCVE-2024-36921:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: iwlwifi: mvm: guard against invalid STA ID on removal\nGuard against invalid station IDs in iwl_mvm_mld_rm_sta_id as that would\nresult in out-of-bounds array accesses. This prevents issues should the\ndriver get into a bad state during error handling.\n\nCVE-2024-36927:\nIn the Linux kernel, the following vulnerability has been resolved:\nipv4: Fix uninit-value access in __ip_make_skb()\nKMSAN reported uninit-value access in __ip_make_skb() [1].  __ip_make_skb()\ntests HDRINCL to know if the skb has icmphdr. However, HDRINCL can cause a\nrace condition. If calling setsockopt(2) with IP_HDRINCL changes HDRINCL\nwhile __ip_make_skb() is running, the function will access icmphdr in the\nskb even if it is not included. This causes the issue reported by KMSAN.\nCheck FLOWI_FLAG_KNOWN_NH on fl4-\u003eflowi4_flags instead of testing HDRINCL\non the socket.\nAlso, fl4-\u003efl4_icmp_type and fl4-\u003efl4_icmp_code are not initialized. These\nare union in struct flowi4 and are implicitly initialized by\nflowi4_init_output(), but we should not rely on specific union layout.\nInitialize these explicitly in raw_sendmsg().\n[1]\nBUG: KMSAN: uninit-value in __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481\n__ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481\nip_finish_skb include/net/ip.h:243 [inline]\nip_push_pending_frames+0x4c/0x5c0 net/ipv4/ip_output.c:1508\nraw_sendmsg+0x2381/0x2690 net/ipv4/raw.c:654\ninet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg+0x274/0x3c0 net/socket.c:745\n__sys_sendto+0x62c/0x7b0 net/socket.c:2191\n__do_sys_sendto net/socket.c:2203 [inline]\n__se_sys_sendto net/socket.c:2199 [inline]\n__x64_sys_sendto+0x130/0x200 net/socket.c:2199\ndo_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x6d/0x75\nUninit was created at:\nslab_post_alloc_hook mm/slub.c:3804 [inline]\nslab_alloc_node mm/slub.c:3845 [inline]\nkmem_cache_alloc_node+0x5f6/0xc50 mm/slub.c:3888\nkmalloc_reserve+0x13c/0x4a0 net/core/skbuff.c:577\n__alloc_skb+0x35a/0x7c0 net/core/skbuff.c:668\nalloc_skb include/linux/skbuff.h:1318 [inline]\n__ip_append_data+0x49ab/0x68c0 net/ipv4/ip_output.c:1128\nip_append_data+0x1e7/0x260 net/ipv4/ip_output.c:1365\nraw_sendmsg+0x22b1/0x2690 net/ipv4/raw.c:648\ninet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg+0x274/0x3c0 net/socket.c:745\n__sys_sendto+0x62c/0x7b0 net/socket.c:2191\n__do_sys_sendto net/socket.c:2203 [inline]\n__se_sys_sendto net/socket.c:2199 [inline]\n__x64_sys_sendto+0x130/0x200 net/socket.c:2199\ndo_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x6d/0x75\nCPU: 1 PID: 15709 Comm: syz-executor.7 Not tainted 6.8.0-11567-gb3603fcb79b1 #25\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-1.fc39 04/01/2014\n\nCVE-2024-36929:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: core: reject skb_copy(_expand) for fraglist GSO skbs\nSKB_GSO_FRAGLIST skbs must not be linearized, otherwise they become\ninvalid. Return NULL if such an skb is passed to skb_copy or\nskb_copy_expand, in order to prevent a crash on a potential later\ncall to skb_gso_segment.\n\nCVE-2024-36933:\nIn the Linux kernel, the following vulnerability has been resolved:\nnsh: Restore skb-\u003e{protocol,data,mac_header} for outer header in nsh_gso_segment().\nsyzbot triggered various splats (see [0] and links) by a crafted GSO\npacket of VIRTIO_NET_HDR_GSO_UDP layering the following protocols:\nETH_P_8021AD + ETH_P_NSH + ETH_P_IPV6 + IPPROTO_UDP\nNSH can encapsulate IPv4, IPv6, Ethernet, NSH, and MPLS.  As the inner\nprotocol can be Ethernet, NSH GSO handler, nsh_gso_segment(), calls\nskb_mac_gso_segment() to invoke inner protocol GSO handlers.\nnsh_gso_segment() does the following for the original skb before\ncalling skb_mac_gso_segment()\n1. reset skb-\u003enetwork_header\n2. save the original skb-\u003e{mac_heaeder,mac_len} in a local variable\n3. pull the NSH header\n4. resets skb-\u003emac_header\n5. set up skb-\u003emac_len and skb-\u003eprotocol for the inner protocol.\nand does the following for the segmented skb\n6. set ntohs(ETH_P_NSH) to skb-\u003eprotocol\n7. push the NSH header\n8. restore skb-\u003emac_header\n9. set skb-\u003emac_header + mac_len to skb-\u003enetwork_header\n10. restore skb-\u003emac_len\nThere are two problems in 6-7 and 8-9.\n(a)\nAfter 6 \u0026 7, skb-\u003edata points to the NSH header, so the outer header\n(ETH_P_8021AD in this case) is stripped when skb is sent out of netdev.\nAlso, if NSH is encapsulated by NSH + Ethernet (so NSH-Ethernet-NSH),\nskb_pull() in the first nsh_gso_segment() will make skb-\u003edata point\nto the middle of the outer NSH or Ethernet header because the Ethernet\nheader is not pulled by the second nsh_gso_segment().\n(b)\nWhile restoring skb-\u003e{mac_header,network_header} in 8 \u0026 9,\nnsh_gso_segment() does not assume that the data in the linear\nbuffer is shifted.\nHowever, udp6_ufo_fragment() could shift the data and change\nskb-\u003emac_header accordingly as demonstrated by syzbot.\nIf this happens, even the restored skb-\u003emac_header points to\nthe middle of the outer header.\nIt seems nsh_gso_segment() has never worked with outer headers so far.\nAt the end of nsh_gso_segment(), the outer header must be restored for\nthe segmented skb, instead of the NSH header.\nTo do that, let's calculate the outer header position relatively from\nthe inner header and set skb-\u003e{data,mac_header,protocol} properly.\n[0]:\nBUG: KMSAN: uninit-value in ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:524 [inline]\nBUG: KMSAN: uninit-value in ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:602 [inline]\nBUG: KMSAN: uninit-value in ipvlan_queue_xmit+0xf44/0x16b0 drivers/net/ipvlan/ipvlan_core.c:668\nipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:524 [inline]\nipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:602 [inline]\nipvlan_queue_xmit+0xf44/0x16b0 drivers/net/ipvlan/ipvlan_core.c:668\nipvlan_start_xmit+0x5c/0x1a0 drivers/net/ipvlan/ipvlan_main.c:222\n__netdev_start_xmit include/linux/netdevice.h:4989 [inline]\nnetdev_start_xmit include/linux/netdevice.h:5003 [inline]\nxmit_one net/core/dev.c:3547 [inline]\ndev_hard_start_xmit+0x244/0xa10 net/core/dev.c:3563\n__dev_queue_xmit+0x33ed/0x51c0 net/core/dev.c:4351\ndev_queue_xmit include/linux/netdevice.h:3171 [inline]\npacket_xmit+0x9c/0x6b0 net/packet/af_packet.c:276\npacket_snd net/packet/af_packet.c:3081 [inline]\npacket_sendmsg+0x8aef/0x9f10 net/packet/af_packet.c:3113\nsock_sendmsg_nosec net/socket.c:730 [inline]\n__sock_sendmsg net/socket.c:745 [inline]\n__sys_sendto+0x735/0xa10 net/socket.c:2191\n__do_sys_sendto net/socket.c:2203 [inline]\n__se_sys_sendto net/socket.c:2199 [inline]\n__x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x63/0x6b\nUninit was created at:\nslab_post_alloc_hook mm/slub.c:3819 [inline]\nslab_alloc_node mm/slub.c:3860 [inline]\n__do_kmalloc_node mm/slub.c:3980 [inline]\n__kmalloc_node_track_caller+0x705/0x1000 mm/slub.c:4001\nkmalloc_reserve+0x249/0x4a0 net/core/skbuff.c:582\n__\n---truncated---\n\nCVE-2024-36940:\nIn the Linux kernel, the following vulnerability has been resolved:\npinctrl: core: delete incorrect free in pinctrl_enable()\nThe \"pctldev\" struct is allocated in devm_pinctrl_register_and_init().\nIt's a devm_ managed pointer that is freed by devm_pinctrl_dev_release(),\nso freeing it in pinctrl_enable() will lead to a double free.\nThe devm_pinctrl_dev_release() function frees the pindescs and destroys\nthe mutex as well.\n\nCVE-2024-36941:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: nl80211: don't free NULL coalescing rule\nIf the parsing fails, we can dereference a NULL pointer here.\n\nCVE-2024-36945:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/smc: fix neighbour and rtable leak in smc_ib_find_route()\nIn smc_ib_find_route(), the neighbour found by neigh_lookup() and rtable\nresolved by ip_route_output_flow() are not released or put before return.\nIt may cause the refcount leak, so fix it.\n\nCVE-2024-36950:\nIn the Linux kernel, the following vulnerability has been resolved:\nfirewire: ohci: mask bus reset interrupts between ISR and bottom half\nIn the FireWire OHCI interrupt handler, if a bus reset interrupt has\noccurred, mask bus reset interrupts until bus_reset_work has serviced and\ncleared the interrupt.\nNormally, we always leave bus reset interrupts masked. We infer the bus\nreset from the self-ID interrupt that happens shortly thereafter. A\nscenario where we unmask bus reset interrupts was introduced in 2008 in\na007bb857e0b26f5d8b73c2ff90782d9c0972620: If\nOHCI_PARAM_DEBUG_BUSRESETS (8) is set in the debug parameter bitmask, we\nwill unmask bus reset interrupts so we can log them.\nirq_handler logs the bus reset interrupt. However, we can't clear the bus\nreset event flag in irq_handler, because we won't service the event until\nlater. irq_handler exits with the event flag still set. If the\ncorresponding interrupt is still unmasked, the first bus reset will\nusually freeze the system due to irq_handler being called again each\ntime it exits. This freeze can be reproduced by loading firewire_ohci\nwith \"modprobe firewire_ohci debug=-1\" (to enable all debugging output).\nApparently there are also some cases where bus_reset_work will get called\nsoon enough to clear the event, and operation will continue normally.\nThis freeze was first reported a few months after a007bb85 was committed,\nbut until now it was never fixed. The debug level could safely be set\nto -1 through sysfs after the module was loaded, but this would be\nineffectual in logging bus reset interrupts since they were only\nunmasked during initialization.\nirq_handler will now leave the event flag set but mask bus reset\ninterrupts, so irq_handler won't be called again and there will be no\nfreeze. If OHCI_PARAM_DEBUG_BUSRESETS is enabled, bus_reset_work will\nunmask the interrupt after servicing the event, so future interrupts\nwill be caught as desired.\nAs a side effect to this change, OHCI_PARAM_DEBUG_BUSRESETS can now be\nenabled through sysfs in addition to during initial module loading.\nHowever, when enabled through sysfs, logging of bus reset interrupts will\nbe effective only starting with the second bus reset, after\nbus_reset_work has executed.\n\nCVE-2024-36954:\nIn the Linux kernel, the following vulnerability has been resolved:\ntipc: fix a possible memleak in tipc_buf_append\n__skb_linearize() doesn't free the skb when it fails, so move\n'*buf = NULL' after __skb_linearize(), so that the skb can be\nfreed on the err path.\n\nCVE-2024-36960:\nIn the Linux kernel, the following vulnerability has been resolved:\ndrm/vmwgfx: Fix invalid reads in fence signaled events\nCorrectly set the length of the drm_event to the size of the structure\nthat's actually used.\nThe length of the drm_event was set to the parent structure instead of\nto the drm_vmw_event_fence which is supposed to be read. drm_read\nuses the length parameter to copy the event to the user space thus\nresuling in oob reads.\n\nCVE-2024-36971:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: fix __dst_negative_advice() race\n__dst_negative_advice() does not enforce proper RCU rules when\nsk-\u003edst_cache must be cleared, leading to possible UAF.\nRCU rules are that we must first clear sk-\u003esk_dst_cache,\nthen call dst_release(old_dst).\nNote that sk_dst_reset(sk) is implementing this protocol correctly,\nwhile __dst_negative_advice() uses the wrong order.\nGiven that ip6_negative_advice() has special logic\nagainst RTF_CACHE, this means each of the three -\u003enegative_advice()\nexisting methods must perform the sk_dst_reset() themselves.\nNote the check against NULL dst is centralized in\n__dst_negative_advice(), there is no need to duplicate\nit in various callbacks.\nMany thanks to Clement Lecigne for tracking this issue.\nThis old bug became visible after the blamed commit, using UDP sockets.\n\nCVE-2024-36978:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: sched: sch_multiq: fix possible OOB write in multiq_tune()\nq-\u003ebands will be assigned to qopt-\u003ebands to execute subsequent code logic\nafter kmalloc. So the old q-\u003ebands should not be used in kmalloc.\nOtherwise, an out-of-bounds write will occur.\n\nCVE-2024-36979:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: bridge: mst: fix vlan use-after-free\nsyzbot reported a suspicious rcu usage[1] in bridge's mst code. While\nfixing it I noticed that nothing prevents a vlan to be freed while\nwalking the list from the same path (br forward delay timer). Fix the rcu\nusage and also make sure we are not accessing freed memory by making\nbr_mst_vlan_set_state use rcu read lock.\n[1]\nWARNING: suspicious RCU usage\n6.9.0-rc6-syzkaller #0 Not tainted\n-----------------------------\nnet/bridge/br_private.h:1599 suspicious rcu_dereference_protected() usage!\n...\nstack backtrace:\nCPU: 1 PID: 8017 Comm: syz-executor.1 Not tainted 6.9.0-rc6-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n\u003cIRQ\u003e\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\nlockdep_rcu_suspicious+0x221/0x340 kernel/locking/lockdep.c:6712\nnbp_vlan_group net/bridge/br_private.h:1599 [inline]\nbr_mst_set_state+0x1ea/0x650 net/bridge/br_mst.c:105\nbr_set_state+0x28a/0x7b0 net/bridge/br_stp.c:47\nbr_forward_delay_timer_expired+0x176/0x440 net/bridge/br_stp_timer.c:88\ncall_timer_fn+0x18e/0x650 kernel/time/timer.c:1793\nexpire_timers kernel/time/timer.c:1844 [inline]\n__run_timers kernel/time/timer.c:2418 [inline]\n__run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2429\nrun_timer_base kernel/time/timer.c:2438 [inline]\nrun_timer_softirq+0xb7/0x170 kernel/time/timer.c:2448\n__do_softirq+0x2c6/0x980 kernel/softirq.c:554\ninvoke_softirq kernel/softirq.c:428 [inline]\n__irq_exit_rcu+0xf2/0x1c0 kernel/softirq.c:633\nirq_exit_rcu+0x9/0x30 kernel/softirq.c:645\ninstr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1043 [inline]\nsysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1043\n\u003c/IRQ\u003e\n\u003cTASK\u003e\nasm_sysvec_apic_timer_interrupt+0x1a/0x20 arch/x86/include/asm/idtentry.h:702\nRIP: 0010:lock_acquire+0x264/0x550 kernel/locking/lockdep.c:5758\nCode: 2b 00 74 08 4c 89 f7 e8 ba d1 84 00 f6 44 24 61 02 0f 85 85 01 00 00 41 f7 c7 00 02 00 00 74 01 fb 48 c7 44 24 40 0e 36 e0 45 \u003c4b\u003e c7 44 25 00 00 00 00 00 43 c7 44 25 09 00 00 00 00 43 c7 44 25\nRSP: 0018:ffffc90013657100 EFLAGS: 00000206\nRAX: 0000000000000001 RBX: 1ffff920026cae2c RCX: 0000000000000001\nRDX: dffffc0000000000 RSI: ffffffff8bcaca00 RDI: ffffffff8c1eaa60\nRBP: ffffc90013657260 R08: ffffffff92efe507 R09: 1ffffffff25dfca0\nR10: dffffc0000000000 R11: fffffbfff25dfca1 R12: 1ffff920026cae28\nR13: dffffc0000000000 R14: ffffc90013657160 R15: 0000000000000246\n\nCVE-2024-38538:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet: bridge: xmit: make sure we have at least eth header len bytes\nsyzbot triggered an uninit value[1] error in bridge device's xmit path\nby sending a short (less than ETH_HLEN bytes) skb. To fix it check if\nwe can actually pull that amount instead of assuming.\nTested with dropwatch:\ndrop at: br_dev_xmit+0xb93/0x12d0 [bridge] (0xffffffffc06739b3)\norigin: software\ntimestamp: Mon May 13 11:31:53 2024 778214037 nsec\nprotocol: 0x88a8\nlength: 2\noriginal length: 2\ndrop reason: PKT_TOO_SMALL\n[1]\nBUG: KMSAN: uninit-value in br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65\nbr_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65\n__netdev_start_xmit include/linux/netdevice.h:4903 [inline]\nnetdev_start_xmit include/linux/netdevice.h:4917 [inline]\nxmit_one net/core/dev.c:3531 [inline]\ndev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3547\n__dev_queue_xmit+0x34db/0x5350 net/core/dev.c:4341\ndev_queue_xmit include/linux/netdevice.h:3091 [inline]\n__bpf_tx_skb net/core/filter.c:2136 [inline]\n__bpf_redirect_common net/core/filter.c:2180 [inline]\n__bpf_redirect+0x14a6/0x1620 net/core/filter.c:2187\n____bpf_clone_redirect net/core/filter.c:2460 [inline]\nbpf_clone_redirect+0x328/0x470 net/core/filter.c:2432\n___bpf_prog_run+0x13fe/0xe0f0 kernel/bpf/core.c:1997\n__bpf_prog_run512+0xb5/0xe0 kernel/bpf/core.c:2238\nbpf_dispatcher_nop_func include/linux/bpf.h:1234 [inline]\n__bpf_prog_run include/linux/filter.h:657 [inline]\nbpf_prog_run include/linux/filter.h:664 [inline]\nbpf_test_run+0x499/0xc30 net/bpf/test_run.c:425\nbpf_prog_test_run_skb+0x14ea/0x1f20 net/bpf/test_run.c:1058\nbpf_prog_test_run+0x6b7/0xad0 kernel/bpf/syscall.c:4269\n__sys_bpf+0x6aa/0xd90 kernel/bpf/syscall.c:5678\n__do_sys_bpf kernel/bpf/syscall.c:5767 [inline]\n__se_sys_bpf kernel/bpf/syscall.c:5765 [inline]\n__x64_sys_bpf+0xa0/0xe0 kernel/bpf/syscall.c:5765\nx64_sys_call+0x96b/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:322\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCVE-2024-38555:\nIn the Linux kernel, the following vulnerability has been resolved:\nnet/mlx5: Discard command completions in internal error\nFix use after free when FW completion arrives while device is in\ninternal error state. Avoid calling completion handler in this case,\nsince the device will flush the command interface and trigger all\ncompletions manually.\nKernel log:\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\n...\nRIP: 0010:refcount_warn_saturate+0xd8/0xe0\n...\nCall Trace:\n\u003cIRQ\u003e\n? __warn+0x79/0x120\n? refcount_warn_saturate+0xd8/0xe0\n? report_bug+0x17c/0x190\n? handle_bug+0x3c/0x60\n? exc_invalid_op+0x14/0x70\n? asm_exc_invalid_op+0x16/0x20\n? refcount_warn_saturate+0xd8/0xe0\ncmd_ent_put+0x13b/0x160 [mlx5_core]\nmlx5_cmd_comp_handler+0x5f9/0x670 [mlx5_core]\ncmd_comp_notifier+0x1f/0x30 [mlx5_core]\nnotifier_call_chain+0x35/0xb0\natomic_notifier_call_chain+0x16/0x20\nmlx5_eq_async_int+0xf6/0x290 [mlx5_core]\nnotifier_call_chain+0x35/0xb0\natomic_notifier_call_chain+0x16/0x20\nirq_int_handler+0x19/0x30 [mlx5_core]\n__handle_irq_event_percpu+0x4b/0x160\nhandle_irq_event+0x2e/0x80\nhandle_edge_irq+0x98/0x230\n__common_interrupt+0x3b/0xa0\ncommon_interrupt+0x7b/0xa0\n\u003c/IRQ\u003e\n\u003cTASK\u003e\nasm_common_interrupt+0x22/0x40\n\nCVE-2024-38573:\nIn the Linux kernel, the following vulnerability has been resolved:\ncppc_cpufreq: Fix possible null pointer dereference\ncppc_cpufreq_get_rate() and hisi_cppc_cpufreq_get_rate() can be called from\ndifferent places with various parameters. So cpufreq_cpu_get() can return\nnull as 'policy' in some circumstances.\nFix this bug by adding null return check.\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\n\nCVE-2024-38575:\nIn the Linux kernel, the following vulnerability has been resolved:\nwifi: brcmfmac: pcie: handle randbuf allocation failure\nThe kzalloc() in brcmf_pcie_download_fw_nvram() will return null\nif the physical memory has run out. As a result, if we use\nget_random_bytes() to generate random bytes in the randbuf, the\nnull pointer dereference bug will happen.\nIn order to prevent allocation failure, this patch adds a separate\nfunction using buffer on kernel stack to generate random bytes in\nthe randbuf, which could prevent the kernel stack from overflow.\n\nCVE-2024-38596:\nIn the Linux kernel, the following vulnerability has been resolved:\naf_unix: Fix data races in unix_release_sock/unix_stream_sendmsg\nA data-race condition has been identified in af_unix. In one data path,\nthe write function unix_release_sock() atomically writes to\nsk-\u003esk_shutdown using WRITE_ONCE. However, on the reader side,\nunix_stream_sendmsg() does not read it atomically. Consequently, this\nissue is causing the following KCSAN splat to occur:\nBUG: KCSAN: data-race in unix_release_sock / unix_stream_sendmsg\nwrite (marked) to 0xffff88867256ddbb of 1 bytes by task 7270 on cpu 28:\nunix_release_sock (net/unix/af_unix.c:640)\nunix_release (net/unix/af_unix.c:1050)\nsock_close (net/socket.c:659 net/socket.c:1421)\n__fput (fs/file_table.c:422)\n__fput_sync (fs/file_table.c:508)\n__se_sys_close (fs/open.c:1559 fs/open.c:1541)\n__x64_sys_close (fs/open.c:1541)\nx64_sys_call (arch/x86/entry/syscall_64.c:33)\ndo_syscall_64 (arch/x86/entry/common.c:?)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\nread to 0xffff88867256ddbb of 1 bytes by task 989 on cpu 14:\nunix_stream_sendmsg (net/unix/af_unix.c:2273)\n__sock_sendmsg (net/socket.c:730 net/socket.c:745)\n____sys_sendmsg (net/socket.c:2584)\n__sys_sendmmsg (net/socket.c:2638 net/socket.c:2724)\n__x64_sys_sendmmsg (net/socket.c:2753 net/socket.c:2750 net/socket.c:2750)\nx64_sys_call (arch/x86/entry/syscall_64.c:33)\ndo_syscall_64 (arch/x86/entry/common.c:?)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\nvalue changed: 0x01 -\u003e 0x03\nThe line numbers are related to commit dd5a440a31fa (\"Linux 6.9-rc7\").\nCommit e1d09c2c2f57 (\"af_unix: Fix data races around sk-\u003esk_shutdown.\")\naddressed a comparable issue in the past regarding sk-\u003esk_shutdown.\nHowever, it overlooked resolving this particular data path.\nThis patch only offending unix_stream_sendmsg() function, since the\nother reads seem to be protected by unix_state_lock() as discussed in\n\nCVE-2024-38598:\nIn the Linux kernel, the following vulnerability has been resolved:\nmd: fix resync softlockup when bitmap size is less than array size\nIs is reported that for dm-raid10, lvextend + lvchange --syncaction will\ntrigger following softlockup:\nkernel:watchdog: BUG: soft lockup - CPU#3 stuck for 26s! [mdX_resync:6976]\nCPU: 7 PID: 3588 Comm: mdX_resync Kdump: loaded Not tainted 6.9.0-rc4-next-20240419 #1\nRIP: 0010:_raw_spin_unlock_irq+0x13/0x30\nCall Trace:\n\u003cTASK\u003e\nmd_bitmap_start_sync+0x6b/0xf0\nraid10_sync_request+0x25c/0x1b40 [raid10]\nmd_do_sync+0x64b/0x1020\nmd_thread+0xa7/0x170\nkthread+0xcf/0x100\nret_from_fork+0x30/0x50\nret_from_fork_asm+0x1a/0x30\nAnd the detailed process is as follows:\nmd_do_sync\nj = mddev-\u003eresync_min\nwhile (j \u003c max_sectors)\nsectors = raid10_sync_request(mddev, j, \u0026skipped)\nif (!md_bitmap_start_sync(..., \u0026sync_blocks))\n// md_bitmap_start_sync set sync_blocks to 0\nreturn sync_blocks + sectors_skippe;\n// sectors = 0;\nj += sectors;\n// j never change\nRoot cause is that commit 301867b1c168 (\"md/raid10: check\nslab-out-of-bounds in md_bitmap_get_counter\") return early from\nmd_bitmap_get_counter(), without setting returned blocks.\nFix this problem by always set returned blocks from\nmd_bitmap_get_counter\"(), as it used to be.\nNoted that this patch just fix the softlockup problem in kernel, the\ncase that bitmap size doesn't match array size still need to be fixed.\n\nCVE-2024-38615:\nIn the Linux kernel, the following vulnerability has been resolved:\ncpufreq: exit() callback is optional\nThe exit() callback is optional and shouldn't be called without checking\na valid pointer first.\nAlso, we must clear freq_table pointer even if the exit() callback isn't\npresent.\n\nCVE-2024-38627:\nIn the Linux kernel, the following vulnerability has been resolved:\nstm class: Fix a double free in stm_register_device()\nThe put_device(\u0026stm-\u003edev) call will trigger stm_device_release() which\nfrees \"stm\" so the vfree(stm) on the next line is a double free.\n\nCVE-2024-39276:\nIn the Linux kernel, the following vulnerability has been resolved:\next4: fix mb_cache_entry's e_refcnt leak in ext4_xattr_block_cache_find()\nSyzbot reports a warning as follows:\n============================================\nWARNING: CPU: 0 PID: 5075 at fs/mbcache.c:419 mb_cache_destroy+0x224/0x290\nModules linked in:\nCPU: 0 PID: 5075 Comm: syz-executor199 Not tainted 6.9.0-rc6-gb947cc5bf6d7\nRIP: 0010:mb_cache_destroy+0x224/0x290 fs/mbcache.c:419\nCall Trace:\n\u003cTASK\u003e\next4_put_super+0x6d4/0xcd0 fs/ext4/super.c:1375\ngeneric_shutdown_super+0x136/0x2d0 fs/super.c:641\nkill_block_super+0x44/0x90 fs/super.c:1675\next4_kill_sb+0x68/0xa0 fs/ext4/super.c:7327\n[...]\n============================================\nThis is because when finding an entry in ext4_xattr_block_cache_find(), if\next4_sb_bread() returns -ENOMEM, the ce's e_refcnt, which has already grown\nin the __entry_find(), won't be put away, and eventually trigger the above\nissue in mb_cache_destroy() due to reference count leakage.\nSo call mb_cache_entry_put() on the -ENOMEM error branch as a quick fix.\n\nCVE-2024-39472:\nIn the Linux kernel, the following vulnerability has been resolved:\nxfs: fix log recovery buffer allocation for the legacy h_size fixup\nCommit a70f9fe52daa (\"xfs: detect and handle invalid iclog size set by\nmkfs\") added a fixup for incorrect h_size values used for the initial\numount record in old xfsprogs versions.  Later commit 0c771b99d6c9\n(\"xfs: clean up calculation of LR header blocks\") cleaned up the log\nreover buffer calculation, but stoped using the fixed up h_size value\nto size the log recovery buffer, which can lead to an out of bounds\naccess when the incorrect h_size does not come from the old mkfs\ntool, but a fuzzer.\nFix this by open coding xlog_logrec_hblks and taking the fixed h_size\ninto account for this calculation.\n\nCVE-2024-39476:\nIn the Linux kernel, the following vulnerability has been resolved:\nmd/raid5: fix deadlock that raid5d() wait for itself to clear MD_SB_CHANGE_PENDING\nXiao reported that lvm2 test lvconvert-raid-takeover.sh can hang with\nsmall possibility, the root cause is exactly the same as commit\nbed9e27baf52 (\"Revert \"md/raid5: Wait for MD_SB_CHANGE_PENDING in raid5d\"\")\nHowever, Dan reported another hang after that, and junxiao investigated\nthe problem and found out that this is caused by plugged bio can't issue\nfrom raid5d().\nCurrent implementation in raid5d() has a weird dependence:\n1) md_check_recovery() from raid5d() must hold 'reconfig_mutex' to clear\nMD_SB_CHANGE_PENDING;\n2) raid5d() handles IO in a deadloop, until all IO are issued;\n3) IO from raid5d() must wait for MD_SB_CHANGE_PENDING to be cleared;\nThis behaviour is introduce before v2.6, and for consequence, if other\ncontext hold 'reconfig_mutex', and md_check_recovery() can't update\nsuper_block, then raid5d() will waste one cpu 100% by the deadloop, until\n'reconfig_mutex' is released.\nRefer to the implementation from raid1 and raid10, fix this problem by\nskipping issue IO if MD_SB_CHANGE_PENDING is still set after\nmd_check_recovery(), daemon thread will be woken up when 'reconfig_mutex'\nis released. Meanwhile, the hang problem will be fixed as well.\n\nCVE-2024-39487:\nIn the Linux kernel, the following vulnerability has been resolved:\nbonding: Fix out-of-bounds read in bond_option_arp_ip_targets_set()\nIn function bond_option_arp_ip_targets_set(), if newval-\u003estring is an\nempty string, newval-\u003estring+1 will point to the byte after the\nstring, causing an out-of-bound read.\nBUG: KASAN: slab-out-of-bounds in strlen+0x7d/0xa0 lib/string.c:418\nRead of size 1 at addr ffff8881119c4781 by task syz-executor665/8107\nCPU: 1 PID: 8107 Comm: syz-executor665 Not tainted 6.7.0-rc7 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nCall Trace:\n\u003cTASK\u003e\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106\nprint_address_description mm/kasan/report.c:364 [inline]\nprint_report+0xc1/0x5e0 mm/kasan/report.c:475\nkasan_report+0xbe/0xf0 mm/kasan/report.c:588\nstrlen+0x7d/0xa0 lib/string.c:418\n__fortify_strlen include/linux/fortify-string.h:210 [inline]\nin4_pton+0xa3/0x3f0 net/core/utils.c:130\nbond_option_arp_ip_targets_set+0xc2/0x910\ndrivers/net/bonding/bond_options.c:1201\n__bond_opt_set+0x2a4/0x1030 drivers/net/bonding/bond_options.c:767\n__bond_opt_set_notify+0x48/0x150 drivers/net/bonding/bond_options.c:792\nbond_opt_tryset_rtnl+0xda/0x160 drivers/net/bonding/bond_options.c:817\nbonding_sysfs_store_option+0xa1/0x120 drivers/net/bonding/bond_sysfs.c:156\ndev_attr_store+0x54/0x80 drivers/base/core.c:2366\nsysfs_kf_write+0x114/0x170 fs/sysfs/file.c:136\nkernfs_fop_write_iter+0x337/0x500 fs/kernfs/file.c:334\ncall_write_iter include/linux/fs.h:2020 [inline]\nnew_sync_write fs/read_write.c:491 [inline]\nvfs_write+0x96a/0xd80 fs/read_write.c:584\nksys_write+0x122/0x250 fs/read_write.c:637\ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]\ndo_syscall_64+0x40/0x110 arch/x86/entry/common.c:83\nentry_SYSCALL_64_after_hwframe+0x63/0x6b\n---[ end trace ]---\nFix it by adding a check of string length before using it.\n\nCVE-2024-39502:\nIn the Linux kernel, the following vulnerability has been resolved:\nionic: fix use after netif_napi_del()\nWhen queues are started, netif_napi_add() and napi_enable() are called.\nIf there are 4 queues and only 3 queues are used for the current\nconfiguration, only 3 queues' napi should be registered and enabled.\nThe ionic_qcq_enable() checks whether the .poll pointer is not NULL for\nenabling only the using queue' napi. Unused queues' napi will not be\nregistered by netif_napi_add(), so the .poll pointer indicates NULL.\nBut it couldn't distinguish whether the napi was unregistered or not\nbecause netif_napi_del() doesn't reset the .poll pointer to NULL.\nSo, ionic_qcq_enable() calls napi_enable() for the queue, which was\nunregistered by netif_napi_del().\nReproducer:\nethtool -L \u003cinterface name\u003e rx 1 tx 1 combined 0\nethtool -L \u003cinterface name\u003e rx 0 tx 0 combined 1\nethtool -L \u003cinterface name\u003e rx 0 tx 0 combined 4\nSplat looks like:\nkernel BUG at net/core/dev.c:6666!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 3 PID: 1057 Comm: kworker/3:3 Not tainted 6.10.0-rc2+ #16\nWorkqueue: events ionic_lif_deferred_work [ionic]\nRIP: 0010:napi_enable+0x3b/0x40\nCode: 48 89 c2 48 83 e2 f6 80 b9 61 09 00 00 00 74 0d 48 83 bf 60 01 00 00 00 74 03 80 ce 01 f0 4f\nRSP: 0018:ffffb6ed83227d48 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff97560cda0828 RCX: 0000000000000029\nRDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff97560cda0a28\nRBP: ffffb6ed83227d50 R08: 0000000000000400 R09: 0000000000000001\nR10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000\nR13: ffff97560ce3c1a0 R14: 0000000000000000 R15: ffff975613ba0a20\nFS:  0000000000000000(0000) GS:ffff975d5f780000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f8f734ee200 CR3: 0000000103e50000 CR4: 00000000007506f0\nPKRU: 55555554\nCall Trace:\n\u003cTASK\u003e\n? die+0x33/0x90\n? do_trap+0xd9/0x100\n? napi_enable+0x3b/0x40\n? do_error_trap+0x83/0xb0\n? napi_enable+0x3b/0x40\n? napi_enable+0x3b/0x40\n? exc_invalid_op+0x4e/0x70\n? napi_enable+0x3b/0x40\n? asm_exc_invalid_op+0x16/0x20\n? napi_enable+0x3b/0x40\nionic_qcq_enable+0xb7/0x180 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\nionic_start_queues+0xc4/0x290 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\nionic_link_status_check+0x11c/0x170 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\nionic_lif_deferred_work+0x129/0x280 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\nprocess_one_work+0x145/0x360\nworker_thread+0x2bb/0x3d0\n? __pfx_worker_thread+0x10/0x10\nkthread+0xcc/0x100\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x2d/0x50\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n\nCVE-2024-40927:\nIn the Linux kernel, the following vulnerability has been resolved:\nxhci: Handle TD clearing for multiple streams case\nWhen multiple streams are in use, multiple TDs might be in flight when\nan endpoint is stopped. We need to issue a Set TR Dequeue Pointer for\neach, to ensure everything is reset properly and the caches cleared.\nChange the logic so that any N\u003e1 TDs found active for different streams\nare deferred until after the first one is processed, calling\nxhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() to\nqueue another command until we are done with all of them. Also change\nthe error/\"should never happen\" paths to ensure we at least clear any\naffected TDs, even if we can't issue a command to clear the hardware\ncache, and complain loudly with an xhci_warn() if this ever happens.\nThis problem case dates back to commit e9df17eb1408 (\"USB: xhci: Correct\nassumptions about number of rings per endpoint.\") early on in the XHCI\ndriver's life, when stream support was first added.\nIt was then identified but not fixed nor made into a warning in commit\n674f8438c121 (\"xhci: split handling halted endpoints into two steps\"),\nwhich added a FIXME comment for the problem case (without materially\nchanging the behavior as far as I can tell, though the new logic made\nthe problem more obvious).\nThen later, in commit 94f339147fc3 (\"xhci: Fix failure to give back some\ncached cancelled URBs.\"), it was acknowledged again.\n[Mathias: commit 94f339147fc3 (\"xhci: Fix failure to give back some cached\ncancelled URBs.\") was a targeted regression fix to the previously mentioned\npatch. Users reported issues with usb stuck after unmounting/disconnecting\nUAS devices. This rolled back the TD clearing of multiple streams to its\noriginal state.]\nApparently the commit author was aware of the problem (yet still chose\nto submit it): It was still mentioned as a FIXME, an xhci_dbg() was\nadded to log the problem condition, and the remaining issue was mentioned\nin the commit description. The choice of making the log type xhci_dbg()\nfor what is, at this point, a completely unhandled and known broken\ncondition is puzzling and unfortunate, as it guarantees that no actual\nusers would see the log in production, thereby making it nigh\nundebuggable (indeed, even if you turn on DEBUG, the message doesn't\nreally hint at there being a problem at all).\nIt took me *months* of random xHC crashes to finally find a reliable\nrepro and be able to do a deep dive debug session, which could all have\nbeen avoided had this unhandled, broken condition been actually reported\nwith a warning, as it should have been as a bug intentionally left in\nunfixed (never mind that it shouldn't have been left in at all).\n\u003e Another fix to solve clearing the caches of all stream rings with\n\u003e cancelled TDs is needed, but not as urgent.\n3 years after that statement and 14 years after the original bug was\nintroduced, I think it's finally time to fix it. And maybe next time\nlet's not leave bugs unfixed (that are actually worse than the original\nbug), and let's actually get people to review kernel commits please.\nFixes xHC crashes and IOMMU faults with UAS devices when handling\nerrors/faults. Easiest repro is to use `hdparm` to mark an early sector\n(e.g. 1024) on a disk as bad, then `cat /dev/sdX \u003e /dev/null` in a loop.\nAt least in the case of JMicron controllers, the read errors end up\nhaving to cancel two TDs (for two queued requests to different streams)\nand the one that didn't get cleared properly ends up faulting the xHC\nentirely when it tries to access DMA pages that have since been unmapped,\nreferred to by the stale TDs. This normally happens quickly (after two\nor three loops). After this fix, I left the `cat` in a loop running\novernight and experienced no xHC failures, with all read errors\nrecovered properly. Repro'd and tested on an Apple M1 Mac Mini\n(dwc3 host).\nOn systems without an IOMMU, this bug would instead silently corrupt\nfreed memory, making this a\n---truncated---\n\nCVE-2024-40974:\nIn the Linux kernel, the following vulnerability has been resolved:\npowerpc/pseries: Enforce hcall result buffer validity and size\nplpar_hcall(), plpar_hcall9(), and related functions expect callers to\nprovide valid result buffers of certain minimum size. Currently this\nis communicated only through comments in the code and the compiler has\nno idea.\nFor example, if I write a bug like this:\nlong retbuf[PLPAR_HCALL_BUFSIZE]; // should be PLPAR_HCALL9_BUFSIZE\nplpar_hcall9(H_ALLOCATE_VAS_WINDOW, retbuf, ...);\nThis compiles with no diagnostics emitted, but likely results in stack\ncorruption at runtime when plpar_hcall9() stores results past the end\nof the array. (To be clear this is a contrived example and I have not\nfound a real instance yet.)\nTo make this class of error less likely, we can use explicitly-sized\narray parameters instead of pointers in the declarations for the hcall\nAPIs. When compiled with -Warray-bounds[1], the code above now\nprovokes a diagnostic like this:\nerror: array argument is too small;\nis of size 32, callee requires at least 72 [-Werror,-Warray-bounds]\n60 |                 plpar_hcall9(H_ALLOCATE_VAS_WINDOW, retbuf,\n|                 ^                                   ~~~~~~\n[1] Enabled for LLVM builds but not GCC for now. See commit\n0da6e5fd6c37 (\"gcc: disable '-Warray-bounds' for gcc-13 too\") and\nrelated changes.\n\nCVE-2024-35962:\nIn the Linux kernel, the following vulnerability has been resolved:\nnetfilter: complete validation of user input\nIn my recent commit, I missed that do_replace() handlers\nuse copy_from_sockptr() (which I fixed), followed\nby unsafe copy_from_sockptr_offset() calls.\nIn all functions, we can perform the @optlen validation\nbefore even calling xt_alloc_table_info() with the following\ncheck:\nif ((u64)optlen \u0026amp;lt; (u64)tmp.size + sizeof(tmp))\nreturn -EINVAL;\n\nCVE-2024-36924:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Release hbalock before calling lpfc_worker_wake_up()\nlpfc_worker_wake_up() calls the lpfc_work_done() routine, which takes the\nhbalock.  Thus, lpfc_worker_wake_up() should not be called while holding the\nhbalock to avoid potential deadlock.\n\nCVE-2024-36952:\nIn the Linux kernel, the following vulnerability has been resolved:\nscsi: lpfc: Move NPIV's transport unregistration to after resource clean up\nThere are cases after NPIV deletion where the fabric switch still believes\nthe NPIV is logged into the fabric.  This occurs when a vport is\nunregistered before the Remove All DA_ID CT and LOGO ELS are sent to the\nfabric.\nCurrently fc_remove_host(), which calls dev_loss_tmo for all D_IDs including\nthe fabric D_ID, removes the last ndlp reference and frees the ndlp rport\nobject.  This sometimes causes the race condition where the final DA_ID and\nLOGO are skipped from being sent to the fabric switch.\nFix by moving the fc_remove_host() and scsi_remove_host() calls after DA_ID\nand LOGO are sent.",
    "Advisory": {
      "Severity": "Moderate",
      "Issued": {
        "Date": "2024-08-13"
      },
      "Updated": {
        "Date": "2024-09-20"
      },
      "Cves": [
        {
          "ID": "CVE-2021-46939",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-46939",
          "CWE": "CWE-833",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47018",
          "CVSS3": "7.8/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47018",
          "CWE": "CWE-20",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47257",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47257",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47284",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47284",
          "CWE": "CWE-590",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47304",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47304",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47373",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47373",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47408",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47408",
          "CWE": "CWE-667",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47461",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47461",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47468",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47468",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47491",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47491",
          "CWE": "CWE-664",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47548",
          "CVSS3": "6.0/CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47548",
          "CWE": "CWE-129",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47579",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47579",
          "CWE": "CWE-457",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2021-47624",
          "CVSS3": "6.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:L",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2021-47624",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2022-48632",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48632",
          "CWE": "CWE-122",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2022-48743",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48743",
          "CWE": "CWE-124",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2022-48747",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48747",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2022-48757",
          "CVSS3": "3.3/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2022-48757",
          "CWE": "CWE-276",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-28746",
          "CVSS3": "6.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-28746",
          "CWE": "CWE-1342",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52451",
          "CVSS3": "7.8/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52451",
          "CWE": "CWE-125",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52463",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52463",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52469",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52469",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52471",
          "CVSS3": "2.3/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:L",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52471",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52486",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52486",
          "CWE": "CWE-833",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52530",
          "CVSS3": "5.8/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52530",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52619",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52619",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52622",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52622",
          "CWE": "CWE-131",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52623",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52623",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52648",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52648",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52653",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52653",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52658",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52658",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52662",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52662",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52679",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52679",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52707",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52707",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52730",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52730",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52756",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52756",
          "CWE": "CWE-120",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52762",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52762",
          "CWE": "CWE-121",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52764",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52764",
          "CWE": "CWE-125",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52775",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52775",
          "CWE": "CWE-20",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52777",
          "CVSS3": "5.2/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52777",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52784",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52784",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52791",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52791",
          "CWE": "CWE-459",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52796",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52796",
          "CWE": "CWE-121",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52803",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52803",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52811",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52811",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52832",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52832",
          "CWE": "CWE-190",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52834",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52834",
          "CWE": "CWE-125",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52845",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52845",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52847",
          "CVSS3": "5.2/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52847",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2023-52864",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2023-52864",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-21823",
          "CVSS3": "6.4/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-21823",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-2201",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-2201",
          "CWE": "CWE-1423",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-25739",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-25739",
          "CWE": "CWE-754",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26586",
          "CVSS3": "6.7/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26586",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26614",
          "CVSS3": "3.3/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26614",
          "CWE": "CWE-413",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26640",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26640",
          "CWE": "CWE-20",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26660",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26660",
          "CWE": "CWE-125",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26669",
          "CVSS3": "7.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26669",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26686",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26686",
          "CWE": "CWE-413",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26698",
          "CVSS3": "4.1/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26698",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26704",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26704",
          "CWE": "CWE-415",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26733",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26733",
          "CWE": "CWE-122",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26740",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26740",
          "CWE": "CWE-833",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26772",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26772",
          "CWE": "CWE-229",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26773",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26773",
          "CWE": "CWE-229",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26802",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26802",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26810",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26810",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26837",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26837",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26840",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26840",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26843",
          "CVSS3": "6.0/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26843",
          "CWE": "CWE-121",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26852",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26852",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26853",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26853",
          "CWE": "CWE-20",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26870",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26870",
          "CWE": "CWE-20",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26878",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26878",
          "CWE": "CWE-362-\u003eCWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26908",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26908",
          "CWE": "CWE-690",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26921",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26921",
          "CWE": "CWE-124",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26925",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26925",
          "CWE": "CWE-667",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26940",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26940",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26958",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26958",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26960",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26960",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-26961",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-26961",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27010",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27010",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27011",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27011",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27019",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27019",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27020",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27020",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27025",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27025",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27065",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27065",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27388",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27388",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27395",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27395",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-27434",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-27434",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-31076",
          "CVSS3": "5.1/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:L",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-31076",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-33621",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-33621",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35790",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35790",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35801",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35801",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35807",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35807",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35810",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35810",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35814",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35814",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35823",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35823",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35824",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35824",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35847",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35847",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35876",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35876",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35893",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35893",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35896",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35896",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35897",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35897",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35899",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35899",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35900",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35900",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35910",
          "CVSS3": "5.8/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35910",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35912",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35912",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35924",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35924",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35925",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35925",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35930",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35930",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35937",
          "CVSS3": "5.8/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35937",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35938",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35938",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35946",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35946",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35947",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35947",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35952",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35952",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36000",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36000",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36005",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36005",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36006",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36006",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36010",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36010",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36016",
          "CVSS3": "6.4/CVSS:3.1/AV:A/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36016",
          "CWE": "CWE-787",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36017",
          "CVSS3": "6.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36017",
          "CWE": "CWE-125",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36020",
          "CVSS3": "5.3/CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36020",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36025",
          "CVSS3": "5.2/CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36025",
          "CWE": "CWE-787",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36270",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36270",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36286",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36286",
          "CWE": "CWE-667",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36489",
          "CVSS3": "6.1/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:L",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36489",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36886",
          "CVSS3": "7.1/CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36886",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36889",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36889",
          "CWE": "CWE-665",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36896",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36896",
          "CWE": "CWE-170",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36904",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36904",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36905",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36905",
          "CWE": "CWE-369",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36917",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36917",
          "CWE": "CWE-190",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36921",
          "CVSS3": "6.7/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36921",
          "CWE": "CWE-125",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36927",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36927",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36929",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36929",
          "CWE": "CWE-822",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36933",
          "CVSS3": "5.9/CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36933",
          "CWE": "CWE-457",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36940",
          "CVSS3": "2.3/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:L",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36940",
          "CWE": "CWE-415",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36941",
          "CVSS3": "5.7/CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36941",
          "CWE": "CWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36945",
          "CVSS3": "3.3/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L",
          "Impact": "Low",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36945",
          "CWE": "CWE-401",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36950",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36950",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36954",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36954",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36960",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36960",
          "CWE": "CWE-125",
          "Public": "20240602"
        },
        {
          "ID": "CVE-2024-36971",
          "CVSS3": "7.0/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Important",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36971",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36978",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36978",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-36979",
          "CVSS3": "6.6/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36979",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38538",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38538",
          "CWE": "CWE-99",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38555",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38555",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38573",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38573",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38575",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38575",
          "CWE": "CWE-400-\u003eCWE-476",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38596",
          "CVSS3": "4.7/CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38596",
          "CWE": "CWE-362",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38598",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38598",
          "CWE": "CWE-667",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38615",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38615",
          "CWE": "CWE-459",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-38627",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-38627",
          "CWE": "CWE-415",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-39276",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39276",
          "CWE": "CWE-402",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-39472",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39472",
          "CWE": "CWE-119",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-39476",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39476",
          "CWE": "CWE-833",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-39487",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39487",
          "CWE": "",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-39502",
          "CVSS3": "6.7/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-39502",
          "CWE": "CWE-416",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-40927",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40927",
          "CWE": "CWE-820",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-40974",
          "CVSS3": "6.6/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-40974",
          "CWE": "CWE-119",
          "Public": "20240813"
        },
        {
          "ID": "CVE-2024-35962",
          "CVSS3": "5.5/CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-35962",
          "CWE": "",
          "Public": "20240920"
        },
        {
          "ID": "CVE-2024-36924",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36924",
          "CWE": "CWE-833",
          "Public": "20240530"
        },
        {
          "ID": "CVE-2024-36952",
          "CVSS3": "4.4/CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
          "Impact": "Moderate",
          "Href": "https://anas.openanolis.cn/cves/detail/CVE-2024-36952",
          "CWE": "CWE-459",
          "Public": "20240530"
        }
      ],
      "AffectedCpeList": [
        "cpe:2.3:o:openanolis:anolis_os:8:*:*:*:*:*:*:* "
      ]
    }
  },
  "Criteria": {
    "Operator": "AND",
    "Criterias": [
      {
        "Operator": "OR",
        "Criterias": null,
        "Criterions": [
          {
            "Comment": "bpftool is earlier than 0:4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789001"
          },
          {
            "Comment": "kernel is earlier than 0:4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789002"
          },
          {
            "Comment": "kernel-core is earlier than 0:core-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789003"
          },
          {
            "Comment": "kernel-cross-headers is earlier than 0:cross-headers-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789004"
          },
          {
            "Comment": "kernel-debug is earlier than 0:debug-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789005"
          },
          {
            "Comment": "kernel-debug-core is earlier than 0:debug-core-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789006"
          },
          {
            "Comment": "kernel-debug-devel is earlier than 0:debug-devel-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789007"
          },
          {
            "Comment": "kernel-debug-modules is earlier than 0:debug-modules-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789008"
          },
          {
            "Comment": "kernel-debug-modules-extra is earlier than 0:debug-modules-extra-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789009"
          },
          {
            "Comment": "kernel-devel is earlier than 0:devel-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789010"
          },
          {
            "Comment": "kernel-headers is earlier than 0:headers-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789011"
          },
          {
            "Comment": "kernel-modules is earlier than 0:modules-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789012"
          },
          {
            "Comment": "kernel-modules-extra is earlier than 0:modules-extra-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789013"
          },
          {
            "Comment": "kernel-tools is earlier than 0:tools-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789014"
          },
          {
            "Comment": "kernel-tools-libs is earlier than 0:tools-libs-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789015"
          },
          {
            "Comment": "kernel-tools-libs-devel is earlier than 0:tools-libs-devel-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789016"
          },
          {
            "Comment": "perf is earlier than 0:4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789017"
          },
          {
            "Comment": "python3-perf is earlier than 0:perf-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789018"
          },
          {
            "Comment": "kernel-abi-stablelists is earlier than 0:abi-stablelists-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789019"
          },
          {
            "Comment": "kernel-doc is earlier than 0:doc-4.18.0-553.16.1.0.1.an8",
            "TestRef": "oval:cn.openanolis:tst:20240789020"
          }
        ]
      }
    ],
    "Criterions": [
      {
        "Comment": "Anolis OS 8 is installed",
        "TestRef": "oval:cn.openanolis:tst:1"
      }
    ]
  }
}